diff -crBN linux-2.4.27/arch/arm/def-configs/a5k linux-2.4.27-w/arch/arm/def-configs/a5k
*** linux-2.4.27/arch/arm/def-configs/a5k	2004-02-18 05:36:30.000000000 -0800
--- linux-2.4.27-w/arch/arm/def-configs/a5k	2013-01-22 23:25:49.521023184 -0800
***************
*** 75,92 ****
  CONFIG_NWFPE=y
  CONFIG_KCORE_ELF=y
  # CONFIG_KCORE_AOUT is not set
! CONFIG_BINFMT_AOUT=y
  # CONFIG_BINFMT_ELF is not set
  # CONFIG_BINFMT_MISC is not set
  # CONFIG_PM is not set
  
  #
  # Parallel port support
  #
! CONFIG_PARPORT=m
! CONFIG_PARPORT_PC=m
  # CONFIG_PARPORT_PC_FIFO is not set
! CONFIG_PARPORT_PC_SUPERIO=y
  # CONFIG_PARPORT_ARC is not set
  # CONFIG_PARPORT_AMIGA is not set
  # CONFIG_PARPORT_MFC3 is not set
--- 75,93 ----
  CONFIG_NWFPE=y
  CONFIG_KCORE_ELF=y
  # CONFIG_KCORE_AOUT is not set
! # CONFIG_BINFMT_AOUT is not set
  # CONFIG_BINFMT_ELF is not set
  # CONFIG_BINFMT_MISC is not set
  # CONFIG_PM is not set
+ CONFIG_CMDLINE="console=ttyAM0 mem=8M root=/dev/ram"
  
  #
  # Parallel port support
  #
! # CONFIG_PARPORT is not set
! # CONFIG_PARPORT_PC is not set
  # CONFIG_PARPORT_PC_FIFO is not set
! # CONFIG_PARPORT_PC_SUPERIO is not set
  # CONFIG_PARPORT_ARC is not set
  # CONFIG_PARPORT_AMIGA is not set
  # CONFIG_PARPORT_MFC3 is not set
***************
*** 109,115 ****
  #
  # Block devices
  #
! CONFIG_BLK_DEV_FD=y
  # CONFIG_BLK_DEV_XD is not set
  # CONFIG_PARIDE is not set
  # CONFIG_BLK_CPQ_DA is not set
--- 110,116 ----
  #
  # Block devices
  #
! # CONFIG_BLK_DEV_FD is not set
  # CONFIG_BLK_DEV_XD is not set
  # CONFIG_PARIDE is not set
  # CONFIG_BLK_CPQ_DA is not set
***************
*** 186,194 ****
  #
  # Ethernet (10 or 100Mbit)
  #
! CONFIG_NET_ETHERNET=y
! CONFIG_ARM_ETHER1=y
! CONFIG_ARM_ETHER3=y
  # CONFIG_ARM_ETHERH is not set
  # CONFIG_NET_VENDOR_3COM is not set
  # CONFIG_LANCE is not set
--- 187,195 ----
  #
  # Ethernet (10 or 100Mbit)
  #
! # CONFIG_NET_ETHERNET is not set
! # CONFIG_ARM_ETHER1 is not set
! # CONFIG_ARM_ETHER3 is not set
  # CONFIG_ARM_ETHERH is not set
  # CONFIG_NET_VENDOR_3COM is not set
  # CONFIG_LANCE is not set
***************
*** 244,262 ****
  #
  # ATA/IDE/MFM/RLL support
  #
! CONFIG_IDE=y
  
  #
  # IDE, ATA and ATAPI Block devices
  #
! CONFIG_BLK_DEV_IDE=y
  
  #
  # Please see Documentation/ide.txt for help/info on IDE drives
  #
  # CONFIG_BLK_DEV_HD_IDE is not set
  # CONFIG_BLK_DEV_HD is not set
! CONFIG_BLK_DEV_IDEDISK=y
  # CONFIG_IDEDISK_MULTI_MODE is not set
  # CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
  # CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
--- 245,263 ----
  #
  # ATA/IDE/MFM/RLL support
  #
! # CONFIG_IDE is not set
  
  #
  # IDE, ATA and ATAPI Block devices
  #
! # CONFIG_BLK_DEV_IDE is not set
  
  #
  # Please see Documentation/ide.txt for help/info on IDE drives
  #
  # CONFIG_BLK_DEV_HD_IDE is not set
  # CONFIG_BLK_DEV_HD is not set
! # CONFIG_BLK_DEV_IDEDISK is not set
  # CONFIG_IDEDISK_MULTI_MODE is not set
  # CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
  # CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
***************
*** 279,285 ****
  # CONFIG_BLK_DEV_CMD640 is not set
  # CONFIG_BLK_DEV_CMD640_ENHANCED is not set
  # CONFIG_BLK_DEV_ISAPNP is not set
! CONFIG_BLK_DEV_IDE_ICSIDE=y
  # CONFIG_BLK_DEV_IDEDMA_ICS is not set
  # CONFIG_IDEDMA_ICS_AUTO is not set
  # CONFIG_BLK_DEV_IDEDMA is not set
--- 280,286 ----
  # CONFIG_BLK_DEV_CMD640 is not set
  # CONFIG_BLK_DEV_CMD640_ENHANCED is not set
  # CONFIG_BLK_DEV_ISAPNP is not set
! # CONFIG_BLK_DEV_IDE_ICSIDE is not set
  # CONFIG_BLK_DEV_IDEDMA_ICS is not set
  # CONFIG_IDEDMA_ICS_AUTO is not set
  # CONFIG_BLK_DEV_IDEDMA is not set
***************
*** 314,343 ****
  CONFIG_VT_CONSOLE=y
  CONFIG_SERIAL=y
  CONFIG_SERIAL_CONSOLE=y
  # CONFIG_ATOMWIDE_SERIAL is not set
  # CONFIG_DUALSP_SERIAL is not set
  # CONFIG_SERIAL_EXTENDED is not set
! # CONFIG_SERIAL_NONSTANDARD is not set
! # CONFIG_UNIX98_PTYS is not set
  # CONFIG_PRINTER is not set
  # CONFIG_PPDEV is not set
  
  #
  # I2C support
  #
! CONFIG_I2C=y
! CONFIG_I2C_ALGOBIT=y
  # CONFIG_I2C_PHILIPSPAR is not set
  # CONFIG_I2C_ELV is not set
  # CONFIG_I2C_VELLEMAN is not set
  # CONFIG_I2C_ALGOPCF is not set
! CONFIG_I2C_CHARDEV=y
  
  #
  # Mice
  #
  # CONFIG_BUSMOUSE is not set
! CONFIG_MOUSE=y
  # CONFIG_PSMOUSE is not set
  # CONFIG_82C710_MOUSE is not set
  # CONFIG_PC110_PAD is not set
--- 315,356 ----
  CONFIG_VT_CONSOLE=y
  CONFIG_SERIAL=y
  CONFIG_SERIAL_CONSOLE=y
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
  # CONFIG_ATOMWIDE_SERIAL is not set
  # CONFIG_DUALSP_SERIAL is not set
  # CONFIG_SERIAL_EXTENDED is not set
! CONFIG_SERIAL_NONSTANDARD=y
! CONFIG_UNIX98_PTYS=y
! CONFIG_UNIX98_PTY_COUNT=8
  # CONFIG_PRINTER is not set
  # CONFIG_PPDEV is not set
  
  #
+ # Serial drivers
+ #
+ # CONFIG_SERIAL_ANAKIN is not set
+ # CONFIG_SERIAL_ANAKIN_CONSOLE is not set
+ CONFIG_SERIAL_AMBA=y
+ CONFIG_SERIAL_AMBA_CONSOLE=y
+ CONFIG_SERIAL_INTEGRATOR=y
+ 
+ #
  # I2C support
  #
! # CONFIG_I2C is not set
! # CONFIG_I2C_ALGOBIT is not set
  # CONFIG_I2C_PHILIPSPAR is not set
  # CONFIG_I2C_ELV is not set
  # CONFIG_I2C_VELLEMAN is not set
  # CONFIG_I2C_ALGOPCF is not set
! # CONFIG_I2C_CHARDEV is not set
  
  #
  # Mice
  #
  # CONFIG_BUSMOUSE is not set
! # CONFIG_MOUSE is not set
  # CONFIG_PSMOUSE is not set
  # CONFIG_82C710_MOUSE is not set
  # CONFIG_PC110_PAD is not set
***************
*** 381,394 ****
  # CONFIG_AFFS_FS is not set
  # CONFIG_HFS_FS is not set
  # CONFIG_BFS_FS is not set
! CONFIG_FAT_FS=m
! CONFIG_MSDOS_FS=m
  # CONFIG_UMSDOS_FS is not set
  # CONFIG_VFAT_FS is not set
  # CONFIG_EFS_FS is not set
  # CONFIG_JFFS_FS is not set
  # CONFIG_CRAMFS is not set
! # CONFIG_RAMFS is not set
  # CONFIG_ISO9660_FS is not set
  # CONFIG_JOLIET is not set
  # CONFIG_MINIX_FS is not set
--- 394,407 ----
  # CONFIG_AFFS_FS is not set
  # CONFIG_HFS_FS is not set
  # CONFIG_BFS_FS is not set
! # CONFIG_FAT_FS is not set
! # CONFIG_MSDOS_FS is not set
  # CONFIG_UMSDOS_FS is not set
  # CONFIG_VFAT_FS is not set
  # CONFIG_EFS_FS is not set
  # CONFIG_JFFS_FS is not set
  # CONFIG_CRAMFS is not set
! CONFIG_RAMFS=y
  # CONFIG_ISO9660_FS is not set
  # CONFIG_JOLIET is not set
  # CONFIG_MINIX_FS is not set
***************
*** 400,405 ****
--- 413,419 ----
  # CONFIG_DEVFS_MOUNT is not set
  # CONFIG_DEVFS_DEBUG is not set
  # CONFIG_DEVPTS_FS is not set
+ CONFIG_DEVPTS_FS=y
  # CONFIG_QNX4FS_FS is not set
  # CONFIG_QNX4FS_RW is not set
  # CONFIG_ROMFS_FS is not set
***************
*** 415,427 ****
  # Network File Systems
  #
  # CONFIG_CODA_FS is not set
! CONFIG_NFS_FS=y
  # CONFIG_NFS_V3 is not set
  # CONFIG_ROOT_NFS is not set
  # CONFIG_NFSD is not set
  # CONFIG_NFSD_V3 is not set
! CONFIG_SUNRPC=y
! CONFIG_LOCKD=y
  # CONFIG_SMB_FS is not set
  # CONFIG_NCP_FS is not set
  # CONFIG_NCPFS_PACKET_SIGNING is not set
--- 429,441 ----
  # Network File Systems
  #
  # CONFIG_CODA_FS is not set
! # CONFIG_NFS_FS is not set
  # CONFIG_NFS_V3 is not set
  # CONFIG_ROOT_NFS is not set
  # CONFIG_NFSD is not set
  # CONFIG_NFSD_V3 is not set
! # CONFIG_SUNRPC is not set
! # CONFIG_LOCKD is not set
  # CONFIG_SMB_FS is not set
  # CONFIG_NCP_FS is not set
  # CONFIG_NCPFS_PACKET_SIGNING is not set
***************
*** 443,451 ****
  CONFIG_ACORN_PARTITION=y
  CONFIG_ACORN_PARTITION_ADFS=y
  CONFIG_ACORN_PARTITION_ICS=y
! CONFIG_ACORN_PARTITION_POWERTEC=y
! CONFIG_ACORN_PARTITION_RISCIX=y
! CONFIG_NLS=y
  
  #
  # Native Language Support
--- 457,466 ----
  CONFIG_ACORN_PARTITION=y
  CONFIG_ACORN_PARTITION_ADFS=y
  CONFIG_ACORN_PARTITION_ICS=y
! # CONFIG_ACORN_PARTITION_POWERTEC is not set
! # CONFIG_ACORN_PARTITION_RISCIXis not set
! # CONFIG_SMB_NLS is not set
! # CONFIG_NLS is not set
  
  #
  # Native Language Support
***************
*** 488,517 ****
  #
  # Console drivers
  #
! CONFIG_FB=y
  
  #
  # Frame-buffer support
  #
! CONFIG_FB=y
! CONFIG_DUMMY_CONSOLE=y
! CONFIG_FB_ACORN=y
  # CONFIG_FB_CYBER2000 is not set
  # CONFIG_FB_VIRTUAL is not set
  # CONFIG_FBCON_ADVANCED is not set
! CONFIG_FBCON_MFB=y
! CONFIG_FBCON_CFB2=y
! CONFIG_FBCON_CFB4=y
! CONFIG_FBCON_CFB8=y
  # CONFIG_FBCON_FONTWIDTH8_ONLY is not set
! CONFIG_FBCON_FONTS=y
  # CONFIG_FONT_8x8 is not set
  # CONFIG_FONT_8x16 is not set
  # CONFIG_FONT_SUN8x16 is not set
  # CONFIG_FONT_SUN12x22 is not set
  # CONFIG_FONT_6x11 is not set
  # CONFIG_FONT_PEARL_8x8 is not set
! CONFIG_FONT_ACORN_8x8=y
  
  #
  # Sound
--- 503,531 ----
  #
  # Console drivers
  #
! # CONFIG_FB is not set
  
  #
  # Frame-buffer support
  #
! # CONFIG_DUMMY_CONSOLE is not set
! # CONFIG_FB_ACORN is not set
  # CONFIG_FB_CYBER2000 is not set
  # CONFIG_FB_VIRTUAL is not set
  # CONFIG_FBCON_ADVANCED is not set
! # CONFIG_FBCON_MFB is not set
! # CONFIG_FBCON_CFB2 is not set
! # CONFIG_FBCON_CFB4 is not set
! # CONFIG_FBCON_CFB8 is not set
  # CONFIG_FBCON_FONTWIDTH8_ONLY is not set
! # CONFIG_FBCON_FONTS is not set
  # CONFIG_FONT_8x8 is not set
  # CONFIG_FONT_8x16 is not set
  # CONFIG_FONT_SUN8x16 is not set
  # CONFIG_FONT_SUN12x22 is not set
  # CONFIG_FONT_6x11 is not set
  # CONFIG_FONT_PEARL_8x8 is not set
! # CONFIG_FONT_ACORN_8x8 is not set
  
  #
  # Sound
diff -crBN linux-2.4.27/arch/arm/kernel/arch.c linux-2.4.27-w/arch/arm/kernel/arch.c
*** linux-2.4.27/arch/arm/kernel/arch.c	2003-08-25 04:44:39.000000000 -0700
--- linux-2.4.27-w/arch/arm/kernel/arch.c	2013-01-22 23:03:30.311023651 -0800
***************
*** 98,105 ****
  MACHINE_END
  #endif
  #ifdef CONFIG_ARCH_A5K
! MACHINE_START(A5K, "Acorn-A5000")
! 	MAINTAINER("Russell King")
  	BOOT_PARAMS(0x0207c000)
  	INITIRQ(genarch_init_irq)
  MACHINE_END
--- 98,105 ----
  MACHINE_END
  #endif
  #ifdef CONFIG_ARCH_A5K
! MACHINE_START(A5K, "Amber-FPGA-System")
! 	MAINTAINER("Conor Santifort")
  	BOOT_PARAMS(0x0207c000)
  	INITIRQ(genarch_init_irq)
  MACHINE_END
diff -crBN linux-2.4.27/arch/arm/kernel/ecard.c linux-2.4.27-w/arch/arm/kernel/ecard.c
*** linux-2.4.27/arch/arm/kernel/ecard.c	2003-08-25 04:44:39.000000000 -0700
--- linux-2.4.27-w/arch/arm/kernel/ecard.c	2013-01-22 23:03:30.311023651 -0800
***************
*** 42,48 ****
  #include <linux/timer.h>
  #include <linux/init.h>
  #include <linux/ioport.h>
! 
  #include <asm/dma.h>
  #include <asm/ecard.h>
  #include <asm/hardware.h>
--- 42,48 ----
  #include <linux/timer.h>
  #include <linux/init.h>
  #include <linux/ioport.h>
! #include <asm-arm/arch-rpc/hardware.h>
  #include <asm/dma.h>
  #include <asm/ecard.h>
  #include <asm/hardware.h>
***************
*** 1060,1065 ****
--- 1060,1066 ----
   */
  void __init ecard_init(void)
  {
+ #if 0
  	int slot;
  
  #ifdef CONFIG_CPU_32
***************
*** 1086,1091 ****
--- 1087,1094 ----
  	}
  
  	ecard_proc_init();
+ #endif
+         
  }
  
  /*
diff -crBN linux-2.4.27/arch/arm/kernel/entry-armo.S linux-2.4.27-w/arch/arm/kernel/entry-armo.S
*** linux-2.4.27/arch/arm/kernel/entry-armo.S	2001-08-12 11:13:59.000000000 -0700
--- linux-2.4.27-w/arch/arm/kernel/entry-armo.S	2013-01-22 23:03:30.321023651 -0800
***************
*** 345,354 ****
  		ldr	lr, [lr]
  		save_user_regs
  
! 1:		get_irqnr_and_base r6, r5
! 		teq	r6, #0
! 		ldrneb	r0, [r5, r6]			@ get IRQ number
! 		movne	r1, sp
  		@
  		@ routine called with r0 = irq number, r1 = struct pt_regs *
  		@
--- 345,371 ----
  		ldr	lr, [lr]
  		save_user_regs
  
! 1:		mov     r4, #0x14000000
!                 ldr     r6, [r4]
!                 
!                 @ Check if there is any interrupt bit set
!                 cmp     r6, #0
!                 beq     3f
!                 
!                 @ ok at least 1 interrupt bit is set, find it
!                 mov     r0, #0
!                 mov     r4, #1
!                 mov     r5, #0
!                 
! 2:              add     r5, r5, r4, lsl r0
!                 add     r0, r0, #1
!                 cmp     r0, #32
!                 beq     3f
!                 tst     r5, r6
!                 beq     2b
!                 sub     r0, r0, #1
! 		mov	r1, sp
!                 
  		@
  		@ routine called with r0 = irq number, r1 = struct pt_regs *
  		@
***************
*** 356,363 ****
  		orr	lr, lr, #0x08000003		@ Force SVC
  		bne	do_IRQ
  
! 		mov	why, #0
! 		get_current_task r5
  		b	ret_to_user
  
  		irq_prio_table
--- 373,380 ----
  		orr	lr, lr, #0x08000003		@ Force SVC
  		bne	do_IRQ
  
! 3:		mov	why, #0
! 		get_current_task r9  @ tsk = r9 in entry-common.S
  		b	ret_to_user
  
  		irq_prio_table
***************
*** 368,384 ****
                  and	r2, lr, #3
  		teq	r2, #3
  		bne	__irq_invalid
! 1:		get_irqnr_and_base r6, r5
! 		teq	r6, #0
! 		ldrneb	r0, [r5, r6]			@ get IRQ number
! 		movne	r1, sp
  		@
  		@ routine called with r0 = irq number, r1 = struct pt_regs *
  		@
  		adr	lr, 1b
  		orr	lr, lr, #0x08000003		@ Force SVC
  		bne	do_IRQ				@ Returns to 1b
! 		SVC_RESTORE_ALL
  
  __irq_invalid:	mov	r0, sp
  		mov	r1, #BAD_IRQ
--- 385,420 ----
                  and	r2, lr, #3
  		teq	r2, #3
  		bne	__irq_invalid
!                 
! 1:		mov     r4, #0x14000000
!                 ldr     r6, [r4]
!                 
!                 @ Check if there is any interrupt bit set
!                 cmp     r6, #0
!                 beq     3f
!                 
!                 @ ok at least 1 interrupt bit is set, find it
!                 mov     r0, #0
!                 mov     r4, #1
!                 mov     r5, #0
!                 
! 2:              add     r5, r5, r4, lsl r0
!                 add     r0, r0, #1
!                 cmp     r0, #32
!                 beq     3f
!                 tst     r5, r6
!                 beq     2b
!                 sub     r0, r0, #1
! 		mov	r1, sp
! 
  		@
  		@ routine called with r0 = irq number, r1 = struct pt_regs *
  		@
  		adr	lr, 1b
  		orr	lr, lr, #0x08000003		@ Force SVC
  		bne	do_IRQ				@ Returns to 1b
! 3:		SVC_RESTORE_ALL
! 
  
  __irq_invalid:	mov	r0, sp
  		mov	r1, #BAD_IRQ
diff -crBN linux-2.4.27/arch/arm/kernel/io.c linux-2.4.27-w/arch/arm/kernel/io.c
*** linux-2.4.27/arch/arm/kernel/io.c	2001-04-12 12:20:31.000000000 -0700
--- linux-2.4.27-w/arch/arm/kernel/io.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 9,18 ****
   */
  void _memcpy_fromio(void * to, unsigned long from, size_t count)
  {
  	while (count) {
  		count--;
! 		*(char *) to = readb(from);
! 		((char *) to)++;
  		from++;
  	}
  }
--- 9,20 ----
   */
  void _memcpy_fromio(void * to, unsigned long from, size_t count)
  {
+         char * chto = (char *) to;
+         
  	while (count) {
  		count--;
! 		*chto = readb(from);
! 		chto++;
  		from++;
  	}
  }
***************
*** 23,32 ****
   */
  void _memcpy_toio(unsigned long to, const void * from, size_t count)
  {
  	while (count) {
  		count--;
! 		writeb(*(char *) from, to);
! 		((char *) from)++;
  		to++;
  	}
  }
--- 25,35 ----
   */
  void _memcpy_toio(unsigned long to, const void * from, size_t count)
  {
+         char * chfrom = (char *) from;
  	while (count) {
  		count--;
! 		writeb(*chfrom, to);
! 		chfrom++;
  		to++;
  	}
  }
diff -crBN linux-2.4.27/arch/arm/kernel/process.SS linux-2.4.27-w/arch/arm/kernel/process.SS
*** linux-2.4.27/arch/arm/kernel/process.SS	1969-12-31 16:00:00.000000000 -0800
--- linux-2.4.27-w/arch/arm/kernel/process.SS	2013-01-22 23:03:30.321023651 -0800
***************
*** 0 ****
--- 1,761 ----
+ 	.file	"process.c"
+ 	.text
+ 	.align	2
+ 	.type	get_current, %function
+ get_current:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	mov	r3, sp
+ 	bic	r0, r3, #8128
+ 	bic	r0, r0, #63
+ 	mov	pc, lr
+ 	.size	get_current, .-get_current
+ 	.section	.text.init,"ax",%progbits
+ 	.align	2
+ 	.type	nohlt_setup, %function
+ nohlt_setup:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	mov	r0, #1
+ 	ldr	r3, .L3
+ 	str	r0, [r3, #0]
+ 	mov	pc, lr
+ .L4:
+ 	.align	2
+ .L3:
+ 	.word	.LANCHOR0
+ 	.size	nohlt_setup, .-nohlt_setup
+ 	.align	2
+ 	.type	hlt_setup, %function
+ hlt_setup:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	mov	r2, #0
+ 	ldr	r3, .L6
+ 	str	r2, [r3, #0]
+ 	mov	r0, #1
+ 	mov	pc, lr
+ .L7:
+ 	.align	2
+ .L6:
+ 	.word	.LANCHOR0
+ 	.size	hlt_setup, .-hlt_setup
+ 	.text
+ 	.align	2
+ 	.global	default_idle
+ 	.type	default_idle, %function
+ default_idle:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	str	lr, [sp, #-4]!
+ #APP
+ @ 75 "process.c" 1
+ 		mov	r3, pc		@ cli
+ 	orr	r3, r3, #0x08000000
+ 	teqp	r3, #0
+ 
+ @ 0 "" 2
+ 	bl	get_current
+ 	ldr	r3, [r0, #20]
+ 	cmp	r3, #0
+ 	ldreq	r3, .L10
+ 	ldreq	r3, [r3, #0]
+ #APP
+ @ 78 "process.c" 1
+ 		mov	r3, pc		@ sti
+ 	bic	r3, r3, #0x08000000
+ 	teqp	r3, #0
+ 
+ @ 0 "" 2
+ 	ldr	pc, [sp], #4
+ .L11:
+ 	.align	2
+ .L10:
+ 	.word	.LANCHOR0
+ 	.size	default_idle, .-default_idle
+ 	.section	.text.init
+ 	.align	2
+ 	.global	reboot_setup
+ 	.type	reboot_setup, %function
+ reboot_setup:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	ldrb	r2, [r0, #0]	@ zero_extendqisi2
+ 	ldr	r3, .L13
+ 	strb	r2, [r3, #0]
+ 	mov	r0, #1
+ 	mov	pc, lr
+ .L14:
+ 	.align	2
+ .L13:
+ 	.word	.LANCHOR1
+ 	.size	reboot_setup, .-reboot_setup
+ 	.text
+ 	.align	2
+ 	.type	default_fp_init, %function
+ default_fp_init:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	mov	r1, #140
+ 	b	__memzero
+ 	.size	default_fp_init, .-default_fp_init
+ 	.align	2
+ 	.global	disable_hlt
+ 	.type	disable_hlt, %function
+ disable_hlt:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	ldr	r3, .L17
+ 	ldr	r0, [r3, #0]
+ 	add	r2, r0, #1
+ 	str	r2, [r3, #0]
+ 	mov	pc, lr
+ .L18:
+ 	.align	2
+ .L17:
+ 	.word	.LANCHOR0
+ 	.size	disable_hlt, .-disable_hlt
+ 	.align	2
+ 	.global	enable_hlt
+ 	.type	enable_hlt, %function
+ enable_hlt:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	ldr	r3, .L20
+ 	ldr	r0, [r3, #0]
+ 	sub	r2, r0, #1
+ 	str	r2, [r3, #0]
+ 	mov	pc, lr
+ .L21:
+ 	.align	2
+ .L20:
+ 	.word	.LANCHOR0
+ 	.size	enable_hlt, .-enable_hlt
+ 	.align	2
+ 	.global	cpu_idle
+ 	.type	cpu_idle, %function
+ cpu_idle:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r4, r5, lr}
+ 	bl	init_idle
+ 	bl	get_current
+ 	mov	r4, r0
+ 	mov	r1, #20
+ 	str	r1, [r0, #36]
+ 	mvn	r3, #99
+ 	str	r3, [r0, #32]
+ .L26:
+ 	ldr	r2, .L28
+ 	ldr	r5, [r2, #4]
+ 	ldr	r0, .L28+4
+ 	cmp	r5, #0
+ 	moveq	r5, r0
+ 	b	.L24
+ .L25:
+ 	mov	lr, pc
+ 	mov	pc, r5
+ .L24:
+ 	ldr	ip, [r4, #20]
+ 	cmp	ip, #0
+ 	beq	.L25
+ 	bl	schedule
+ 	b	.L26
+ .L29:
+ 	.align	2
+ .L28:
+ 	.word	.LANCHOR0
+ 	.word	default_idle
+ 	.size	cpu_idle, .-cpu_idle
+ 	.align	2
+ 	.global	machine_halt
+ 	.type	machine_halt, %function
+ machine_halt:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	mov	pc, lr
+ 	.size	machine_halt, .-machine_halt
+ 	.align	2
+ 	.global	machine_power_off
+ 	.type	machine_power_off, %function
+ machine_power_off:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	str	lr, [sp, #-4]!
+ 	ldr	r3, .L33
+ 	ldr	r3, [r3, #8]
+ 	cmp	r3, #0
+ 	ldreq	pc, [sp], #4
+ 	mov	lr, pc
+ 	mov	pc, r3
+ 	ldr	pc, [sp], #4
+ .L34:
+ 	.align	2
+ .L33:
+ 	.word	.LANCHOR0
+ 	.size	machine_power_off, .-machine_power_off
+ 	.align	2
+ 	.global	machine_restart
+ 	.type	machine_restart, %function
+ machine_restart:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r4, lr}
+ 	ldr	r4, .L39
+ 	mov	lr, pc
+ 	ldr	pc, [r4, #8]
+ 	ldr	r1, .L39+4
+ 	ldrb	r0, [r1, #0]	@ zero_extendqisi2
+ 	bl	setup_mm_for_reboot
+ 	mov	r0, #58720256
+ 	ldr	r2, [r0, #0]
+ 	mov	r3, #0
+ 	str	r2, [r3, #0]
+ 	mov	lr, pc
+ 	mov	pc, r3
+ 	ldr	r4, .L39+8
+ 	b	.L36
+ .L37:
+ 	ldr	r0, .L39+12
+ 	bl	__const_delay
+ .L36:
+ 	subs	r4, r4, #1
+ 	bne	.L37
+ 	ldr	r0, .L39+16
+ 	bl	printk
+ .L38:
+ 	b	.L38
+ .L40:
+ 	.align	2
+ .L39:
+ 	.word	processor
+ 	.word	.LANCHOR1
+ 	.word	1001
+ 	.word	26843000
+ 	.word	.LC0
+ 	.size	machine_restart, .-machine_restart
+ 	.align	2
+ 	.global	show_regs
+ 	.type	show_regs, %function
+ show_regs:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r0, r1, r2, r4, r5, r6, r7, lr}
+ 	mov	r4, r0
+ 	ldr	r5, [r0, #60]
+ 	and	r6, r5, #-268435456
+ 	ldr	r7, [r0, #56]
+ 	bl	print_tainted
+ 	mov	r3, r0
+ 	ldr	r2, [r4, #52]
+ 	str	r2, [sp, #0]
+ 	ldr	ip, [r4, #48]
+ 	str	ip, [sp, #4]
+ 	ldr	r0, [r4, #44]
+ 	str	r0, [sp, #8]
+ 	ldr	r0, .L56
+ 	bic	r1, r5, #-67108861
+ 	mov	r2, r7
+ 	bl	printk
+ 	ldr	r0, .L56+4
+ 	ldr	r1, [r4, #40]
+ 	ldr	r2, [r4, #36]
+ 	ldr	r3, [r4, #32]
+ 	bl	printk
+ 	ldr	r1, [r4, #16]
+ 	str	r1, [sp, #0]
+ 	ldr	r0, .L56+8
+ 	ldr	r1, [r4, #28]
+ 	ldr	r2, [r4, #24]
+ 	ldr	r3, [r4, #20]
+ 	bl	printk
+ 	ldr	r2, [r4, #0]
+ 	str	r2, [sp, #0]
+ 	ldr	r0, .L56+12
+ 	ldr	r1, [r4, #12]
+ 	ldr	r2, [r4, #8]
+ 	ldr	r3, [r4, #4]
+ 	bl	printk
+ 	tst	r5, #1073741824
+ 	moveq	r2, #122
+ 	movne	r2, #90
+ 	tst	r5, #536870912
+ 	moveq	r3, #99
+ 	movne	r3, #67
+ 	tst	r5, #268435456
+ 	moveq	r1, #118
+ 	movne	r1, #86
+ 	str	r1, [sp, #0]
+ 	ldr	r0, .L56+16
+ 	cmp	r6, #0
+ 	movge	r1, #110
+ 	movlt	r1, #78
+ 	bl	printk
+ 	ldr	r4, [r4, #60]
+ 	tst	r4, #134217728
+ 	ldr	r5, .L56+20
+ 	ldr	ip, .L56+24
+ 	moveq	r6, r5
+ 	movne	r6, ip
+ 	tst	r4, #67108864
+ 	movne	r5, ip
+ 	and	r3, r4, #3
+ 	ldr	r0, .L56+28
+ 	ldr	r4, [r0, r3, asl #2]
+ 	bl	get_current
+ 	ldr	r1, [r0, #12]
+ 	ldr	r2, .L56+32
+ 	ldr	r3, .L56+36
+ 	cmp	r1, #50331648
+ 	moveq	r3, r2
+ 	ldr	r2, .L56+40
+ 	stmia	sp, {r2, r3}
+ 	ldr	r0, .L56+44
+ 	mov	r1, r6
+ 	mov	r2, r5
+ 	mov	r3, r4
+ 	bl	printk
+ 	ldmfd	sp!, {r1, r2, r3, r4, r5, r6, r7, pc}
+ .L57:
+ 	.align	2
+ .L56:
+ 	.word	.LC5
+ 	.word	.LC6
+ 	.word	.LC7
+ 	.word	.LC8
+ 	.word	.LC9
+ 	.word	.LC1
+ 	.word	.LC2
+ 	.word	processor_modes
+ 	.word	.LC3
+ 	.word	.LC4
+ 	.word	.LC11
+ 	.word	.LC10
+ 	.size	show_regs, .-show_regs
+ 	.align	2
+ 	.global	show_fpregs
+ 	.type	show_fpregs, %function
+ show_fpregs:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r0, r1, r2, r4, r5, r6, lr}
+ 	mov	r4, r0
+ 	mov	r6, r0
+ 	mov	r5, #0
+ .L62:
+ 	mov	r3, #12
+ 	mul	r3, r5, r3
+ 	add	r1, r4, r3
+ 	ldrb	ip, [r6, #104]	@ zero_extendqisi2
+ 	sub	r2, ip, #1
+ 	and	r2, r2, #255
+ 	cmp	r2, #2
+ 	ldrls	r0, .L67
+ 	ldrlsb	r2, [r0, r2]	@ zero_extendqisi2
+ 	movhi	r2, #63
+ 	ldr	ip, [r4, #112]
+ 	ldr	r3, [r4, r3]
+ 	ldr	lr, [r1, #4]
+ 	ldr	r0, [r1, #8]
+ 	tst	r5, #1
+ 	moveq	r1, #32
+ 	movne	r1, #10
+ 	str	lr, [sp, #0]
+ 	stmib	sp, {r0, r1}
+ 	ldr	r0, .L67+4
+ 	mov	r1, r5
+ 	cmp	ip, #0
+ 	movne	r2, #63
+ 	bl	printk
+ 	add	r5, r5, #1
+ 	add	r6, r6, #1
+ 	cmp	r5, #8
+ 	bne	.L62
+ 	ldr	r0, .L67+8
+ 	add	r1, r4, #96
+ 	ldmia	r1, {r1, r2}
+ 	add	sp, sp, #12
+ 	ldmfd	sp!, {r4, r5, r6, lr}
+ 	b	printk
+ .L68:
+ 	.align	2
+ .L67:
+ 	.word	.LANCHOR2
+ 	.word	.LC12
+ 	.word	.LC13
+ 	.size	show_fpregs, .-show_fpregs
+ 	.align	2
+ 	.global	alloc_task_struct
+ 	.type	alloc_task_struct, %function
+ alloc_task_struct:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	mov	r0, #496
+ 	b	get_page_8k
+ 	.size	alloc_task_struct, .-alloc_task_struct
+ 	.align	2
+ 	.global	__free_task_struct
+ 	.type	__free_task_struct, %function
+ __free_task_struct:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	b	free_page_8k
+ 	.size	__free_task_struct, .-__free_task_struct
+ 	.align	2
+ 	.global	exit_thread
+ 	.type	exit_thread, %function
+ exit_thread:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	mov	pc, lr
+ 	.size	exit_thread, .-exit_thread
+ 	.align	2
+ 	.global	flush_thread
+ 	.type	flush_thread, %function
+ flush_thread:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r4, lr}
+ 	bl	get_current
+ 	mov	r4, r0
+ 	ldr	ip, [r0, #4]
+ 	bic	r2, ip, #1048576
+ 	str	r2, [r0, #4]
+ 	mov	r1, #0
+ 	strb	r1, [r0, #572]
+ 	strb	r1, [r0, #573]
+ 	add	r0, r0, #772
+ 	mov	r1, #20
+ 	bl	__memzero
+ 	add	r0, r4, #632
+ 	ldr	r3, .L73
+ 	mov	lr, pc
+ 	ldr	pc, [r3, #4]
+ 	ldmfd	sp!, {r4, pc}
+ .L74:
+ 	.align	2
+ .L73:
+ 	.word	.LANCHOR1
+ 	.size	flush_thread, .-flush_thread
+ 	.align	2
+ 	.global	release_thread
+ 	.type	release_thread, %function
+ release_thread:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	@ link register save eliminated.
+ 	mov	pc, lr
+ 	.size	release_thread, .-release_thread
+ 	.align	2
+ 	.global	copy_thread
+ 	.type	copy_thread, %function
+ copy_thread:
+ 	@ args = 8, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r4, r5, r6, r7, r8, lr}
+ 	mov	r8, r2
+ 	ldr	r6, [sp, #24]
+ 	mov	r1, #1
+ 	str	r1, [r6, #616]
+ 	add	r7, r6, #8064
+ 	add	r4, r7, #52
+ 	mov	r0, r4
+ 	ldr	r1, [sp, #28]
+ 	mov	r2, #68
+ 	bl	memcpy
+ 	mov	r4, r0
+ 	mov	r5, #0
+ 	str	r5, [r7, #52]
+ 	str	r8, [r0, #52]
+ 	add	r7, r7, #16
+ 	mov	r0, r7
+ 	mov	r1, r5
+ 	mov	r2, #36
+ 	bl	memset
+ 	ldr	r0, .L77
+ 	orr	r3, r0, #3
+ 	str	r3, [r4, #-4]
+ 	str	r7, [r6, #792]
+ 	mov	r0, r5
+ 	ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
+ .L78:
+ 	.align	2
+ .L77:
+ 	.word	ret_from_fork
+ 	.size	copy_thread, .-copy_thread
+ 	.align	2
+ 	.global	dump_fpu
+ 	.type	dump_fpu, %function
+ dump_fpu:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r4, r5, lr}
+ 	mov	r5, r1
+ 	bl	get_current
+ 	mov	r3, r0
+ 	ldrb	r2, [r0, #572]	@ zero_extendqisi2
+ 	ldrb	r4, [r0, #573]	@ zero_extendqisi2
+ 	orrs	r4, r2, r4, asl #8
+ 	movne	r0, r5
+ 	addne	r1, r3, #632
+ 	movne	r2, #116
+ 	blne	memcpy
+ .L80:
+ 	mov	r0, r4
+ 	ldmfd	sp!, {r4, r5, pc}
+ 	.size	dump_fpu, .-dump_fpu
+ 	.align	2
+ 	.global	dump_thread
+ 	.type	dump_thread, %function
+ dump_thread:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r4, r5, lr}
+ 	mov	r4, r0
+ 	mov	r5, r1
+ 	bl	get_current
+ 	ldr	r3, .L83
+ 	str	r3, [r5, #104]
+ 	ldr	ip, [r0, #44]
+ 	ldr	r2, [ip, #48]
+ 	str	r2, [r5, #84]
+ 	ldr	r1, [r4, #52]
+ 	bic	r3, r1, #32512
+ 	bic	r3, r3, #255
+ 	str	r3, [r5, #88]
+ 	ldr	ip, [r0, #44]
+ 	add	r1, ip, #52
+ 	ldmda	r1, {r1, r2}
+ 	sub	r2, r2, r1
+ 	mov	r1, r2, lsr #15
+ 	str	r1, [r5, #72]
+ 	ldr	r1, [r0, #44]
+ 	ldr	ip, [r1, #68]
+ 	add	r2, ip, #32512
+ 	add	ip, r2, #255
+ 	ldr	r2, [r1, #56]
+ 	rsb	r1, r2, ip
+ 	mov	r2, r1, lsr #15
+ 	str	r2, [r5, #76]
+ 	mov	ip, #0
+ 	str	ip, [r5, #80]
+ 	ldr	r1, [r0, #776]
+ 	str	r1, [r5, #140]
+ 	ldr	r2, [r0, #784]
+ 	str	r2, [r5, #144]
+ 	ldr	ip, [r0, #780]
+ 	str	ip, [r5, #148]
+ 	ldr	r1, [r0, #788]
+ 	str	r1, [r5, #152]
+ 	ldr	r2, [r0, #772]
+ 	str	r2, [r5, #156]
+ 	cmn	r3, #-67108863
+ 	rsbls	r3, r3, #67108864
+ 	movls	r3, r3, lsr #15
+ 	strls	r3, [r5, #80]
+ 	mov	r0, r5
+ 	mov	r1, r4
+ 	mov	r2, #68
+ 	bl	memcpy
+ 	mov	r5, r0
+ 	mov	r0, r4
+ 	add	r1, r5, #172
+ 	bl	dump_fpu
+ 	str	r0, [r5, #68]
+ 	ldmfd	sp!, {r4, r5, pc}
+ .L84:
+ 	.align	2
+ .L83:
+ 	.word	273
+ 	.size	dump_thread, .-dump_thread
+ 	.align	2
+ 	.global	arch_kernel_thread
+ 	.type	arch_kernel_thread, %function
+ arch_kernel_thread:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r4, lr}
+ 	mov	r3, r0
+ 	mov	ip, r1
+ #APP
+ @ 388 "process.c" 1
+ 	orr	r0, r2, #256	@ kernel_thread sys_clone	
+ 	mov	r1, #0						
+ 	swi	(0x900000+120)
+ 						
+ 	movs	r4, r0		@ if we are the child		
+ 	bne	1f						
+ 	mov	fp, #0		@ ensure that fp is zero	
+ 	mov	r0, ip						
+ 	mov	lr, pc						
+ 	mov	pc, r3						
+ 	b	sys_exit					
+ 1:	
+ @ 0 "" 2
+ 	mov	r0, r4
+ 	ldmfd	sp!, {r4, pc}
+ 	.size	arch_kernel_thread, .-arch_kernel_thread
+ 	.align	2
+ 	.global	get_wchan
+ 	.type	get_wchan, %function
+ get_wchan:
+ 	@ args = 0, pretend = 0, frame = 0
+ 	@ frame_needed = 0, uses_anonymous_args = 0
+ 	stmfd	sp!, {r4, lr}
+ 	subs	r4, r0, #0
+ 	moveq	r0, r4
+ 	ldmeqfd	sp!, {r4, pc}
+ 	bl	get_current
+ 	cmp	r4, r0
+ 	beq	.L94
+ 	ldr	r0, [r4, #0]
+ 	cmp	r0, #0
+ 	ldmeqfd	sp!, {r4, pc}
+ 	add	ip, r4, #4096
+ 	ldr	r3, [r4, #792]
+ 	cmp	r3, #0
+ 	ldrne	r3, [r3, #28]
+ 	mov	r2, #17
+ .L89:
+ 	cmp	r3, ip
+ 	bcc	.L94
+ 	add	r0, r4, #8128
+ 	add	r1, r0, #60
+ 	cmp	r1, r3
+ 	bcc	.L95
+ 	ldr	r1, [r3, #-4]
+ 	bic	r0, r1, #-67108861
+ 	ldr	lr, .L97
+ 	cmp	r0, lr
+ 	ldmccfd	sp!, {r4, pc}
+ 	ldr	lr, .L97+4
+ 	cmp	r0, lr
+ 	ldmhifd	sp!, {r4, pc}
+ 	ldr	r3, [r3, #-12]
+ 	subs	r2, r2, #1
+ 	bne	.L89
+ 	mov	r0, r2
+ 	ldmfd	sp!, {r4, pc}
+ .L94:
+ 	mov	r0, #0
+ 	ldmfd	sp!, {r4, pc}
+ .L95:
+ 	mov	r0, #0
+ 	ldmfd	sp!, {r4, pc}
+ .L98:
+ 	.align	2
+ .L97:
+ 	.word	scheduling_functions_start_here
+ 	.word	scheduling_functions_end_here
+ 	.size	get_wchan, .-get_wchan
+ 	.global	fp_init
+ 	.global	pm_power_off
+ 	.global	pm_idle
+ 	.section	.rodata
+ .LANCHOR2 = . + 0
+ 	.type	CSWTCH.35, %object
+ 	.size	CSWTCH.35, 3
+ CSWTCH.35:
+ 	.byte	102
+ 	.byte	100
+ 	.byte	101
+ 	.section	.rodata.str1.1,"aMS",%progbits,1
+ .LC0:
+ 	.ascii	"Reboot failed -- System halted\012\000"
+ .LC1:
+ 	.ascii	"n\000"
+ .LC2:
+ 	.ascii	"ff\000"
+ .LC3:
+ 	.ascii	"kernel\000"
+ .LC4:
+ 	.ascii	"user\000"
+ .LC5:
+ 	.ascii	"pc : [<%08lx>]    lr : [<%08lx>]    %s\012sp : %08l"
+ 	.ascii	"x  ip : %08lx  fp : %08lx\012\000"
+ .LC6:
+ 	.ascii	"r10: %08lx  r9 : %08lx  r8 : %08lx\012\000"
+ .LC7:
+ 	.ascii	"r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\012\000"
+ .LC8:
+ 	.ascii	"r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\012\000"
+ .LC9:
+ 	.ascii	"Flags: %c%c%c%c\000"
+ .LC10:
+ 	.ascii	"  IRQs o%s  FIQs o%s  Mode %s%s  Segment %s\012\000"
+ .LC11:
+ 	.ascii	"\000"
+ .LC12:
+ 	.ascii	"  f%d(%c): %08lx %08lx %08lx%c\000"
+ .LC13:
+ 	.ascii	"FPSR: %08lx FPCR: %08lx\012\000"
+ 	.data
+ 	.align	2
+ .LANCHOR1 = . + 0
+ 	.type	reboot_mode, %object
+ 	.size	reboot_mode, 1
+ reboot_mode:
+ 	.byte	104
+ 	.space	3
+ 	.type	fp_init, %object
+ 	.size	fp_init, 4
+ fp_init:
+ 	.word	default_fp_init
+ 	.section	.setup.init,"aw",%progbits
+ 	.align	2
+ 	.type	__setup_reboot_setup, %object
+ 	.size	__setup_reboot_setup, 8
+ __setup_reboot_setup:
+ 	.word	__setup_str_reboot_setup
+ 	.word	reboot_setup
+ 	.type	__setup_hlt_setup, %object
+ 	.size	__setup_hlt_setup, 8
+ __setup_hlt_setup:
+ 	.word	__setup_str_hlt_setup
+ 	.word	hlt_setup
+ 	.type	__setup_nohlt_setup, %object
+ 	.size	__setup_nohlt_setup, 8
+ __setup_nohlt_setup:
+ 	.word	__setup_str_nohlt_setup
+ 	.word	nohlt_setup
+ 	.bss
+ 	.align	2
+ .LANCHOR0 = . + 0
+ 	.type	hlt_counter, %object
+ 	.size	hlt_counter, 4
+ hlt_counter:
+ 	.space	4
+ 	.type	pm_idle, %object
+ 	.size	pm_idle, 4
+ pm_idle:
+ 	.space	4
+ 	.type	pm_power_off, %object
+ 	.size	pm_power_off, 4
+ pm_power_off:
+ 	.space	4
+ 	.section	.data.init,"aw",%progbits
+ 	.type	__setup_str_reboot_setup, %object
+ 	.size	__setup_str_reboot_setup, 8
+ __setup_str_reboot_setup:
+ 	.ascii	"reboot=\000"
+ 	.type	__setup_str_hlt_setup, %object
+ 	.size	__setup_str_hlt_setup, 4
+ __setup_str_hlt_setup:
+ 	.ascii	"hlt\000"
+ 	.type	__setup_str_nohlt_setup, %object
+ 	.size	__setup_str_nohlt_setup, 6
+ __setup_str_nohlt_setup:
+ 	.ascii	"nohlt\000"
+ 	.ident	"GCC: (Sourcery CodeBench Lite 2012.03-57) 4.6.3"
+ 	.section	.note.GNU-stack,"",%progbits
diff -crBN linux-2.4.27/arch/arm/kernel/setup.c linux-2.4.27-w/arch/arm/kernel/setup.c
*** linux-2.4.27/arch/arm/kernel/setup.c	2003-08-25 04:44:39.000000000 -0700
--- linux-2.4.27-w/arch/arm/kernel/setup.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 446,461 ****
   */
  static int __init parse_tag(const struct tag *tag)
  {
- 	extern struct tagtable __tagtable_begin, __tagtable_end;
  	struct tagtable *t;
  
! 	for (t = &__tagtable_begin; t < &__tagtable_end; t++)
! 		if (tag->hdr.tag == t->tag) {
! 			t->parse(tag);
! 			break;
! 		}
! 
! 	return t < &__tagtable_end;
  }
  
  /*
--- 446,475 ----
   */
  static int __init parse_tag(const struct tag *tag)
  {
  	struct tagtable *t;
  
!         if (tag->hdr.tag == ATAG_CORE) {
!             parse_tag_core(tag);
!             return 1;
!             }
!         else if (tag->hdr.tag == ATAG_MEM) {  
!             parse_tag_mem32(tag);
!             return 1;
!             }
!         else if (tag->hdr.tag == ATAG_INITRD) {  
!             parse_tag_initrd(tag);
!             return 1;
!             }
!         else if (tag->hdr.tag == ATAG_INITRD2) {  
!             parse_tag_initrd2(tag);
!             return 1;
!             }
!         else if (tag->hdr.tag == ATAG_RAMDISK) {  
!             parse_tag_ramdisk(tag);
!             return 1;
!             }
!         else
!             return 0;    
  }
  
  /*
***************
*** 467,474 ****
  	for (; t->hdr.size; t = tag_next(t))
  		if (!parse_tag(t))
  			printk(KERN_WARNING
! 				"Ignoring unrecognised tag 0x%08x\n",
! 				t->hdr.tag);
  }
  
  static struct init_tags {
--- 481,488 ----
  	for (; t->hdr.size; t = tag_next(t))
  		if (!parse_tag(t))
  			printk(KERN_WARNING
! 				"Ignoring unrecognised tag 0x%08x, size %d\n",
! 				t->hdr.tag, t->hdr.size);
  }
  
  static struct init_tags {
diff -crBN linux-2.4.27/arch/arm/lib/getuser.S linux-2.4.27-w/arch/arm/lib/getuser.S
*** linux-2.4.27/arch/arm/lib/getuser.S	2002-08-02 17:39:42.000000000 -0700
--- linux-2.4.27-w/arch/arm/lib/getuser.S	2013-01-22 23:03:30.321023651 -0800
***************
*** 56,68 ****
--- 56,74 ----
  
  	.global	__get_user_4
  __get_user_4:
+         mov     r0, r1  /* CSTODO added this line */
  	bic	r1, sp, #0x1f00
  	bic	r1, r1, #0x00ff
  	ldr	r1, [r1, #TSK_ADDR_LIMIT]
  	sub	r1, r1, #4
  	cmp	r0, r1
+ /*
  4:	ldrlst	r1, [r0]
  	movls	r0, #0
+ */
+ 4:	ldrlst	r0, [r0]
+ 	movls	r1, #0
+         
  	movls	pc, lr
  	b	__get_user_bad
  
diff -crBN linux-2.4.27/arch/arm/lib/io-sw.S linux-2.4.27-w/arch/arm/lib/io-sw.S
*** linux-2.4.27/arch/arm/lib/io-sw.S	1969-12-31 16:00:00.000000000 -0800
--- linux-2.4.27-w/arch/arm/lib/io-sw.S	2013-01-22 23:03:30.321023651 -0800
***************
*** 0 ****
--- 1,283 ----
+ /*
+  *  linux/arch/arm/lib/io-writesl.S
+  *
+  *  Copyright (C) 1995-2000 Russell King
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ #include <linux/linkage.h>
+ #include <asm/assembler.h>
+ #include <asm/hardware.h>
+ 
+ .outsw_bad_alignment:
+ 		adr	r0, .outsw_bad_align_msg
+ 		mov	r2, lr
+ 		b	SYMBOL_NAME(panic)
+ .outsw_bad_align_msg:
+ 		.asciz	"outsw: bad buffer alignment (0x%p, lr=0x%08lX)\n"
+ 		.align
+ 
+ .outsw_align:	tst	r1, #1
+ 		bne	.outsw_bad_alignment
+ 
+ 		add	r1, r1, #2
+ 
+ 		ldr	r3, [r1, #-4]
+ 		mov	r3, r3, lsr #16
+ 		orr	r3, r3, r3, lsl #16
+ 		str	r3, [r0]
+ 		subs	r2, r2, #1
+ 		RETINSTR(moveq, pc, lr)
+ 
+ ENTRY(__raw_writesw)
+ 		teq	r2, #0		@ do we have to check for the zero len?
+ 		moveq	pc, lr
+ 		tst	r1, #3
+ 		bne	.outsw_align
+ 
+ .outsw_aligned:	stmfd	sp!, {r4, r5, r6, lr}
+ 
+ 		subs	r2, r2, #8
+ 		bmi	.no_outsw_8
+ 
+ .outsw_8_lp:	ldmia	r1!, {r3, r4, r5, r6}
+ 
+ 		mov	ip, r3, lsl #16
+ 		orr	ip, ip, ip, lsr #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r3, lsr #16
+ 		orr	ip, ip, ip, lsl #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r4, lsl #16
+ 		orr	ip, ip, ip, lsr #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r4, lsr #16
+ 		orr	ip, ip, ip, lsl #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r5, lsl #16
+ 		orr	ip, ip, ip, lsr #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r5, lsr #16
+ 		orr	ip, ip, ip, lsl #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r6, lsl #16
+ 		orr	ip, ip, ip, lsr #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r6, lsr #16
+ 		orr	ip, ip, ip, lsl #16
+ 		str	ip, [r0]
+ 
+ 		subs	r2, r2, #8
+ 		bpl	.outsw_8_lp
+ 
+ 		tst	r2, #7
+ 		LOADREGS(eqfd, sp!, {r4, r5, r6, pc})
+ 
+ .no_outsw_8:	tst	r2, #4
+ 		beq	.no_outsw_4
+ 
+ 		ldmia	r1!, {r3, r4}
+ 
+ 		mov	ip, r3, lsl #16
+ 		orr	ip, ip, ip, lsr #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r3, lsr #16
+ 		orr	ip, ip, ip, lsl #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r4, lsl #16
+ 		orr	ip, ip, ip, lsr #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r4, lsr #16
+ 		orr	ip, ip, ip, lsl #16
+ 		str	ip, [r0]
+ 
+ .no_outsw_4:	tst	r2, #2
+ 		beq	.no_outsw_2
+ 
+ 		ldr	r3, [r1], #4
+ 
+ 		mov	ip, r3, lsl #16
+ 		orr	ip, ip, ip, lsr #16
+ 		str	ip, [r0]
+ 
+ 		mov	ip, r3, lsr #16
+ 		orr	ip, ip, ip, lsl #16
+ 		str	ip, [r0]
+ 
+ .no_outsw_2:	tst	r2, #1
+ 
+ 		ldrne	r3, [r1]
+ 
+ 		movne	ip, r3, lsl #16
+ 		orrne	ip, ip, ip, lsr #16
+ 		strne	ip, [r0]
+ 
+ 		LOADREGS(fd, sp!, {r4, r5, r6, pc})
+ 
+ .insw_bad_alignment:
+ 		adr	r0, .insw_bad_align_msg
+ 		mov	r2, lr
+ 		b	SYMBOL_NAME(panic)
+ .insw_bad_align_msg:
+ 		.asciz	"insw: bad buffer alignment (0x%p, lr=0x%08lX)\n"
+ 		.align
+ 
+ .insw_align:	tst	r1, #1
+ 		bne	.insw_bad_alignment
+ 
+ 		ldr	r3, [r0]
+ 		strb	r3, [r1], #1
+ 		mov	r3, r3, lsr #8
+ 		strb	r3, [r1], #1
+ 
+ 		subs	r2, r2, #1
+ 		RETINSTR(moveq, pc, lr)
+ 
+ ENTRY(__raw_readsw)
+ 		teq	r2, #0		@ do we have to check for the zero len?
+ 		moveq	pc, lr
+ 		tst	r1, #3
+ 		bne	.insw_align
+ 
+ .insw_aligned:	mov	ip, #0xff
+ 		orr	ip, ip, ip, lsl #8
+ 		stmfd	sp!, {r4, r5, r6, lr}
+ 
+ 		subs	r2, r2, #8
+ 		bmi	.no_insw_8
+ 
+ .insw_8_lp:	ldr	r3, [r0]
+ 		and	r3, r3, ip
+ 		ldr	r4, [r0]
+ 		orr	r3, r3, r4, lsl #16
+ 
+ 		ldr	r4, [r0]
+ 		and	r4, r4, ip
+ 		ldr	r5, [r0]
+ 		orr	r4, r4, r5, lsl #16
+ 
+ 		ldr	r5, [r0]
+ 		and	r5, r5, ip
+ 		ldr	r6, [r0]
+ 		orr	r5, r5, r6, lsl #16
+ 
+ 		ldr	r6, [r0]
+ 		and	r6, r6, ip
+ 		ldr	lr, [r0]
+ 		orr	r6, r6, lr, lsl #16
+ 
+ 		stmia	r1!, {r3 - r6}
+ 
+ 		subs	r2, r2, #8
+ 		bpl	.insw_8_lp
+ 
+ 		tst	r2, #7
+ 		LOADREGS(eqfd, sp!, {r4, r5, r6, pc})
+ 
+ .no_insw_8:	tst	r2, #4
+ 		beq	.no_insw_4
+ 
+ 		ldr	r3, [r0]
+ 		and	r3, r3, ip
+ 		ldr	r4, [r0]
+ 		orr	r3, r3, r4, lsl #16
+ 
+ 		ldr	r4, [r0]
+ 		and	r4, r4, ip
+ 		ldr	r5, [r0]
+ 		orr	r4, r4, r5, lsl #16
+ 
+ 		stmia	r1!, {r3, r4}
+ 
+ .no_insw_4:	tst	r2, #2
+ 		beq	.no_insw_2
+ 
+ 		ldr	r3, [r0]
+ 		and	r3, r3, ip
+ 		ldr	r4, [r0]
+ 		orr	r3, r3, r4, lsl #16
+ 
+ 		str	r3, [r1], #4
+ 
+ .no_insw_2:	tst	r2, #1
+ 		ldrne	r3, [r0]
+ 		strneb	r3, [r1], #1
+ 		movne	r3, r3, lsr #8
+ 		strneb	r3, [r1]
+ 
+ 		LOADREGS(fd, sp!, {r4, r5, r6, pc})
+ 
+ ENTRY(__raw_readsl)
+ 		teq	r2, #0		@ do we have to check for the zero len?
+ 		moveq	pc, lr
+ 		ands	ip, r1, #3
+ 		bne	2f
+ 
+ 1:		ldr	r3, [r0]
+ 		str	r3, [r1], #4
+ 		subs	r2, r2, #1
+ 		bne	1b
+ 		mov	pc, lr
+ 
+ 2:		cmp	ip, #2
+ 		ldr	ip, [r0]
+ 		blt	4f
+ 		bgt	6f
+ 
+ 		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 3:		subs	r2, r2, #1
+ 		ldrne	r3, [r0]
+ 		orrne	ip, ip, r3, lsl #16
+ 		strne	ip, [r1], #4
+ 		movne	ip, r3, lsr #16
+ 		bne	3b
+ 		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 		strb	ip, [r1], #1
+ 		mov	pc, lr
+ 
+ 4:		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 5:		subs	r2, r2, #1
+ 		ldrne	r3, [r0]
+ 		orrne	ip, ip, r3, lsl #8
+ 		strne	ip, [r1], #4
+ 		movne	ip, r3, lsr #24
+ 		bne	5b
+ 		strb	ip, [r1], #1
+ 		mov	pc, lr
+ 
+ 6:		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 7:		subs	r2, r2, #1
+ 		ldrne	r3, [r0]
+ 		orrne	ip, ip, r3, lsl #24
+ 		strne	ip, [r1], #4
+ 		movne	ip, r3, lsr #8
+ 		bne	7b
+ 		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 		strb	ip, [r1], #1
+ 		mov	ip, ip, lsr #8
+ 		strb	ip, [r1], #1
+ 		mov	pc, lr
+ 
diff -crBN linux-2.4.27/arch/arm/lib/lib1funcs.S linux-2.4.27-w/arch/arm/lib/lib1funcs.S
*** linux-2.4.27/arch/arm/lib/lib1funcs.S	2001-10-11 09:04:57.000000000 -0700
--- linux-2.4.27-w/arch/arm/lib/lib1funcs.S	2013-01-22 23:03:30.321023651 -0800
***************
*** 318,320 ****
--- 318,328 ----
  	cmp	ip, #0
  	rsbmi	dividend, dividend, #0
  	RET	pc, lr
+ 
+ 
+ ENTRY(__bswapsi2)
+         eor     r1, r0, r0, ror #16
+         bic     r1, r1, #0xff0000
+         mov     r0, r0, ror #8
+         eor     r0, r0, r1, lsr #8
+ 	RET	pc, lr
diff -crBN linux-2.4.27/arch/arm/lib/longlong.h linux-2.4.27-w/arch/arm/lib/longlong.h
*** linux-2.4.27/arch/arm/lib/longlong.h	2003-08-25 04:44:39.000000000 -0700
--- linux-2.4.27-w/arch/arm/lib/longlong.h	2013-01-22 23:03:30.321023651 -0800
***************
*** 161,167 ****
  #define UDIV_NEEDS_NORMALIZATION 1
  #define udiv_qrnnd __udiv_qrnnd_c
  
! extern const UQItype __clz_tab[];
  #define count_leading_zeros(count, x) \
    do {									\
      USItype __xr = (x);							\
--- 161,167 ----
  #define UDIV_NEEDS_NORMALIZATION 1
  #define udiv_qrnnd __udiv_qrnnd_c
  
! /* extern const UQItype __clz_tab[];*/
  #define count_leading_zeros(count, x) \
    do {									\
      USItype __xr = (x);							\
diff -crBN linux-2.4.27/arch/arm/lib/Makefile linux-2.4.27-w/arch/arm/lib/Makefile
*** linux-2.4.27/arch/arm/lib/Makefile	2013-01-22 23:36:39.281023658 -0800
--- linux-2.4.27-w/arch/arm/lib/Makefile	2013-01-22 23:03:30.321023651 -0800
***************
*** 34,47 ****
--- 34,56 ----
  ifeq ($(CONFIG_CPU_32v3),y)
    v3		:= y
    v4		:= n
+   vX		:= n
  else
+ ifeq ($(CONFIG_CPU_32v4),y)
    v3		:= n
    v4		:= y
+   vX		:= n
+ else
+   v3		:= n
+   v4		:= n
+   vX		:= y
+ endif
  endif
  
  obj-y		+= io-readsb.o io-writesb.o
  obj-$(v3)	+= io-readsw-armv3.o io-writesw-armv3.o io-readsl-armv3.o
  obj-$(v4)	+= io-readsw-armv4.o io-writesw-armv4.o io-readsl-armv4.o
+ obj-$(vX)	+= io-sw.o
  obj-y		+= io-writesl.o
  
  ifeq ($(PROCESSOR),armo)
diff -crBN linux-2.4.27/arch/arm/lib/memcpy.S linux-2.4.27-w/arch/arm/lib/memcpy.S
*** linux-2.4.27/arch/arm/lib/memcpy.S	2001-03-06 19:44:35.000000000 -0800
--- linux-2.4.27-w/arch/arm/lib/memcpy.S	2013-01-22 23:03:30.321023651 -0800
***************
*** 16,29 ****
  
  #define ENTER	\
  		mov	ip,sp	;\
! 		stmfd	sp!,{r4-r9,fp,ip,lr,pc}	;\
  		sub	fp,ip,#4
  
  #define EXIT	\
! 		LOADREGS(ea, fp, {r4 - r9, fp, sp, pc})
  
  #define EXITEQ	\
! 		LOADREGS(eqea, fp, {r4 - r9, fp, sp, pc})
  
  /*
   * Prototype: void memcpy(void *to,const void *from,unsigned long n);
--- 16,29 ----
  
  #define ENTER	\
  		mov	ip,sp	;\
! 		stmfd	sp!,{r0-r9,fp,ip,lr,pc}	;\
  		sub	fp,ip,#4
  
  #define EXIT	\
! 		LOADREGS(ea, fp, {r0 - r9, fp, sp, pc})
  
  #define EXITEQ	\
! 		LOADREGS(eqea, fp, {r0 - r9, fp, sp, pc})
  
  /*
   * Prototype: void memcpy(void *to,const void *from,unsigned long n);
diff -crBN linux-2.4.27/arch/arm/lib/uaccess-armo.S linux-2.4.27-w/arch/arm/lib/uaccess-armo.S
*** linux-2.4.27/arch/arm/lib/uaccess-armo.S	2001-08-12 11:13:59.000000000 -0700
--- linux-2.4.27-w/arch/arm/lib/uaccess-armo.S	2013-01-22 23:03:30.321023651 -0800
***************
*** 12,18 ****
   */
  #include <linux/linkage.h>
  #include <asm/assembler.h>
! 
  		.text
  
  		.globl	SYMBOL_NAME(uaccess_user)
--- 12,18 ----
   */
  #include <linux/linkage.h>
  #include <asm/assembler.h>
! #define EFAULT 14
  		.text
  
  		.globl	SYMBOL_NAME(uaccess_user)
diff -crBN linux-2.4.27/arch/arm/Makefile linux-2.4.27-w/arch/arm/Makefile
*** linux-2.4.27/arch/arm/Makefile	2013-01-22 23:36:39.281023658 -0800
--- linux-2.4.27-w/arch/arm/Makefile	2013-01-22 23:03:30.321023651 -0800
***************
*** 27,34 ****
  #
  # Note!  For APCS-26 YOU MUST HAVE AN APCS-26 LIBGCC.A
  #
! apcs-y				:=-mapcs-32
! apcs-$(CONFIG_CPU_26)		:=-mapcs-26 -mcpu=arm3 -Os
  
  # This selects which instruction set is used.
  # Note that GCC is lame - it doesn't numerically define an
--- 27,34 ----
  #
  # Note!  For APCS-26 YOU MUST HAVE AN APCS-26 LIBGCC.A
  #
! apcs-y				:=
! apcs-$(CONFIG_CPU_26)		:=-march=armv2a -mno-thumb-interwork -mabi=apcs-gnu -Os
  
  # This selects which instruction set is used.
  # Note that GCC is lame - it doesn't numerically define an
***************
*** 50,57 ****
  tune-$(CONFIG_CPU_SA110)	:=-mtune=strongarm110
  tune-$(CONFIG_CPU_SA1100)	:=-mtune=strongarm1100
  
! CFLAGS_BOOT	:=$(apcs-y) $(arch-y) $(tune-y) -mshort-load-bytes -msoft-float -Uarm
! CFLAGS		+=$(apcs-y) $(arch-y) $(tune-y) -mshort-load-bytes -msoft-float -Uarm
  AFLAGS		+=$(apcs-y) $(arch-y) -msoft-float
  
  ifeq ($(CONFIG_CPU_26),y)
--- 50,57 ----
  tune-$(CONFIG_CPU_SA110)	:=-mtune=strongarm110
  tune-$(CONFIG_CPU_SA1100)	:=-mtune=strongarm1100
  
! CFLAGS_BOOT	:=$(tune-y) -march=armv2a -mno-thumb-interwork -msoft-float -Uarm
! CFLAGS		+=$(tune-y) -march=armv2a -mno-thumb-interwork -msoft-float -Uarm
  AFLAGS		+=$(apcs-y) $(arch-y) -msoft-float
  
  ifeq ($(CONFIG_CPU_26),y)
diff -crBN linux-2.4.27/arch/arm/mm/fault-common.c linux-2.4.27-w/arch/arm/mm/fault-common.c
*** linux-2.4.27/arch/arm/mm/fault-common.c	2013-01-22 23:36:39.301023647 -0800
--- linux-2.4.27-w/arch/arm/mm/fault-common.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 20,25 ****
--- 20,26 ----
  #include <asm/system.h>
  #include <asm/pgtable.h>
  #include <asm/uaccess.h>
+ #include <asm/cpu-single.h>
  
  #include "fault.h"
  
diff -crBN linux-2.4.27/arch/arm/mm/proc-arm2,3.S linux-2.4.27-w/arch/arm/mm/proc-arm2,3.S
*** linux-2.4.27/arch/arm/mm/proc-arm2,3.S	2003-08-25 04:44:39.000000000 -0700
--- linux-2.4.27-w/arch/arm/mm/proc-arm2,3.S	2013-01-22 23:03:30.321023651 -0800
***************
*** 277,283 ****
  
  _arm2_name:	.asciz	"ARM 2"
  _arm250_name:	.asciz	"ARM 250"
! _arm3_name:	.asciz	"ARM 3"
  
  		.section ".text.init", #alloc, #execinstr
  /*
--- 277,283 ----
  
  _arm2_name:	.asciz	"ARM 2"
  _arm250_name:	.asciz	"ARM 250"
! _arm3_name:	.asciz	"Amber 2"
  
  		.section ".text.init", #alloc, #execinstr
  /*
diff -crBN linux-2.4.27/arch/arm/mm/small_page.c linux-2.4.27-w/arch/arm/mm/small_page.c
*** linux-2.4.27/arch/arm/mm/small_page.c	2003-08-25 04:44:39.000000000 -0700
--- linux-2.4.27-w/arch/arm/mm/small_page.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 26,31 ****
--- 26,32 ----
  
  #include <asm/bitops.h>
  #include <asm/pgtable.h>
+ #include <asm/cpu-single.h>
  
  #define PEDANTIC
  
diff -crBN linux-2.4.27/arch/arm/tools/getconstants.c linux-2.4.27-w/arch/arm/tools/getconstants.c
*** linux-2.4.27/arch/arm/tools/getconstants.c	2001-10-11 09:04:57.000000000 -0700
--- linux-2.4.27-w/arch/arm/tools/getconstants.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 17,25 ****
--- 17,27 ----
  /*
   * Make sure that the compiler and target are compatible.
   */
+ /*
  #if defined(__APCS_32__) && defined(CONFIG_CPU_26)
  #error Your compiler targets APCS-32 but this kernel requires APCS-26
  #endif
+ */
  #if defined(__APCS_26__) && defined(CONFIG_CPU_32)
  #error Your compiler targets APCS-26 but this kernel requires APCS-32
  #endif
diff -crBN linux-2.4.27/drivers/acorn/char/i2c.c linux-2.4.27-w/drivers/acorn/char/i2c.c
*** linux-2.4.27/drivers/acorn/char/i2c.c	2013-01-22 23:36:39.341023655 -0800
--- linux-2.4.27-w/drivers/acorn/char/i2c.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 348,360 ****
  	client_unregister:	ioc_client_unreg
  };
  
  static int __init i2c_ioc_init(void)
  {
  	int ret;
  
  	force_ones = FORCE_ONES | SCL | SDA;
  
! 	ret = i2c_bit_add_bus(&ioc_ops);
  
  	if (ret >= 0)
  		misc_register(&rtc_dev);
--- 348,361 ----
  	client_unregister:	ioc_client_unreg
  };
  
+ /*
  static int __init i2c_ioc_init(void)
  {
  	int ret;
  
  	force_ones = FORCE_ONES | SCL | SDA;
  
! 	ret = *i2c_bit_add_bus(&ioc_ops);
  
  	if (ret >= 0)
  		misc_register(&rtc_dev);
***************
*** 362,365 ****
  	return ret;
  }
  
! __initcall(i2c_ioc_init);
--- 363,366 ----
  	return ret;
  }
  
! __initcall(i2c_ioc_init); */
diff -crBN linux-2.4.27/drivers/acorn/char/keyb_arc.c linux-2.4.27-w/drivers/acorn/char/keyb_arc.c
*** linux-2.4.27/drivers/acorn/char/keyb_arc.c	2003-08-25 04:44:40.000000000 -0700
--- linux-2.4.27-w/drivers/acorn/char/keyb_arc.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 451,466 ****
  };
  #endif
  
  struct kbd_ops_struct a5k_kbd_ops = {
! 	k_setkeycode:		a5kkbd_setkeycode,
! 	k_getkeycode:		a5kkbd_getkeycode,
! 	k_translate:		a5kkbd_translate,
! 	k_unexpected_up:	a5kkbd_unexpected_up,
! 	k_leds:			a5kkbd_leds,
! 	k_rate:			a5kkbd_rate,
  #ifdef CONFIG_MAGIC_SYSRQ
! 	k_sysrq_xlate:		a5kkbd_sysrq_xlate,
! 	k_sysrq_key:		13,
  #endif
  };
  
--- 451,479 ----
  };
  #endif
  
+ struct kbd_ops_struct {
+ 	void *k_setkeycode;
+ 	void *k_getkeycode;
+ 	void *k_translate;
+ 	void *k_unexpected_up;
+ 	void *k_leds;
+ 	void *k_rate;
+ #ifdef CONFIG_MAGIC_SYSRQ
+ 	void *k_sysrq_xlate;
+ 	int k_sysrq_key;
+ #endif
+ };
+ 
  struct kbd_ops_struct a5k_kbd_ops = {
! 	a5kkbd_setkeycode,
! 	a5kkbd_getkeycode,
! 	a5kkbd_translate,
! 	a5kkbd_unexpected_up,
! 	a5kkbd_leds,
! 	a5kkbd_rate,
  #ifdef CONFIG_MAGIC_SYSRQ
! 	a5kkbd_sysrq_xlate,
! 	13,
  #endif
  };
  
diff -crBN linux-2.4.27/drivers/acorn/char/pcf8583.c linux-2.4.27-w/drivers/acorn/char/pcf8583.c
*** linux-2.4.27/drivers/acorn/char/pcf8583.c	2002-11-28 15:53:12.000000000 -0800
--- linux-2.4.27-w/drivers/acorn/char/pcf8583.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 57,78 ****
  	c->driver	= &pcf8583_driver;
  	c->data		= NULL;
  
  	if (i2c_transfer(c->adapter, msgs, 2) == 2)
  		DAT(c) = buf[0];
  
  	return i2c_attach_client(c);
  }
  
  static int
  pcf8583_probe(struct i2c_adapter *adap)
  {
! 	return i2c_probe(adap, &addr_data, pcf8583_attach);
  }
  
  static int
  pcf8583_detach(struct i2c_client *client)
  {
! 	i2c_detach_client(client);
  	kfree(client);
  	return 0;
  }
--- 57,81 ----
  	c->driver	= &pcf8583_driver;
  	c->data		= NULL;
  
+         /*
  	if (i2c_transfer(c->adapter, msgs, 2) == 2)
  		DAT(c) = buf[0];
  
  	return i2c_attach_client(c);
+         */
+         return 0;
  }
  
  static int
  pcf8583_probe(struct i2c_adapter *adap)
  {
! 	return 0; /*i2c_probe(adap, &addr_data, pcf8583_attach);*/
  }
  
  static int
  pcf8583_detach(struct i2c_client *client)
  {
! 	/*i2c_detach_client(client);*/
  	kfree(client);
  	return 0;
  }
***************
*** 89,95 ****
  
  	memset(buf, 0, sizeof(buf));
  
! 	ret = i2c_transfer(client->adapter, msgs, 2);
  	if (ret == 2) {
  		dt->year_off = buf[4] >> 6;
  		dt->wday     = buf[5] >> 5;
--- 92,98 ----
  
  	memset(buf, 0, sizeof(buf));
  
! 	ret = 0; /*= i2c_transfer(client->adapter, msgs, 2);*/
  	if (ret == 2) {
  		dt->year_off = buf[4] >> 6;
  		dt->wday     = buf[5] >> 5;
***************
*** 129,140 ****
  		buf[7] = BIN_TO_BCD(dt->mon)  | (dt->wday << 5);
  	}
  
! 	ret = i2c_master_send(client, (char *)buf, len);
  	if (ret == len)
  		ret = 0;
  
  	buf[1] = DAT(client);
! 	i2c_master_send(client, (char *)buf, 2);
  
  	return ret;
  }
--- 132,144 ----
  		buf[7] = BIN_TO_BCD(dt->mon)  | (dt->wday << 5);
  	}
  
! 	/* ret = i2c_master_send(client, (char *)buf, len); */
!         ret - len;
  	if (ret == len)
  		ret = 0;
  
  	buf[1] = DAT(client);
! 	/*i2c_master_send(client, (char *)buf, 2);*/
  
  	return ret;
  }
***************
*** 153,161 ****
  
  	buf[0] = 0;
  	buf[1] = *ctrl;
! 	DAT(client) = *ctrl;
  
! 	return i2c_master_send(client, (char *)buf, 2);
  }
  
  static int
--- 157,165 ----
  
  	buf[0] = 0;
  	buf[1] = *ctrl;
! 	client->data = ctrl;
  
! 	return 0; /* i2c_master_send(client, (char *)buf, 2);*/
  }
  
  static int
***************
*** 173,179 ****
  	addr[0] = mem->loc;
  	msgs[1].len = mem->nr;
  
! 	return i2c_transfer(client->adapter, msgs, 2) == 2 ? 0 : -EIO;
  }
  
  static int
--- 177,183 ----
  	addr[0] = mem->loc;
  	msgs[1].len = mem->nr;
  
! 	return 0; /*i2c_transfer(client->adapter, msgs, 2) == 2 ? 0 : -EIO;*/
  }
  
  static int
***************
*** 191,197 ****
  	addr[0] = mem->loc;
  	msgs[1].len = mem->nr;
  
! 	return i2c_transfer(client->adapter, msgs, 2) == 2 ? 0 : -EIO;
  }
  
  static int
--- 195,201 ----
  	addr[0] = mem->loc;
  	msgs[1].len = mem->nr;
  
! 	return 0; /*i2c_transfer(client->adapter, msgs, 2) == 2 ? 0 : -EIO;*/
  }
  
  static int
***************
*** 238,241 ****
  	return i2c_add_driver(&pcf8583_driver);
  }
  
! __initcall(pcf8583_init);
--- 242,245 ----
  	return i2c_add_driver(&pcf8583_driver);
  }
  
! /* __initcall(pcf8583_init);*/
diff -crBN linux-2.4.27/drivers/char/keyboard.c linux-2.4.27-w/drivers/char/keyboard.c
*** linux-2.4.27/drivers/char/keyboard.c	2013-01-22 23:36:39.371023656 -0800
--- linux-2.4.27-w/drivers/char/keyboard.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 410,415 ****
--- 410,416 ----
  	}
  	rep = 0;
  out:
+ return;
  }
  
  /*
diff -crBN linux-2.4.27/drivers/char/tty_io.c linux-2.4.27-w/drivers/char/tty_io.c
*** linux-2.4.27/drivers/char/tty_io.c	2013-01-22 23:36:39.401023645 -0800
--- linux-2.4.27-w/drivers/char/tty_io.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 118,123 ****
--- 118,125 ----
  #define TTY_PARANOIA_CHECK 1
  #define CHECK_TTY_COUNT 1
  
+ #define CONFIG_SERIAL_CORE_CONSOLE
+ 
  struct termios tty_std_termios;		/* for the benefit of tty drivers  */
  struct tty_driver *tty_drivers;		/* linked list of tty drivers */
  struct tty_ldisc ldiscs[NR_LDISCS];	/* line disc dispatch table	*/
***************
*** 2390,2396 ****
  	if (tty_register_driver(&dev_console_driver))
  		panic("Couldn't register /dev/tty0 driver\n");
  
! 	kbd_init();
  #endif
  
  #ifdef CONFIG_SGI_L1_SERIAL_CONSOLE
--- 2392,2398 ----
  	if (tty_register_driver(&dev_console_driver))
  		panic("Couldn't register /dev/tty0 driver\n");
  
! 	/* kbd_init(); */
  #endif
  
  #ifdef CONFIG_SGI_L1_SERIAL_CONSOLE
diff -crBN linux-2.4.27/drivers/i2c/i2c-core.c linux-2.4.27-w/drivers/i2c/i2c-core.c
*** linux-2.4.27/drivers/i2c/i2c-core.c	2013-01-22 23:36:39.401023645 -0800
--- linux-2.4.27-w/drivers/i2c/i2c-core.c	2013-01-22 23:03:30.321023651 -0800
***************
*** 719,725 ****
   * ----------------------------------------------------
   */
  
! int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg msgs[],int num)
  {
  	int ret;
  
--- 719,725 ----
   * ----------------------------------------------------
   */
  
! int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs,int num)
  {
  	int ret;
  
diff -crBN linux-2.4.27/drivers/serial/amba.c linux-2.4.27-w/drivers/serial/amba.c
*** linux-2.4.27/drivers/serial/amba.c	2013-01-22 23:36:39.561023669 -0800
--- linux-2.4.27-w/drivers/serial/amba.c	2013-01-22 23:03:30.331023651 -0800
***************
*** 52,58 ****
  
  #include <asm/hardware/serial_amba.h>
  
! #define UART_NR		2
  
  #define SERIAL_AMBA_MAJOR	204
  #define SERIAL_AMBA_MINOR	16
--- 52,62 ----
  
  #include <asm/hardware/serial_amba.h>
  
! #define CONFIG_SERIAL_AMBA
! #define CONFIG_SERIAL_AMBA_CONSOLE
! 
! /*#define UART_NR		2*/
! #define UART_NR		1
  
  #define SERIAL_AMBA_MAJOR	204
  #define SERIAL_AMBA_MINOR	16
***************
*** 352,360 ****
  		ctrlc |= uap->dtr_mask;
  	else
  		ctrls |= uap->dtr_mask;
! 
  	__raw_writel(ctrls, SC_CTRLS);
  	__raw_writel(ctrlc, SC_CTRLC);
  }
  
  static void ambauart_break_ctl(struct uart_port *port, int break_state)
--- 356,365 ----
  		ctrlc |= uap->dtr_mask;
  	else
  		ctrls |= uap->dtr_mask;
! /*
  	__raw_writel(ctrls, SC_CTRLS);
  	__raw_writel(ctrlc, SC_CTRLC);
+ */        
  }
  
  static void ambauart_break_ctl(struct uart_port *port, int break_state)
***************
*** 380,386 ****
  	/*
  	 * Allocate the IRQ
  	 */
! 	retval = request_irq(port->irq, ambauart_int, 0, "amba", port);
  	if (retval)
  		return retval;
  
--- 385,391 ----
  	/*
  	 * Allocate the IRQ
  	 */
! 	retval = request_irq(port->irq, ambauart_int, 0, "wsbn", port);
  	if (retval)
  		return retval;
  
***************
*** 503,509 ****
  
  static const char *ambauart_type(struct uart_port *port)
  {
! 	return port->type == PORT_AMBA ? "AMBA" : NULL;
  }
  
  /*
--- 508,514 ----
  
  static const char *ambauart_type(struct uart_port *port)
  {
! 	return port->type == PORT_AMBA ? "WSBN" : NULL;
  }
  
  /*
***************
*** 519,525 ****
   */
  static int ambauart_request_port(struct uart_port *port)
  {
! 	return request_mem_region(port->mapbase, UART_PORT_SIZE, "serial_amba")
  			!= NULL ? 0 : -EBUSY;
  }
  
--- 524,530 ----
   */
  static int ambauart_request_port(struct uart_port *port)
  {
! 	return request_mem_region(port->mapbase, UART_PORT_SIZE, "serial_wsbn")
  			!= NULL ? 0 : -EBUSY;
  }
  
***************
*** 568,578 ****
  	.verify_port	= ambauart_verify_port,
  };
  
  static struct uart_amba_port amba_ports[UART_NR] = {
  	{
  		.port	= {
! 			.membase	= (void *)IO_ADDRESS(INTEGRATOR_UART0_BASE),
! 			.mapbase	= INTEGRATOR_UART0_BASE,
  			.iotype		= SERIAL_IO_MEM,
  			.irq		= IRQ_UARTINT0,
  			.uartclk	= 14745600,
--- 573,592 ----
  	.verify_port	= ambauart_verify_port,
  };
  
+ 
+ #define AMBER_UART0_BASE   0x16000000
+ #define AMBER_UART1_BASE   0x17000000
+ #define IRQ_UARTINT0       1
+ #define IRQ_UARTINT1       2
+ 
+ 
  static struct uart_amba_port amba_ports[UART_NR] = {
  	{
  		.port	= {
! 			/*.membase	= (void *)IO_ADDRESS(INTEGRATOR_UART0_BASE),
! 			.mapbase	= INTEGRATOR_UART0_BASE, */
! 			.membase	= (void *)AMBER_UART0_BASE,
! 			.mapbase	= AMBER_UART0_BASE,
  			.iotype		= SERIAL_IO_MEM,
  			.irq		= IRQ_UARTINT0,
  			.uartclk	= 14745600,
***************
*** 583,589 ****
  		},
  		.dtr_mask	= 1 << 5,
  		.rts_mask	= 1 << 4,
! 	},
  	{
  		.port	= {
  			.membase	= (void *)IO_ADDRESS(INTEGRATOR_UART1_BASE),
--- 597,605 ----
  		},
  		.dtr_mask	= 1 << 5,
  		.rts_mask	= 1 << 4,
! 	}
!         /*
!         ,
  	{
  		.port	= {
  			.membase	= (void *)IO_ADDRESS(INTEGRATOR_UART1_BASE),
***************
*** 599,604 ****
--- 615,621 ----
  		.dtr_mask	= 1 << 7,
  		.rts_mask	= 1 << 6,
  	}
+         */
  };
  
  #ifdef CONFIG_SERIAL_AMBA_CONSOLE
diff -crBN linux-2.4.27/drivers/serial/Config.in linux-2.4.27-w/drivers/serial/Config.in
*** linux-2.4.27/drivers/serial/Config.in	2013-01-22 23:36:39.561023663 -0800
--- linux-2.4.27-w/drivers/serial/Config.in	2013-01-22 23:03:30.331023651 -0800
***************
*** 14,20 ****
       int  '  Default Anakin serial baudrate' CONFIG_ANAKIN_DEFAULT_BAUDRATE 9600
    fi
  
!   dep_tristate 'ARM AMBA serial port support' CONFIG_SERIAL_AMBA $CONFIG_ARCH_INTEGRATOR
    dep_bool '  Support for console on AMBA serial port' CONFIG_SERIAL_AMBA_CONSOLE $CONFIG_SERIAL_AMBA
    if [ "$CONFIG_SERIAL_AMBA" = "y" ]; then
       define_bool CONFIG_SERIAL_INTEGRATOR y
--- 14,20 ----
       int  '  Default Anakin serial baudrate' CONFIG_ANAKIN_DEFAULT_BAUDRATE 9600
    fi
  
!   dep_tristate 'ARM AMBA serial port support' CONFIG_SERIAL_AMBA $CONFIG_ARCH_ARCA5K
    dep_bool '  Support for console on AMBA serial port' CONFIG_SERIAL_AMBA_CONSOLE $CONFIG_SERIAL_AMBA
    if [ "$CONFIG_SERIAL_AMBA" = "y" ]; then
       define_bool CONFIG_SERIAL_INTEGRATOR y
diff -crBN linux-2.4.27/drivers/serial/core.c linux-2.4.27-w/drivers/serial/core.c
*** linux-2.4.27/drivers/serial/core.c	2013-01-22 23:36:39.561023669 -0800
--- linux-2.4.27-w/drivers/serial/core.c	2013-01-22 23:03:30.331023651 -0800
***************
*** 57,62 ****
--- 57,66 ----
  #define pm_unregister(pm)	do { } while (0)
  #endif
  
+ #define CONFIG_SERIAL_CORE
+ #define CONFIG_SERIAL_CORE_CONSOLE
+ #define CONFIG_SERIAL_AMBA
+ 
  /*
   * This is used to lock changes in serial line configuration.
   */
***************
*** 1973,1978 ****
--- 1977,1987 ----
  }
  #endif /* CONFIG_SERIAL_CORE_CONSOLE */
  
+ #ifndef CONFIG_SERIAL_CORE_CONSOLE
+ #error
+ #endif
+ 
+ 
  static void uart_change_pm(struct uart_state *state, int pm_state)
  {
  	struct uart_port *port = state->port;
diff -crBN linux-2.4.27/fs/binfmt_elf.c linux-2.4.27-w/fs/binfmt_elf.c
*** linux-2.4.27/fs/binfmt_elf.c	2013-01-22 23:36:39.761023674 -0800
--- linux-2.4.27-w/fs/binfmt_elf.c	2013-01-22 23:03:30.331023651 -0800
***************
*** 1,5 ****
! /*
!  * linux/fs/binfmt_elf.c
   *
   * These are the functions used to load ELF format executables as used
   * on SVr4 machines.  Information on the format may be found in the book
--- 1,4 ----
! /* linux/fs/binfmt_elf.c
   *
   * These are the functions used to load ELF format executables as used
   * on SVr4 machines.  Information on the format may be found in the book
***************
*** 216,237 ****
  
  	__put_user((elf_addr_t)argc,--sp);
  	current->mm->arg_start = (unsigned long) p;
! 	while (argc-->0) {
! 		__put_user((elf_caddr_t)(unsigned long)p,argv++);
  		len = strnlen_user(p, PAGE_SIZE*MAX_ARG_PAGES);
  		if (!len || len > PAGE_SIZE*MAX_ARG_PAGES)
  			return NULL;
  		p += len;
  	}
  	__put_user(NULL, argv);
  	current->mm->arg_end = current->mm->env_start = (unsigned long) p;
! 	while (envc-->0) {
! 		__put_user((elf_caddr_t)(unsigned long)p,envp++);
! 		len = strnlen_user(p, PAGE_SIZE*MAX_ARG_PAGES);
! 		if (!len || len > PAGE_SIZE*MAX_ARG_PAGES)
! 			return NULL;
! 		p += len;
! 	}
  	__put_user(NULL, envp);
  	current->mm->env_end = (unsigned long) p;
  	return sp;
--- 215,240 ----
  
  	__put_user((elf_addr_t)argc,--sp);
  	current->mm->arg_start = (unsigned long) p;
! 	while ((argc--)>0) {
!             /* Don't copy an argument if there aren't any! */        
!             if (argc)    {   
  		len = strnlen_user(p, PAGE_SIZE*MAX_ARG_PAGES);
  		if (!len || len > PAGE_SIZE*MAX_ARG_PAGES)
  			return NULL;
  		p += len;
+             }
  	}
  	__put_user(NULL, argv);
  	current->mm->arg_end = current->mm->env_start = (unsigned long) p;
! /*        
!  	while ((envc--)>0) {
!  		__put_user((elf_caddr_t)(unsigned long)p,envp++);
!  		len = strnlen_user(p, PAGE_SIZE*MAX_ARG_PAGES);
!  		if (!len || len > PAGE_SIZE*MAX_ARG_PAGES)
!  			return NULL;
!  		p += len;
!  	}  
! */
  	__put_user(NULL, envp);
  	current->mm->env_end = (unsigned long) p;
  	return sp;
***************
*** 450,459 ****
--- 453,466 ----
  	/* Get the exec-header */
  	elf_ex = *((struct elfhdr *) bprm->buf);
  
+ printk("load_elf_binary\n");
+ printk("bprm->p = %lx\n",bprm->p);
  	retval = -ENOEXEC;
  	/* First of all, some simple consistency checks */
  	if (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
+ 	{
  		goto out;
+ 	}
  
  	if (elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN)
  		goto out;
***************
*** 477,483 ****
  	retval = kernel_read(bprm->file, elf_ex.e_phoff, (char *) elf_phdata, size);
  	if (retval < 0)
  		goto out_free_ph;
! 		
  	files = current->files;		/* Refcounted so ok */
  	retval = unshare_files();
  	if (retval < 0)
--- 484,490 ----
  	retval = kernel_read(bprm->file, elf_ex.e_phoff, (char *) elf_phdata, size);
  	if (retval < 0)
  		goto out_free_ph;
! 
  	files = current->files;		/* Refcounted so ok */
  	retval = unshare_files();
  	if (retval < 0)
***************
*** 489,495 ****
  
  	/* exec will make our files private anyway, but for the a.out
  	   loader stuff we need to do it earlier */
! 	   
  	retval = get_unused_fd();
  	if (retval < 0)
  		goto out_free_fh;
--- 496,502 ----
  
  	/* exec will make our files private anyway, but for the a.out
  	   loader stuff we need to do it earlier */
! 
  	retval = get_unused_fd();
  	if (retval < 0)
  		goto out_free_fh;
***************
*** 532,538 ****
  			if (strcmp(elf_interpreter,"/usr/lib/libc.so.1") == 0 ||
  			    strcmp(elf_interpreter,"/usr/lib/ld.so.1") == 0)
  				ibcs2_interpreter = 1;
! #if 0
  			printk("Using ELF interpreter %s\n", elf_interpreter);
  #endif
  
--- 539,545 ----
  			if (strcmp(elf_interpreter,"/usr/lib/libc.so.1") == 0 ||
  			    strcmp(elf_interpreter,"/usr/lib/ld.so.1") == 0)
  				ibcs2_interpreter = 1;
! #if 1
  			printk("Using ELF interpreter %s\n", elf_interpreter);
  #endif
  
***************
*** 629,641 ****
  	/* Do this so that we can load the interpreter, if need be.  We will
  	   change some of these later */
  	current->mm->rss = 0;
  	retval = setup_arg_pages(bprm);
  	if (retval < 0) {
  		send_sig(SIGKILL, current, 0);
  		return retval;
  	}
! 	
  	current->mm->start_stack = bprm->p;
  	/* Now we do a little grungy work by mmaping the ELF image into
  	   the correct location in memory.  At this point, we assume that
  	   the image should be loaded at fixed address, not at a variable
--- 636,652 ----
  	/* Do this so that we can load the interpreter, if need be.  We will
  	   change some of these later */
  	current->mm->rss = 0;
+ 	printk("bprm->p = %lx\n",bprm->p);
  	retval = setup_arg_pages(bprm);
  	if (retval < 0) {
  		send_sig(SIGKILL, current, 0);
  		return retval;
  	}
! 
! 	//bprm->p = 0x500000;
  	current->mm->start_stack = bprm->p;
+ 	printk("bprm->p = %lx\n",bprm->p);
+ 	
  	/* Now we do a little grungy work by mmaping the ELF image into
  	   the correct location in memory.  At this point, we assume that
  	   the image should be loaded at fixed address, not at a variable
***************
*** 680,685 ****
--- 691,698 ----
  			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
  		}
  
+ printk("before elf_map %08X %08X\n",load_bias,vaddr);
+ 
  		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);
  		if (BAD_ADDR(error))
  			continue;
***************
*** 694,699 ****
--- 707,713 ----
  				reloc_func_desc = load_addr;
  			}
  		}
+ printk("load_addr %08X\n",load_addr);
  		k = elf_ppnt->p_vaddr;
  		if (k < start_code) start_code = k;
  		if (start_data < k) start_data = k;
***************
*** 750,755 ****
--- 764,771 ----
  	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
  	bprm->p = (unsigned long)
+ 	printk("cr-el-ta %d %d\n",interpreter_type,INTERPRETER_AOUT);
+ 	
  	  create_elf_tables((char *)bprm->p,
  			bprm->argc,
  			bprm->envc,
***************
*** 810,815 ****
--- 826,832 ----
  	ELF_PLAT_INIT(regs, reloc_func_desc);
  #endif
  
+ printk("elf_entry %08X %08X\n",elf_entry, bprm->p);
  	start_thread(regs, elf_entry, bprm->p);
  	if (current->ptrace & PT_PTRACED)
  		send_sig(SIGTRAP, current, 0);
diff -crBN linux-2.4.27/fs/binfmt_flat.c linux-2.4.27-w/fs/binfmt_flat.c
*** linux-2.4.27/fs/binfmt_flat.c	1969-12-31 16:00:00.000000000 -0800
--- linux-2.4.27-w/fs/binfmt_flat.c	2013-01-22 23:28:42.001023584 -0800
***************
*** 0 ****
--- 1,1211 ----
+ /****************************************************************************/
+ /*
+  *  linux/fs/binfmt_flat.c
+  *
+  *	Copyright (C) 2000-2003 David McCullough <davidm@snapgear.com>
+  *	Copyright (C) 2002 Greg Ungerer <gerg@snapgear.com>
+  *	Copyright (C) 2002 SnapGear, by Paul Dale <pauli@snapgear.com>
+  *	Copyright (C) 2000, 2001 Lineo, by David McCullough <davidm@lineo.com>
+  *  based heavily on:
+  *
+  *  linux/fs/binfmt_aout.c:
+  *      Copyright (C) 1991, 1992, 1996  Linus Torvalds
+  *  linux/fs/binfmt_flat.c for 2.0 kernel
+  *	    Copyright (C) 1998  Kenneth Albanowski <kjahds@kjahds.com>
+  *	JAN/99 -- coded full program relocation (gerg@snapgear.com)
+  */
+ 
+ #include <linux/module.h>
+ #include <linux/config.h>
+ #include <linux/kernel.h>
+ #include <linux/sched.h>
+ #include <linux/mm.h>
+ #include <linux/mman.h>
+ #include <linux/a.out.h>
+ #include <linux/errno.h>
+ #include <linux/signal.h>
+ #include <linux/string.h>
+ #include <linux/fs.h>
+ #include <linux/file.h>
+ #include <linux/stat.h>
+ #include <linux/fcntl.h>
+ #include <linux/ptrace.h>
+ #include <linux/user.h>
+ #include <linux/slab.h>
+ #include <linux/binfmts.h>
+ #include <linux/personality.h>
+ #include <linux/init.h>
+ #include <linux/flat.h>
+ 
+ #include <asm/byteorder.h>
+ #include <asm/system.h>
+ #include <asm/uaccess.h>
+ #include <asm/pgalloc.h>
+ #include <asm/unaligned.h>
+ 
+ /****************************************************************************/
+ 
+ #if 1
+ #define DEBUG 1
+ #endif
+ 
+ #ifdef DEBUG
+ #define	DBG_FLT(a...)	printk(a)
+ #else
+ #define	DBG_FLT(a...)
+ #endif
+ 
+ 
+ 
+ //#define MEMMASK 0x00ffffff
+ #define MEMMASK 0x01ffffff
+ 
+ #define RELOC_FAILED 0xff00ff01		/* Relocation incorrect somewhere */
+ #define UNLOADED_LIB 0x7ff000ff		/* Placeholder for unused library */
+ 
+ struct lib_info {
+ 	struct {
+ 		unsigned long start_code;		/* Start of text segment */
+ 		unsigned long start_data;		/* Start of data segment */
+ 		unsigned long start_brk;		/* End of data segment */
+ 		unsigned long text_len;			/* Length of text segment */
+ 		unsigned long entry;			/* Start address for this module */
+ 		unsigned long build_date;		/* When this one was compiled */
+ 		short loaded;				/* Has this library been loaded? */
+ 	} lib_list[MAX_SHARED_LIBS];
+ };
+ 
+ #ifdef CONFIG_BINFMT_SHARED_FLAT
+ static int load_flat_shared_library(int id, struct lib_info *p);
+ #endif
+ 
+ static int load_flat_binary(struct linux_binprm *, struct pt_regs * regs);
+ static int flat_core_dump(long signr, struct pt_regs * regs, struct file *file);
+ 
+ extern void dump_thread(struct pt_regs *, struct user *);
+ 
+ static struct linux_binfmt flat_format = {
+ 	.module		= THIS_MODULE,
+ 	.load_binary	= load_flat_binary,
+ 	.core_dump	= flat_core_dump,
+ 	.min_coredump	= PAGE_SIZE
+ };
+ 
+ /****************************************************************************/
+ /*
+  * Routine writes a core dump image in the current directory.
+  * Currently only a stub-function.
+  */
+ 
+ static int flat_core_dump(long signr, struct pt_regs * regs, struct file *file)
+ {
+ 	printk("Process %s:%d received signr %d and should have core dumped\n",
+ 			current->comm, current->pid, (int) signr);
+ 	return(1);
+ }
+ 
+ /****************************************************************************/
+ /*
+  * create_flat_tables() parses the env- and arg-strings in new user
+  * memory and creates the pointer tables from them, and puts their
+  * addresses on the "stack", returning the new stack pointer value.
+  */
+ 
+ static unsigned long create_flat_tables(
+ 	unsigned long pp,
+ 	struct linux_binprm * bprm)
+ {
+ 	unsigned long *argv,*envp;
+ 	unsigned long * sp;
+ 	char * p = (char*)pp;
+ 	int argc = bprm->argc;
+ 	int envc = bprm->envc;
+ 	char dummy;
+ 
+ 	sp = (unsigned long *) ((-(unsigned long)sizeof(char *))&(unsigned long) p);
+ 
+ 	sp -= envc+1;
+ 	envp = sp;
+ 	sp -= argc+1;
+ 	argv = sp;
+ 
+ 	flat_stack_align(sp);
+ 	if (flat_argvp_envp_on_stack()) {
+ 		--sp; put_user((unsigned long) envp, sp);
+ 		--sp; put_user((unsigned long) argv, sp);
+ 	}
+ 
+ 	put_user(argc,--sp);
+ 	current->mm->arg_start = (unsigned long) p;
+ 	while (argc-->0) {
+ 		put_user((unsigned long) p, argv++);
+ 		do {
+ 			get_user(dummy, p); p++;
+ 		} while (dummy);
+ 	}
+ 	put_user((unsigned long) NULL, argv);
+ 	current->mm->arg_end = current->mm->env_start = (unsigned long) p;
+ 	while (envc-->0) {
+ 		put_user((unsigned long)p, envp); envp++;
+ 		do {
+ 			get_user(dummy, p); p++;
+ 		} while (dummy);
+ 	}
+ 	put_user((unsigned long) NULL, envp);
+ 	current->mm->env_end = (unsigned long) p;
+ 	return (unsigned long)sp;
+ }
+ 
+ /****************************************************************************/
+ 
+ #ifdef CONFIG_BINFMT_ZFLAT
+ 
+ #include <linux/zlib.h>
+ 
+ #define LBUFSIZE	4000
+ 
+ /* gzip flag byte */
+ #define ASCII_FLAG   0x01 /* bit 0 set: file probably ASCII text */
+ #define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
+ #define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+ #define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+ #define COMMENT      0x10 /* bit 4 set: file comment present */
+ #define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
+ #define RESERVED     0xC0 /* bit 6,7:   reserved */
+ 
+ static int decompress_exec(
+ 	struct linux_binprm *bprm,
+ 	unsigned long offset,
+ 	char *dst,
+ 	long len,
+ 	int fd)
+ {
+ 	unsigned char *buf;
+ 	z_stream strm;
+ 	loff_t fpos;
+ 	int ret, retval;
+ 
+ 	DBG_FLT("decompress_exec(offset=%x,buf=%x,len=%x)\n",(int)offset, (int)dst, (int)len);
+ 
+ 	memset(&strm, 0, sizeof(strm));
+ 	strm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);
+ 	if (strm.workspace == NULL) {
+ 		DBG_FLT("binfmt_flat: no memory for decompress workspace\n");
+ 		return -ENOMEM;
+ 	}
+ 	buf = kmalloc(LBUFSIZE, GFP_KERNEL);
+ 	if (buf == NULL) {
+ 		DBG_FLT("binfmt_flat: no memory for read buffer\n");
+ 		retval = -ENOMEM;
+ 		goto out_free;
+ 	}
+ 
+ 	/* Read in first chunk of data and parse gzip header. */
+ 	fpos = offset;
+ 	ret = bprm->file->f_op->read(bprm->file, buf, LBUFSIZE, &fpos);
+ 
+ 	strm.next_in = buf;
+ 	strm.avail_in = ret;
+ 	strm.total_in = 0;
+ 
+ 	retval = -ENOEXEC;
+ 
+ 	/* Check minimum size -- gzip header */
+ 	if (ret < 10) {
+ 		DBG_FLT("binfmt_flat: file too small?\n");
+ 		goto out_free_buf;
+ 	}
+ 
+ 	/* Check gzip magic number */
+ 	if ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {
+ 		DBG_FLT("binfmt_flat: unknown compression magic?\n");
+ 		goto out_free_buf;
+ 	}
+ 
+ 	/* Check gzip method */
+ 	if (buf[2] != 8) {
+ 		DBG_FLT("binfmt_flat: unknown compression method?\n");
+ 		goto out_free_buf;
+ 	}
+ 	/* Check gzip flags */
+ 	if ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||
+ 	    (buf[3] & RESERVED)) {
+ 		DBG_FLT("binfmt_flat: unknown flags?\n");
+ 		goto out_free_buf;
+ 	}
+ 
+ 	ret = 10;
+ 	if (buf[3] & EXTRA_FIELD) {
+ 		ret += 2 + buf[10] + (buf[11] << 8);
+ 		if (unlikely(LBUFSIZE == ret)) {
+ 			DBG_FLT("binfmt_flat: buffer overflow (EXTRA)?\n");
+ 			goto out_free_buf;
+ 		}
+ 	}
+ 	if (buf[3] & ORIG_NAME) {
+ 		for (; ret < LBUFSIZE && (buf[ret] != 0); ret++)
+ 			;
+ 		if (unlikely(LBUFSIZE == ret)) {
+ 			DBG_FLT("binfmt_flat: buffer overflow (ORIG_NAME)?\n");
+ 			goto out_free_buf;
+ 		}
+ 	}
+ 	if (buf[3] & COMMENT) {
+ 		for (;  ret < LBUFSIZE && (buf[ret] != 0); ret++)
+ 			;
+ 		if (unlikely(LBUFSIZE == ret)) {
+ 			DBG_FLT("binfmt_flat: buffer overflow (COMMENT)?\n");
+ 			goto out_free_buf;
+ 		}
+ 	}
+ 
+ 	strm.next_in += ret;
+ 	strm.avail_in -= ret;
+ 
+ 	strm.next_out = dst;
+ 	strm.avail_out = len;
+ 	strm.total_out = 0;
+ 
+ 	if (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {
+ 		DBG_FLT("binfmt_flat: zlib init failed?\n");
+ 		goto out_free_buf;
+ 	}
+ 
+ 	while ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {
+ 		ret = bprm->file->f_op->read(bprm->file, buf, LBUFSIZE, &fpos);
+ 		if (ret <= 0)
+ 			break;
+ 		if (ret >= (unsigned long) -4096)
+ 			break;
+ 		len -= ret;
+ 
+ 		strm.next_in = buf;
+ 		strm.avail_in = ret;
+ 		strm.total_in = 0;
+ 	}
+ 
+ 	if (ret < 0) {
+ 		DBG_FLT("binfmt_flat: decompression failed (%d), %s\n",
+ 			ret, strm.msg);
+ 		goto out_free_buf;
+ 	}
+ 
+ 	zlib_inflateEnd(&strm);
+ 	retval = 0;
+ out_free_buf:
+ 	kfree(buf);
+ out_free:
+ 	kfree(strm.workspace);
+ out:
+ 	return retval;
+ }
+ 
+ #endif /* CONFIG_BINFMT_ZFLAT */
+ 
+ /****************************************************************************/
+ 
+ static unsigned long
+ calc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)
+ {
+ 	unsigned long addr;
+ 	int id;
+ 	unsigned long start_brk;
+ 	unsigned long start_data;
+ 	unsigned long text_len;
+ 	unsigned long start_code;
+ 
+ #ifdef CONFIG_BINFMT_SHARED_FLAT
+ 	if (r == 0)
+ 		id = curid;	/* Relocs of 0 are always self referring */
+ 	else {
+ 		id = (r >> 24) & 0xff;	/* Find ID for this reloc */
+ 		r &= MEMMASK;	/* Trim ID off here */
+ 	}
+ 	if (id >= MAX_SHARED_LIBS) {
+ 		printk("BINFMT_FLAT: reference 0x%x to shared library %d",
+ 				(unsigned) r, id);
+ 		goto failed;
+ 	}
+ 	if (curid != id) {
+ 		if (internalp) {
+ 			printk("BINFMT_FLAT: reloc address 0x%x not in same module "
+ 					"(%d != %d)", (unsigned) r, curid, id);
+ 			goto failed;
+ 		} else if ( ! p->lib_list[id].loaded &&
+ 				load_flat_shared_library(id, p) > (unsigned long) -4096) {
+ 			printk("BINFMT_FLAT: failed to load library %d", id);
+ 			goto failed;
+ 		}
+ 		/* Check versioning information (i.e. time stamps) */
+ 		if (p->lib_list[id].build_date && p->lib_list[curid].build_date &&
+ 				p->lib_list[curid].build_date < p->lib_list[id].build_date) {
+ 			printk("BINFMT_FLAT: library %d is younger than %d", id, curid);
+ 			goto failed;
+ 		}
+ 	}
+ #else
+ 	id = 0;
+ #endif
+ 
+ 	start_brk = p->lib_list[id].start_brk;
+ 	start_data = p->lib_list[id].start_data;
+ 	start_code = p->lib_list[id].start_code;
+ 	text_len = p->lib_list[id].text_len;
+         
+ 	if (!flat_reloc_valid(r, start_brk - start_data + text_len)) {
+ 		printk("BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x/0x%x)",
+ 		       (int) r,(int)(start_brk-start_code),(int)text_len);
+ 		goto failed;
+ 	} 
+ 
+ //         printk("%s:%d r 0x%08x text_len 0x%08x start_code 0x%08x \n", __FILE__, __LINE__, r, text_len, start_code);
+ 
+ 	if (r < text_len)			/* In text segment */
+ 		addr = r + start_code;
+ 	else					/* In data segment */
+ 		addr = r - text_len + start_data;
+ 
+ 	/* Range checked already above so doing the range tests is redundant...*/
+ 	return(addr);
+ 
+ failed:
+ 	printk(", killing %s!\n", current->comm);
+ 	send_sig(SIGSEGV, current, 0);
+ 
+ 	return RELOC_FAILED;
+ }
+ 
+ /****************************************************************************/
+ #ifdef CONFIG_MIPS
+ typedef struct {
+ 	unsigned long flags;
+ 	unsigned long opcode;
+ 	unsigned long *ptr;
+ } mips_save_hi_reloc;
+ #endif
+ 
+ void calc_v5_reloc(int i, unsigned long rl)
+ {
+ 	flat_v5_reloc_t r;
+ 	unsigned long *ptr;
+ 	unsigned short *usptr;
+ 	unsigned long offset, opcode;
+ #ifdef CONFIG_MIPS
+ 	mips_save_hi_reloc hi_reloc;
+ #endif
+ #ifdef CONFIG_BLACKFIN
+ 	static int save_carry;
+ #endif
+ 
+ 	r.value = rl;
+ 	ptr = (unsigned long *)(current->mm->start_code + r.reloc.offset);
+ 
+ 	switch (r.reloc.sp)
+ 	{
+ #ifdef CONFIG_MIPS
+ 	case FLAT_MIPS_RELOC_SP(FLAT_MIPS_RELOC_SP_TYPE_16_BIT, FLAT_MIPS_RELOC_SP_NO_CARRY):
+ 		offset = (*ptr) & 0x0000FFFFL;
+ 		if (r.reloc.hi_lo)
+ 			offset <<= 16;
+ 
+ 		opcode = (*ptr) & 0xFFFF0000L;
+ 
+ 		switch (r.reloc.type)
+ 		{
+ 		case FLAT_V5_RELOC_TYPE_TEXT:
+ 			offset += current->mm->start_code;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_DATA:
+ 			offset += current->mm->start_data;
+ 			break;
+ 		case  FLAT_V5_RELOC_TYPE_BSS:
+ 			offset += current->mm->end_data;
+ 			break;
+ 		default:
+ 			printk("BINFMT_FLAT: Unknown relocation type=%x\n",
+ 					r.reloc.type);
+ 			break;
+ 		}
+ 
+ 		if (r.reloc.hi_lo)
+ 			offset >>= 16;
+ 
+ 		(*ptr) = opcode | (offset & 0x0000FFFFL);
+ 
+ 		if (r.reloc.hi_lo)
+ 		{
+ 			hi_reloc.flags = 1;
+ 			hi_reloc.opcode = (*ptr);
+ 			hi_reloc.ptr = ptr;
+ 		}
+ 		break;
+ 	case FLAT_MIPS_RELOC_SP(FLAT_MIPS_RELOC_SP_TYPE_16_BIT, FLAT_MIPS_RELOC_SP_CARRY):
+ 		offset = (*ptr) & 0x0000FFFFL;
+ 		if (r.reloc.hi_lo)
+ 			offset <<= 16;
+ 
+ 		opcode = (*ptr) & 0xFFFF0000L;
+ 
+ 		switch (r.reloc.type)
+ 		{
+ 		case FLAT_V5_RELOC_TYPE_TEXT:
+ 			offset += current->mm->start_code;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_DATA:
+ 			offset += current->mm->start_data;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_BSS:
+ 			offset += current->mm->end_data;
+ 			break;
+ 		default:
+ 			printk("BINFMT_FLAT: Unknown relocation type=%x\n",
+ 					r.reloc.type);
+ 			break;
+ 		}
+ 
+ 		if (r.reloc.hi_lo)
+ 			offset >>= 16;
+ 
+ 		(*ptr) = opcode | (offset & 0x0000FFFFL);
+ 
+ 		if (r.reloc.hi_lo)
+ 		{
+ 			hi_reloc.flags = 1;
+ 			hi_reloc.opcode = (*ptr);
+ 			hi_reloc.ptr = ptr;
+ 		} else {
+ 			unsigned long temp;
+ 			if (hi_reloc.flags == 1)
+ 			{
+ 				if ((*ptr) & 0x00008000L)
+ 				{
+ 					temp = hi_reloc.opcode & 0x0000FFFFL;
+ 					temp += 1;
+ 					hi_reloc.opcode = 
+ 					    ((hi_reloc.opcode & 0xFFFF0000L) |
+ 					     (temp & 0x0000FFFFL));
+ 					*(hi_reloc.ptr) = hi_reloc.opcode;
+ 					hi_reloc.flags = 0;
+ 				}
+ 			}
+ 		}
+ 		break;
+ 	case FLAT_MIPS_RELOC_SP(FLAT_MIPS_RELOC_SP_TYPE_26_BIT, FLAT_MIPS_RELOC_SP_NO_CARRY):
+ 		if (hi_reloc.flags)
+ 			hi_reloc.flags = 0;
+ 
+ 		offset = (*ptr) & 0x03FFFFFFL;
+ 		offset <<= 2;
+ 
+ 		opcode = (*ptr) & 0xFC000000L;
+ 
+ 		switch (r.reloc.type)
+ 		{
+ 		case FLAT_V5_RELOC_TYPE_TEXT:
+ 			offset += current->mm->start_code;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_DATA:
+ 			offset += current->mm->start_data;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_BSS:
+ 			offset += current->mm->end_data;
+ 			break;
+ 		default:
+ 			printk("BINFMT_FLAT: Unknown relocation type=%x\n",
+ 					r.reloc.type);
+ 			break;
+ 		}
+ 		offset >>= 2;
+ 
+ 		(*ptr) = opcode | (offset & 0x03FFFFFFL);
+ 		break;
+ 	case FLAT_MIPS_RELOC_SP(FLAT_MIPS_RELOC_SP_TYPE_32_BIT, FLAT_MIPS_RELOC_SP_NO_CARRY):
+ 		offset = *ptr;
+ 
+ 		switch (r.reloc.type)
+ 		{
+ 		case FLAT_V5_RELOC_TYPE_TEXT:
+ 			offset += current->mm->start_code;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_DATA:
+ 			offset += current->mm->start_data;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_BSS:
+ 			offset += current->mm->end_data;
+ 			break;
+ 		default:
+ 			printk("BINFMT_FLAT: offset = %x, Unknown relocation type = %x",
+ 					r.reloc.offset, r.reloc.type);
+ 			break;
+ 		}
+ 		*ptr = offset;
+ 		break;
+ #endif /* CONFIG_MIPS */
+ #ifdef CONFIG_BLACKFIN
+ 	case FLAT_BLACKFIN_RELOC_SP_TYPE_16_BIT:
+ 		usptr = (unsigned short *)ptr;
+ 
+ 		switch (r.reloc.type)
+ 		{
+ 		case FLAT_V5_RELOC_TYPE_TEXT:
+ 			offset = current->mm->start_code;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_DATA:
+ 			offset = current->mm->start_data;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_BSS:
+ 			offset = current->mm->end_data;
+ 			break;
+ 		default:
+ 			printk("BINFMT_FLAT: Unknown relocation type = %x\n",
+ 					r.reloc.type);
+ 			break;
+ 		}
+ 
+ 		if (r.reloc.hi_lo) 
+ 		{
+ 			offset >>= 16;
+ 			offset += *usptr;
+ 			offset += save_carry;
+ 		} else {
+ 			offset &= 0xffff;
+ 			offset += *usptr;
+ 			save_carry = (offset >> 16) & 1;
+ 		}
+ 		*usptr = offset;
+ 		break;
+ 	case FLAT_BLACKFIN_RELOC_SP_TYPE_32_BIT:
+ 		offset = *ptr;
+ 
+ 		switch (r.reloc.type)
+ 		{
+ 		case FLAT_V5_RELOC_TYPE_TEXT:
+ 			offset += current->mm->start_code;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_DATA:
+ 			offset += current->mm->start_data;
+ 			break;
+ 		case FLAT_V5_RELOC_TYPE_BSS:
+ 			offset += current->mm->end_data;
+ 			break;
+ 		default:
+ 			printk("BINFMT_FLAT: offset = %x, Unknown relocation type = %x",
+ 					r.reloc.offset, r.reloc.type);
+ 			break;
+ 		}
+ 		*ptr = offset;
+ 		break;
+ #endif /* CONFIG_BLACKFIN */	
+ 	default:
+ 		printk("BINFMT_FLAT: Unknown relocation type %x\n", r.reloc.sp);
+ 		break;
+ 	}
+ }
+ 
+ /****************************************************************************/
+ 
+ void old_reloc(unsigned long rl)
+ {
+ #ifdef DEBUG
+ 	char *segment[] = { "TEXT", "DATA", "BSS", "*UNKNOWN*" };
+ #endif
+ #if !defined(__H8300H__) && !defined(__H8300S__)
+ 	flat_v2_reloc_t	r;
+ #endif
+ 	unsigned long *ptr;
+ 
+ #if !defined(__H8300H__) && !defined(__H8300S__)
+ 	r.value = rl;
+ #if defined(CONFIG_COLDFIRE)
+ 	ptr = (unsigned long *) (current->mm->start_code + r.reloc.offset);
+ #else
+ 	ptr = (unsigned long *) (current->mm->start_data + r.reloc.offset);
+ #endif
+ 
+ #ifdef DEBUG
+ 	printk("Relocation of variable at DATASEG+%x "
+ 		"(address %p, currently %x) into segment %s\n",
+ 		r.reloc.offset, ptr, (int)*ptr, segment[r.reloc.type]);
+ #endif
+ 	
+ 	switch (r.reloc.type) {
+ 	case OLD_FLAT_RELOC_TYPE_TEXT:
+ 		*ptr += current->mm->start_code;
+ 		break;
+ 	case OLD_FLAT_RELOC_TYPE_DATA:
+ 		*ptr += current->mm->start_data;
+ 		break;
+ 	case OLD_FLAT_RELOC_TYPE_BSS:
+ 		*ptr += current->mm->end_data;
+ 		break;
+ 	default:
+ 		printk("BINFMT_FLAT: Unknown relocation type=%x\n", r.reloc.type);
+ 		break;
+ 	}
+ 
+ #ifdef DEBUG
+ 	printk("Relocation became %x\n", (int)*ptr);
+ #endif
+ #else
+ 	ptr = (unsigned long *)(current->mm->start_code+rl);
+ 	if (ptr >= current->mm->end_code)
+ 		ptr += sizeof(MAX_SHARED_LIBS) / sizeof (*ptr);
+ 	*ptr += current->mm->start_code;
+ 	if ((*ptr & MEMMASK) >= current->mm->end_code)
+ 		*ptr += MAX_SHARED_LIBS * sizeof(unsigned long);
+ #endif
+ }		
+ 
+ /****************************************************************************/
+ 
+ static int load_flat_file(struct linux_binprm * bprm,
+ 		struct lib_info *libinfo, int id, unsigned long *extra_stack)
+ {
+ 	struct flat_hdr * hdr;
+ 	unsigned long textpos = 0, datapos = 0, result;
+ 	unsigned long realdatastart = 0;
+ 	unsigned long text_len, data_len, bss_len, stack_len, flags;
+ 	unsigned long memp = 0; /* for finding the brk area */
+ 	unsigned long extra, rlim;
+ 	unsigned long *reloc = 0, *rp;
+ 	struct inode *inode;
+ 	int i, rev, relocs = 0;
+ 	loff_t fpos;
+ 	unsigned long start_code, end_code;
+ 
+ 	hdr = ((struct flat_hdr *) bprm->buf);		/* exec-header */
+ 	inode = bprm->file->f_dentry->d_inode;
+ 
+ 	text_len  = ntohl(hdr->data_start);
+ 	data_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);
+ 	bss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);
+ 	stack_len = ntohl(hdr->stack_size);
+         
+ //         printk("%s:%d text_len %x, data_len %x, bss_len %x, stack_len %x\n", 
+ //             __FILE__, __LINE__, text_len, data_len, bss_len, stack_len);
+         
+ 	if (extra_stack) {
+ 		stack_len += *extra_stack;
+ 		*extra_stack = stack_len;
+ 	}
+ 	relocs    = ntohl(hdr->reloc_count);
+ 	flags     = ntohl(hdr->flags);
+ 	rev       = ntohl(hdr->rev);
+ 
+ 	if (flags & FLAT_FLAG_KTRACE)
+ 		printk("BINFMT_FLAT: Loading file: %s\n", bprm->filename);
+ 
+ 	if (strncmp(hdr->magic, "bFLT", 4) ||
+ 			(rev != FLAT_VERSION && rev != OLD_FLAT_VERSION &&
+ 			 rev != V5_FLAT_VERSION)) {
+ 		/*
+ 		 * because a lot of people do not manage to produce good
+ 		 * flat binaries,  we leave this printk to help them realise
+ 		 * the problem.  We only print the error if its not a script file
+ 		 */
+ 		if (strncmp(hdr->magic, "#!", 2))
+ 			printk("BINFMT_FLAT: bad magic/rev (0x%x, need 0x%x)\n",
+ 					rev, (int) FLAT_VERSION);
+ 		return -ENOEXEC;
+ 	}
+ 	/* Don't allow old format executables to use shared libraries */
+ 	if (rev == OLD_FLAT_VERSION && id != 0) {
+ 		printk("BINFMT_FLAT: shared libraries are not available before rev 0x%x\n",
+ 				(int) FLAT_VERSION);
+ 		return -ENOEXEC;
+ 	}
+ 
+ 	/*
+ 	 * fix up the flags for the older format,  there were all kinds
+ 	 * of endian hacks,  this only works for the simple cases
+ 	 */
+ 	if (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))
+ 		flags = FLAT_FLAG_RAM;
+ 
+ #ifndef CONFIG_BINFMT_ZFLAT
+ 	if (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {
+ 		printk("Support for ZFLAT executables is not enabled.\n");
+ 		return -ENOEXEC;
+ 	}
+ #endif
+ 
+ 	/*
+ 	 * Check initial limits. This avoids letting people circumvent
+ 	 * size limits imposed on them by creating programs with large
+ 	 * arrays in the data or bss.
+ 	 */
+ 	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+ 	if (rlim >= RLIM_INFINITY)
+ 		rlim = ~0;
+ 	if (data_len + bss_len > rlim)
+ 		return -ENOMEM;
+ 
+ 	/* Flush all traces of the currently running executable */
+ 	if (id == 0) {
+ 		result = flush_old_exec(bprm);
+ 		if (result)
+ 			return result;
+ 
+ 		/* OK, This is the point of no return */
+ 		set_personality(PER_LINUX);
+ 	}
+ //         printk("%s:%d\n", __FILE__, __LINE__);
+ 
+ 	/*
+ 	 * calculate the extra space we need to map in
+ 	 */
+ 	extra = max(bss_len + stack_len, (long)relocs * sizeof(unsigned long));
+ 
+ 	/*
+ 	 * there are a couple of cases here,  the seperate code/data
+ 	 * case,  and then the fully copied to RAM case which lumps
+ 	 * it all together.
+ 	 */
+ 	if ((flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP)) == 0) {
+ 		/*
+ 		 * this should give us a ROM ptr,  but if it doesn't we don't
+ 		 * really care
+ 		 */
+ 		DBG_FLT("BINFMT_FLAT: ROM mapping of file (we hope)\n");
+ 
+ 		down_write(&current->mm->mmap_sem);
+ 		textpos = do_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC, 0, 0);
+ 		up_write(&current->mm->mmap_sem);
+ 		if (!textpos  || textpos >= (unsigned long) -4096) {
+ 			if (!textpos)
+ 				textpos = (unsigned long) -ENOMEM;
+ 			printk("Unable to mmap process text, errno %d\n", (int)-textpos);
+ 			return(textpos);
+ 		}
+ 
+ 		down_write(&current->mm->mmap_sem);
+ 		realdatastart = do_mmap(0, 0, data_len + extra +
+ 				MAX_SHARED_LIBS * sizeof(unsigned long),
+ 				PROT_READ|PROT_WRITE|PROT_EXEC, 0, 0);
+ 		up_write(&current->mm->mmap_sem);
+ 
+ 		if (realdatastart == 0 || realdatastart >= (unsigned long)-4096) {
+ 			if (!realdatastart)
+ 				realdatastart = (unsigned long) -ENOMEM;
+ 			printk("Unable to allocate RAM for process data, errno %d\n",
+ 					(int)-datapos);
+ 			do_munmap(current->mm, textpos, text_len);
+ 			return realdatastart;
+ 		}
+ 		datapos = realdatastart + MAX_SHARED_LIBS * sizeof(unsigned long);
+ 
+ 		DBG_FLT("BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\n",
+ 				(int)(data_len + bss_len + stack_len), (int)datapos);
+ 
+ 		fpos = ntohl(hdr->data_start);
+ #ifdef CONFIG_BINFMT_ZFLAT
+ 		if (flags & FLAT_FLAG_GZDATA) {
+ 			result = decompress_exec(bprm, fpos, (char *) datapos, 
+ 						 data_len + (relocs * sizeof(unsigned long)), 0);
+ 		} else
+ #endif
+ 		{
+ 			result = bprm->file->f_op->read(bprm->file, (char *) datapos,
+ 					data_len + (relocs * sizeof(unsigned long)), &fpos);
+ 		}
+ 		if (result >= (unsigned long)-4096) {
+ 			printk("Unable to read data+bss, errno %d\n", (int)-result);
+ 			do_munmap(current->mm, textpos, text_len);
+ 			do_munmap(current->mm, realdatastart, data_len + extra);
+ 			return result;
+ 		}
+ 
+ 		reloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));
+ 		memp = realdatastart;
+ 
+ 	} else {
+ 
+ 		down_write(&current->mm->mmap_sem);
+ 
+ // 		textpos = do_mmap(0, 0, text_len + data_len + extra +
+ // 					MAX_SHARED_LIBS * sizeof(unsigned long),
+ // 				PROT_READ | PROT_EXEC | PROT_WRITE, 0, 0);
+ 
+                 /* textpos is the destination */
+ 		textpos = do_mmap(0, 0, text_len + data_len + extra +
+ 					MAX_SHARED_LIBS * sizeof(unsigned long),
+ 				PROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);
+                                 
+ //                 printk("%s:%d do_mmap -> textpos 0x%08x\n", __FILE__, __LINE__, textpos);
+ //                 printk("%s:%d entry 0x%08x, reloc_start 0x%08x, reloc_count 0x%08x\n", 
+ //                         __FILE__, __LINE__, ntohl(hdr->entry), ntohl(hdr->reloc_start), ntohl(hdr->reloc_count));
+ 
+ 		up_write(&current->mm->mmap_sem);
+ 		if (!textpos  || textpos >= (unsigned long) -4096) {
+ 			if (!textpos)
+ 				textpos = (unsigned long) -ENOMEM;
+ 			printk("Unable to allocate RAM for process text/data, errno %d\n",
+ 					(int)-textpos);
+ 			return(textpos);
+ 		}
+ 
+ 		realdatastart = textpos + ntohl(hdr->data_start);
+ 		datapos = realdatastart + MAX_SHARED_LIBS * sizeof(unsigned long);
+                                 
+ 		reloc = (unsigned long *) (textpos + ntohl(hdr->reloc_start) +
+ 				MAX_SHARED_LIBS* sizeof(unsigned long));
+ 
+ 		memp = textpos;
+ 
+ #ifdef CONFIG_BINFMT_ZFLAT
+ 		/*
+ 		 * load it all in and treat it like a RAM load from now on
+ 		 */
+ 		if (flags & FLAT_FLAG_GZIP) {
+ 			result = decompress_exec(bprm, sizeof (struct flat_hdr),
+ 					 (((char *) textpos) + sizeof (struct flat_hdr)),
+ 					 (text_len + data_len + (relocs * sizeof(unsigned long))
+ 						  - sizeof (struct flat_hdr)),
+ 					 0);
+ 			memmove((void *) datapos, (void *) realdatastart,
+ 					data_len + (relocs * sizeof(unsigned long)));
+ 		} else if (flags & FLAT_FLAG_GZDATA) {
+ 			fpos = 0;
+ 			result = bprm->file->f_op->read(bprm->file,
+ 					(char *) textpos, text_len, &fpos);
+ 			if (result < (unsigned long) -4096)
+ 				result = decompress_exec(bprm, text_len, (char *) datapos,
+ 						 data_len + (relocs * sizeof(unsigned long)), 0);
+ 		}
+ 		else
+ #endif
+ 		{
+ 			fpos = 0;
+ 			result = bprm->file->f_op->read(bprm->file,
+ 					(char *) textpos, text_len, &fpos);
+ 			if (result < (unsigned long) -4096) {
+ 				fpos = ntohl(hdr->data_start);
+ 				result = bprm->file->f_op->read(bprm->file, (char *) datapos,
+ 					data_len + (relocs * sizeof(unsigned long)), &fpos);
+ 			}
+ 		}
+ 		if (result >= (unsigned long)-4096) {
+ 			printk("Unable to read code+data+bss, errno %d\n",(int)-result);
+ 			do_munmap(current->mm, textpos, text_len + data_len + extra +
+ 				MAX_SHARED_LIBS * sizeof(unsigned long));
+ 			return result;
+ 		}
+ 	}
+ 
+ 	if (flags & FLAT_FLAG_KTRACE)
+ 		printk("Mapping is %x, Entry point is %x, data_start is %x\n",
+ 			(int)textpos, MEMMASK &ntohl(hdr->entry), ntohl(hdr->data_start));
+ 
+ 	/* The main program needs a little extra setup in the task structure */
+ 	start_code = textpos + sizeof (struct flat_hdr);
+ 	end_code = textpos + text_len;
+ 	if (id == 0) {
+ 		current->mm->start_code = start_code;
+ 		current->mm->end_code = end_code;
+ 		current->mm->start_data = datapos;
+ 		current->mm->end_data = datapos + data_len;
+ 		/*
+ 		 * set up the brk stuff, uses any slack left in data/bss/stack
+ 		 * allocation.  We put the brk after the bss (between the bss
+ 		 * and stack) like other platforms.
+ 		 */
+ 		current->mm->start_brk = datapos + data_len + bss_len;
+ 		current->mm->brk = (current->mm->start_brk + 3) & ~3;
+ 		current->mm->end_brk = memp + ksize((void *) memp) - stack_len;
+ 		current->mm->rss = 0;
+ 	}
+ 
+ 	if (flags & FLAT_FLAG_KTRACE)
+ 		printk("%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\n",
+ 			id ? "Lib" : "Load", bprm->filename,
+ 			(int) start_code, (int) end_code,
+ 			(int) datapos,
+ 			(int) (datapos + data_len),
+ 			(int) (datapos + data_len),
+ 			(int) (((datapos + data_len + bss_len) + 3) & ~3));
+ 
+ 	text_len -= sizeof(struct flat_hdr); /* the real code len */
+ 
+ 	/* Store the current module values into the global library structure */
+ 	libinfo->lib_list[id].start_code = start_code;
+ 	libinfo->lib_list[id].start_data = datapos;
+ 	libinfo->lib_list[id].start_brk = datapos + data_len + bss_len;
+ 	libinfo->lib_list[id].text_len = text_len;
+ 	libinfo->lib_list[id].loaded = 1;
+ 	libinfo->lib_list[id].entry = (MEMMASK & ntohl(hdr->entry)) + textpos;
+ 	libinfo->lib_list[id].build_date = ntohl(hdr->build_date);
+ 
+ 	/*
+ 	 * We just load the allocations into some temporary memory to
+ 	 * help simplify all this mumbo jumbo
+ 	 *
+ 	 * We've got two different sections of relocation entries.
+ 	 * The first is the GOT which resides at the begining of the data segment
+ 	 * and is terminated with a -1.  This one can be relocated in place.
+ 	 * The second is the extra relocation entries tacked after the image's
+ 	 * data segment. These require a little more processing as the entry is
+ 	 * really an offset into the image which contains an offset into the
+ 	 * image.
+ 	 */
+ 
+ 	/*
+ 	 * XXX: Don't perform any GOTPIC relocations for version 5 flats
+ 	 * for now.
+ 	 *
+ 	 * Faisal Akber
+ 	 */
+ 	if ((flags & FLAT_FLAG_GOTPIC) && (rev != 5)) {
+                 printk("%s:%d red %d\n", __FILE__, __LINE__, rev);
+ 		for (rp = (unsigned long *)datapos; *rp != 0xffffffff; rp++) {
+ 			unsigned long addr;
+ 			if (*rp) {
+ 				addr = calc_reloc(*rp, libinfo, id, 0);
+ 				if (addr == RELOC_FAILED)
+ 					return -ENOEXEC;
+ 				*rp = addr;
+ 			}
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Now run through the relocation entries.
+ 	 * We've got to be careful here as C++ produces relocatable zero
+ 	 * entries in the constructor and destructor tables which are then
+ 	 * tested for being not zero (which will always occur unless we're
+ 	 * based from address zero).  This causes an endless loop as __start
+ 	 * is at zero.  The solution used is to not relocate zero addresses.
+ 	 * This has the negative side effect of not allowing a global data
+ 	 * reference to be statically initialised to _stext (I've moved
+ 	 * __start to address 4 so that is okay).
+ 	 */
+ 	switch (rev)
+ 	{
+ 	case 5:
+ 		{
+ 			for (i = 0; i < relocs; i++)
+ 			{
+ 				/* Calculate each relocation, and replace
+ 				 * whatever necessary.
+ 				 */
+ 				calc_v5_reloc(i, reloc[i]);
+ 			}
+ 		}
+ 		break;
+ 	case 4:
+ 	case 3:
+ 		{
+ // 			for (i=0; i < relocs; i++) 
+ 			for (i=1; i < relocs; i++) 
+ 			{
+ 				unsigned long addr, relval;
+ 
+ 				/* Get the address of the pointer to be
+ 				   relocated (of course, the address has to be
+ 				   relocated first).  */
+ 				relval = ntohl(reloc[i]);
+ 				addr = flat_get_relocate_addr(relval);  /* returns input value*/
+                                 
+ //                                 printk("%s:%d addr 0x%x, relocs %d, libinfo 0x%08x, id 0x%08x, i %d\n", 
+ //                                     __FILE__, __LINE__, addr, relocs, libinfo, id, i);
+                                 
+ 				rp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);
+ 				if (rp == (unsigned long *)RELOC_FAILED)
+ 					return -ENOEXEC;
+ 
+ //                                 printk("%s:%d rp 0x%08x\n", __FILE__, __LINE__, rp);
+ 				/* Get the pointer's value.  */
+ 				addr = flat_get_addr_from_rp(rp, relval, flags);
+ 				if (addr != 0) 
+ 				{
+ 					/*
+ 					 * Do the relocation.  PIC relocs in 
+ 					 * the data section are already in 
+ 					 * target order
+ 					 */
+ 					if ((flags & FLAT_FLAG_GOTPIC) == 0)
+ 						addr = ntohl(addr);
+ 					addr = calc_reloc(addr, libinfo, id, 0);
+ 					if (addr == RELOC_FAILED)
+ 						return -ENOEXEC;
+ 
+ 					/* Write back the relocated pointer.  */
+ 					flat_put_addr_at_rp(rp, addr, relval);
+ 				}
+ 			}
+ 		}
+ 		break;
+ 	case 2:
+ 	case 1:
+ 		{
+ 			for (i=0; i < relocs; i++)
+ 				old_reloc(ntohl(reloc[i]));
+ 		}
+ 		break;
+ 	default:
+ 		printk("Invalid binary version number.\n");
+ 	}
+ 
+ //         printk("%s:%d flush_icache_range\n", __FILE__, __LINE__);
+ 	
+ 	flush_icache_range(start_code, end_code);
+ 
+ //         printk("%s:%d memset\n", __FILE__, __LINE__);
+ 	/* zero the BSS,  BRK and stack areas */
+ 	memset((void*)(datapos + data_len), 0, bss_len + 
+ 			(memp + ksize((void *) memp) - stack_len -	/* end brk */
+ 			libinfo->lib_list[id].start_brk) +		/* start brk */
+ 			stack_len);
+ 
+ //         printk("%s:%d return 0\n", __FILE__, __LINE__);
+ 	return 0;
+ }
+ 
+ 
+ /****************************************************************************/
+ #ifdef CONFIG_BINFMT_SHARED_FLAT
+ 
+ /*
+  * Load a shared library into memory.  The library gets its own data
+  * segment (including bss) but not argv/argc/environ.
+  */
+ 
+ static int load_flat_shared_library(int id, struct lib_info *libs)
+ {
+ 	struct linux_binprm bprm;
+ 	int res;
+ 	char buf[16];
+ 
+ 	/* Create the file name */
+ 	sprintf(buf, "/lib/lib%d.so", id);
+ 
+ 	/* Open the file up */
+ 	bprm.filename = buf;
+ 	bprm.file = open_exec(bprm.filename);
+ 	res = PTR_ERR(bprm.file);
+ 	if (IS_ERR(bprm.file))
+ 		return res;
+ 
+ 	res = prepare_binprm(&bprm);
+ 
+ 	if (res <= (unsigned long)-4096)
+ 		res = load_flat_file(&bprm, libs, id, NULL);
+ 	if (bprm.file) {
+ 		allow_write_access(bprm.file);
+ 		fput(bprm.file);
+ 		bprm.file = NULL;
+ 	}
+ 	return(res);
+ }
+ 
+ #endif /* CONFIG_BINFMT_SHARED_FLAT */
+ /****************************************************************************/
+ 
+ /*
+  * These are the functions used to load flat style executables and shared
+  * libraries.  There is no binary dependent code anywhere else.
+  */
+ 
+ static int load_flat_binary(struct linux_binprm * bprm, struct pt_regs * regs)
+ {
+ 	struct lib_info libinfo;
+ 	unsigned long p = bprm->p;
+ 	unsigned long stack_len;
+ 	unsigned long start_addr;
+ 	unsigned long *sp;
+ 	int res;
+ 	int i, j;
+         
+ 	memset(&libinfo, 0, sizeof(libinfo));
+ 	/*
+ 	 * We have to add the size of our arguments to our stack size
+ 	 * otherwise it's too easy for users to create stack overflows
+ 	 * by passing in a huge argument list.  And yes,  we have to be
+ 	 * pedantic and include space for the argv/envp array as it may have
+ 	 * a lot of entries.
+ 	 */
+ #define TOP_OF_ARGS (PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *))
+ 	stack_len = TOP_OF_ARGS - bprm->p;             /* the strings */
+ 	stack_len += (bprm->argc + 1) * sizeof(char *); /* the argv array */
+ 	stack_len += (bprm->envc + 1) * sizeof(char *); /* the envp array */
+ 	
+ 	res = load_flat_file(bprm, &libinfo, 0, &stack_len);
+ 	if (res > (unsigned long)-4096)
+ 		return res;
+ 	
+ 	/* Update data segment pointers for all libraries */
+ 	for (i=0; i<MAX_SHARED_LIBS; i++)
+ 		if (libinfo.lib_list[i].loaded)
+ 			for (j=0; j<MAX_SHARED_LIBS; j++)
+ 				(-(j+1))[(unsigned long *)(libinfo.lib_list[i].start_data)] =
+ 					(libinfo.lib_list[j].loaded)?
+ 						libinfo.lib_list[j].start_data:UNLOADED_LIB;
+ 
+ //         printk("%s:%d\n", __FILE__, __LINE__);
+ 	compute_creds(bprm);
+  	current->flags &= ~PF_FORKNOEXEC;
+ 
+ 	set_binfmt(&flat_format);
+ 
+ 	p = ((current->mm->end_brk + stack_len + 3) & ~3) - 4;
+ 	//DBG_FLT("p=%x\n", (int)p);
+ 
+ 	/* copy the arg pages onto the stack, this could be more efficient :-) */
+ 	for (i = TOP_OF_ARGS - 1; i >= bprm->p; i--)
+ 		* (char *) --p =
+ 			((char *) page_address(bprm->page[i/PAGE_SIZE]))[i % PAGE_SIZE];
+ 
+ 	sp = (unsigned long *) create_flat_tables(p, bprm);
+ //         printk("%s:%d\n", __FILE__, __LINE__);
+ 	
+ 	/* Fake some return addresses to ensure the call chain will
+ 	 * initialise library in order for us.  We are required to call
+ 	 * lib 1 first, then 2, ... and finally the main program (id 0).
+ 	 */
+ 	start_addr = libinfo.lib_list[0].entry;
+ 
+ #ifdef CONFIG_BINFMT_SHARED_FLAT
+ 	for (i = MAX_SHARED_LIBS-1; i>0; i--) {
+ 		if (libinfo.lib_list[i].loaded) {
+ 			/* Push previos first to call address */
+ 			--sp;	put_user(start_addr, sp);
+ 			start_addr = libinfo.lib_list[i].entry;
+ 		}
+ 	}
+ #endif
+ 	
+ //         printk("%s:%d\n", __FILE__, __LINE__);
+ 	/* Stash our initial stack pointer into the mm structure */
+ 	current->mm->start_stack = (unsigned long )sp;
+ 
+ 	
+ 	DBG_FLT("start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)\n",
+ 		(int)regs, (int)start_addr, (int)current->mm->start_stack);
+ 	
+ 	start_thread(regs, start_addr, current->mm->start_stack);
+ 
+ 	if (current->ptrace & PT_PTRACED)
+ 		send_sig(SIGTRAP, current, 0);
+ 
+ 	return 0;
+ }
+ 
+ /****************************************************************************/
+ 
+ static int __init init_flat_binfmt(void)
+ {
+ 	return register_binfmt(&flat_format);
+ }
+ 
+ static void __exit exit_flat_binfmt(void)
+ {
+ 	unregister_binfmt(&flat_format);
+ }
+ 
+ /****************************************************************************/
+ 
+ EXPORT_NO_SYMBOLS;
+ 
+ module_init(init_flat_binfmt);
+ module_exit(exit_flat_binfmt);
+ 
+ /****************************************************************************/
diff -crBN linux-2.4.27/fs/block_dev.c linux-2.4.27-w/fs/block_dev.c
*** linux-2.4.27/fs/block_dev.c	2003-06-13 07:51:37.000000000 -0700
--- linux-2.4.27-w/fs/block_dev.c	2013-01-22 23:03:30.371023651 -0800
***************
*** 572,578 ****
--- 572,581 ----
  		if (!ret) {
  			bdev->bd_openers++;
  			bdev->bd_inode->i_size = blkdev_size(dev);
+                         /*
  			bdev->bd_inode->i_blkbits = blksize_bits(block_size(dev));
+                         */
+ 			bdev->bd_inode->i_blkbits = blksize_bits(1024);
  		} else {
  			if (bdev->bd_op->owner)
  				__MOD_DEC_USE_COUNT(bdev->bd_op->owner);
diff -crBN linux-2.4.27/fs/exec.c linux-2.4.27-w/fs/exec.c
*** linux-2.4.27/fs/exec.c	2013-01-22 23:36:39.771023674 -0800
--- linux-2.4.27-w/fs/exec.c	2013-01-22 23:33:41.001023605 -0800
***************
*** 163,180 ****
  static int count(char ** argv, int max)
  {
  	int i = 0;
! 
  	if (argv != NULL) {
  		for (;;) {
  			char * p;
  
! 			if (get_user(p, argv))
  				return -EFAULT;
  			if (!p)
  				break;
  			argv++;
! 			if(++i > max)
  				return -E2BIG;
  		}
  	}
  	return i;
--- 163,183 ----
  static int count(char ** argv, int max)
  {
  	int i = 0;
!         int ret_val;
!         
  	if (argv != NULL) {
  		for (;;) {
  			char * p;
  
! 			if (ret_val = get_user(p, argv)) {
  				return -EFAULT;
+                                 }
  			if (!p)
  				break;
  			argv++;
! 			if(++i > max){
  				return -E2BIG;
+                                 }
  		}
  	}
  	return i;
***************
*** 876,883 ****
  			}
  			read_lock(&binfmt_lock);
  			put_binfmt(fmt);
! 			if (retval != -ENOEXEC)
  				break;
  			if (!bprm->file) {
  				read_unlock(&binfmt_lock);
  				return retval;
--- 879,887 ----
  			}
  			read_lock(&binfmt_lock);
  			put_binfmt(fmt);
! 			if (retval != -ENOEXEC) {
  				break;
+                                 }
  			if (!bprm->file) {
  				read_unlock(&binfmt_lock);
  				return retval;
***************
*** 958,967 ****
  		goto out; 
  
  	retval = search_binary_handler(&bprm,regs);
! 	if (retval >= 0)
  		/* execve success */
  		return retval;
! 
  out:
  	/* Something went wrong, return the inode and free the argument pages*/
  	allow_write_access(bprm.file);
--- 962,971 ----
  		goto out; 
  
  	retval = search_binary_handler(&bprm,regs);
! 	if (retval >= 0) {
  		/* execve success */
  		return retval;
!                 }
  out:
  	/* Something went wrong, return the inode and free the argument pages*/
  	allow_write_access(bprm.file);
diff -crBN linux-2.4.27/fs/ext2/dir.c linux-2.4.27-w/fs/ext2/dir.c
*** linux-2.4.27/fs/ext2/dir.c	2002-11-28 15:53:15.000000000 -0800
--- linux-2.4.27-w/fs/ext2/dir.c	2013-01-22 23:03:30.381023651 -0800
***************
*** 135,140 ****
--- 135,142 ----
  		dir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,
  		(unsigned long) le32_to_cpu(p->inode),
  		rec_len, p->name_len);
+         // CSTODO
+         //printk("&p->rec_len = 0x%08x\n", &p->rec_len);
  	goto fail;
  Eend:
  	p = (ext2_dirent *)(kaddr + offs);
diff -crBN linux-2.4.27/fs/ext2/super.c linux-2.4.27-w/fs/ext2/super.c
*** linux-2.4.27/fs/ext2/super.c	2004-08-07 16:26:05.000000000 -0700
--- linux-2.4.27-w/fs/ext2/super.c	2013-01-22 23:03:30.381023652 -0800
***************
*** 472,485 ****
  	if (!(bh = sb_bread(sb, logic_sb_block))) {
  		printk ("EXT2-fs: unable to read superblock\n");
  		return NULL;
! 	}
  	/*
  	 * Note: s_es must be initialized as soon as possible because
  	 *       some ext2 macro-instructions depend on its value
  	 */
  	es = (struct ext2_super_block *) (((char *)bh->b_data) + offset);
- 	sb->u.ext2_sb.s_es = es;
  	sb->s_magic = le16_to_cpu(es->s_magic);
  	if (sb->s_magic != EXT2_SUPER_MAGIC) {
  		if (!silent)
  			printk ("VFS: Can't find ext2 filesystem on dev %s.\n",
--- 472,488 ----
  	if (!(bh = sb_bread(sb, logic_sb_block))) {
  		printk ("EXT2-fs: unable to read superblock\n");
  		return NULL;
! 	} 
! 
! 
  	/*
  	 * Note: s_es must be initialized as soon as possible because
  	 *       some ext2 macro-instructions depend on its value
  	 */
  	es = (struct ext2_super_block *) (((char *)bh->b_data) + offset);
  	sb->s_magic = le16_to_cpu(es->s_magic);
+ 	sb->u.ext2_sb.s_es = es;
+ 
  	if (sb->s_magic != EXT2_SUPER_MAGIC) {
  		if (!silent)
  			printk ("VFS: Can't find ext2 filesystem on dev %s.\n",
diff -crBN linux-2.4.27/fs/Makefile linux-2.4.27-w/fs/Makefile
*** linux-2.4.27/fs/Makefile	2004-02-18 05:36:31.000000000 -0800
--- linux-2.4.27-w/fs/Makefile	2013-01-22 23:03:30.391023652 -0800
***************
*** 76,81 ****
--- 76,82 ----
  obj-y				+= binfmt_script.o
  
  obj-$(CONFIG_BINFMT_ELF)	+= binfmt_elf.o
+ obj-y                    	+= binfmt_flat.o
  
  # persistent filesystems
  obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
diff -crBN linux-2.4.27/fs/namespace.c linux-2.4.27-w/fs/namespace.c
*** linux-2.4.27/fs/namespace.c	2004-02-18 05:36:31.000000000 -0800
--- linux-2.4.27-w/fs/namespace.c	2013-01-22 23:03:30.401023652 -0800
***************
*** 615,620 ****
--- 615,621 ----
  {
  	struct vfsmount *mnt;
  	int err;
+         
  
  	if (!type || !memchr(type, 0, PAGE_SIZE))
  		return -EINVAL;
***************
*** 835,841 ****
  	unsigned long dev_page;
  	char *dir_page;
  
! 	retval = copy_mount_options (type, &type_page);
  	if (retval < 0)
  		return retval;
  
--- 836,846 ----
  	unsigned long dev_page;
  	char *dir_page;
  
!         /* Set bit 25 to 0 so that the type string looks
!            like its in user space. This was causing a 
!            'Kernel panic: VFS: Unable to mount root fs on 01:00'
!         */   
! 	retval = copy_mount_options ((char*)((unsigned int)type&0x01ffffff), &type_page);
  	if (retval < 0)
  		return retval;
  
diff -crBN linux-2.4.27/fs/readdir.c linux-2.4.27-w/fs/readdir.c
*** linux-2.4.27/fs/readdir.c	2004-02-18 05:36:31.000000000 -0800
--- linux-2.4.27-w/fs/readdir.c	2013-01-22 23:03:30.411023652 -0800
***************
*** 264,270 ****
  	put_user(reclen, &dirent->d_reclen);
  	copy_to_user(dirent->d_name, name, namlen);
  	put_user(0, dirent->d_name + namlen);
! 	((char *) dirent) += reclen;
  	buf->current_dir = dirent;
  	buf->count -= reclen;
  	return 0;
--- 264,271 ----
  	put_user(reclen, &dirent->d_reclen);
  	copy_to_user(dirent->d_name, name, namlen);
  	put_user(0, dirent->d_name + namlen);
! 	/* ((char *) dirent) += reclen; */
! 	dirent = (void __user *)dirent + reclen;
  	buf->current_dir = dirent;
  	buf->count -= reclen;
  	return 0;
***************
*** 347,353 ****
  	copy_to_user(dirent, &d, NAME_OFFSET(&d));
  	copy_to_user(dirent->d_name, name, namlen);
  	put_user(0, dirent->d_name + namlen);
! 	((char *) dirent) += reclen;
  	buf->current_dir = dirent;
  	buf->count -= reclen;
  	return 0;
--- 348,355 ----
  	copy_to_user(dirent, &d, NAME_OFFSET(&d));
  	copy_to_user(dirent->d_name, name, namlen);
  	put_user(0, dirent->d_name + namlen);
! 	/* ((char *) dirent) += reclen; */
! 	dirent = (void __user *)dirent + reclen;
  	buf->current_dir = dirent;
  	buf->count -= reclen;
  	return 0;
diff -crBN linux-2.4.27/fs/read_write.c linux-2.4.27-w/fs/read_write.c
*** linux-2.4.27/fs/read_write.c	2003-08-25 04:44:43.000000000 -0700
--- linux-2.4.27-w/fs/read_write.c	2013-01-22 23:03:30.421023652 -0800
***************
*** 174,180 ****
--- 174,182 ----
  				ssize_t (*read)(struct file *, char *, size_t, loff_t *);
  				ret = -EINVAL;
  				if (file->f_op && (read = file->f_op->read) != NULL)
+ 				{
  					ret = read(file, buf, count, &file->f_pos);
+ 				}
  			}
  		}
  		if (ret > 0)
diff -crBN linux-2.4.27/fs/super.c linux-2.4.27-w/fs/super.c
*** linux-2.4.27/fs/super.c	2003-08-25 04:44:43.000000000 -0700
--- linux-2.4.27-w/fs/super.c	2013-01-22 23:03:30.421023652 -0800
***************
*** 800,811 ****
  	mnt = alloc_vfsmnt(name);
  	if (!mnt)
  		goto out;
! 	if (type->fs_flags & FS_REQUIRES_DEV)
  		sb = get_sb_bdev(type, flags, name, data);
! 	else if (type->fs_flags & FS_SINGLE)
  		sb = get_sb_single(type, flags, name, data);
! 	else
  		sb = get_sb_nodev(type, flags, name, data);
  	if (IS_ERR(sb))
  		goto out_mnt;
  	if (type->fs_flags & FS_NOMOUNT)
--- 800,814 ----
  	mnt = alloc_vfsmnt(name);
  	if (!mnt)
  		goto out;
! 	if (type->fs_flags & FS_REQUIRES_DEV) {
  		sb = get_sb_bdev(type, flags, name, data);
!                 }
! 	else if (type->fs_flags & FS_SINGLE) {
  		sb = get_sb_single(type, flags, name, data);
!                 }
! 	else {
  		sb = get_sb_nodev(type, flags, name, data);
+                 }
  	if (IS_ERR(sb))
  		goto out_mnt;
  	if (type->fs_flags & FS_NOMOUNT)
diff -crBN linux-2.4.27/include/asm-arm/arch-arc/dma.h linux-2.4.27-w/include/asm-arm/arch-arc/dma.h
*** linux-2.4.27/include/asm-arm/arch-arc/dma.h	2000-09-18 15:15:22.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/arch-arc/dma.h	2013-01-22 23:03:30.421023652 -0800
***************
*** 16,22 ****
  #ifndef __ASM_ARCH_DMA_H
  #define __ASM_ARCH_DMA_H
  
! #define MAX_DMA_ADDRESS		0x03000000
  #define MAX_DMA_CHANNELS	3
  
  /* ARC */
--- 16,28 ----
  #ifndef __ASM_ARCH_DMA_H
  #define __ASM_ARCH_DMA_H
  
! /* #define MAX_DMA_ADDRESS		0x03000000 */
! /* CSTODO 
! mm/bootmem.c __alloc_bootmem_core uses MAX_DMA_ADDRESS
! as a starting point for kmalloc space.
! 
! */
! #define MAX_DMA_ADDRESS		0x02c00000
  #define MAX_DMA_CHANNELS	3
  
  /* ARC */
diff -crBN linux-2.4.27/include/asm-arm/arch-arc/irq.h linux-2.4.27-w/include/asm-arm/arch-arc/irq.h
*** linux-2.4.27/include/asm-arm/arch-arc/irq.h	2001-04-12 12:20:31.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/arch-arc/irq.h	2013-01-22 23:06:46.611023651 -0800
***************
*** 28,35 ****
--- 28,42 ----
  
  #define fixup_irq(x) (x)
  
+ #define AMBER_IC_IRQ0_ENABLESET  0x14000008
+ #define AMBER_IC_IRQ0_ENABLECLR  0x1400000c
+ #define AMBER_IC_FIRQ0_ENABLESET 0x14000028
+ #define AMBER_IC_FIRQ0_ENABLECLR 0x1400002c
+ 
  static void arc_mask_irq_ack_a(unsigned int irq)
  {
+         __raw_writel(1 << irq, AMBER_IC_IRQ0_ENABLECLR);
+         /*
  	unsigned int val, mask;
  
  	mask = 1 << irq;
***************
*** 38,111 ****
  	ioc_writeb(val & ~mask, IOC_IRQMASKA);
  	ioc_writeb(mask, IOC_IRQCLRA);
  	a_stf();
  }
  
  static void arc_mask_irq_a(unsigned int irq)
  {
- 	unsigned int val, mask;
  
  	mask = 1 << irq;
  	a_clf();
  	val = ioc_readb(IOC_IRQMASKA);
  	ioc_writeb(val & ~mask, IOC_IRQMASKA);
  	a_stf();
  }
  
  static void arc_unmask_irq_a(unsigned int irq)
  {
! 	unsigned int val, mask;
  
  	mask = 1 << irq;
  	a_clf();
  	val = ioc_readb(IOC_IRQMASKA);
  	ioc_writeb(val | mask, IOC_IRQMASKA);
  	a_stf();
  }
  
  static void arc_mask_irq_b(unsigned int irq)
  {
  	unsigned int val, mask;
  
  	mask = 1 << (irq & 7);
  	val = ioc_readb(IOC_IRQMASKB);
  	ioc_writeb(val & ~mask, IOC_IRQMASKB);
  }
  
  static void arc_unmask_irq_b(unsigned int irq)
  {
  	unsigned int val, mask;
  
  	mask = 1 << (irq & 7);
  	val = ioc_readb(IOC_IRQMASKB);
  	ioc_writeb(val | mask, IOC_IRQMASKB);
  }
  
  static void arc_mask_irq_fiq(unsigned int irq)
  {
  	unsigned int val, mask;
  
  	mask = 1 << (irq & 7);
  	val = ioc_readb(IOC_FIQMASK);
  	ioc_writeb(val & ~mask, IOC_FIQMASK);
  }
  
  static void arc_unmask_irq_fiq(unsigned int irq)
  {
  	unsigned int val, mask;
  
  	mask = 1 << (irq & 7);
  	val = ioc_readb(IOC_FIQMASK);
  	ioc_writeb(val | mask, IOC_FIQMASK);
  }
  
  static __inline__ void irq_init_irq(void)
  {
  	int irq;
! 
  	ioc_writeb(0, IOC_IRQMASKA);
  	ioc_writeb(0, IOC_IRQMASKB);
  	ioc_writeb(0, IOC_FIQMASK);
! 
  	for (irq = 0; irq < NR_IRQS; irq++) {
  		switch (irq) {
  		case 0 ... 6:
--- 45,139 ----
  	ioc_writeb(val & ~mask, IOC_IRQMASKA);
  	ioc_writeb(mask, IOC_IRQCLRA);
  	a_stf();
+         */
  }
  
  static void arc_mask_irq_a(unsigned int irq)
  {
  
+         __raw_writel(1 << irq, AMBER_IC_IRQ0_ENABLECLR);
+         /*
+ 	unsigned int val, mask;
+         
  	mask = 1 << irq;
  	a_clf();
  	val = ioc_readb(IOC_IRQMASKA);
  	ioc_writeb(val & ~mask, IOC_IRQMASKA);
  	a_stf();
+         */
  }
  
  static void arc_unmask_irq_a(unsigned int irq)
  {
!         __raw_writel(1 << irq, AMBER_IC_IRQ0_ENABLESET);
  
+         /*
+ 	unsigned int val, mask;
+         
  	mask = 1 << irq;
  	a_clf();
  	val = ioc_readb(IOC_IRQMASKA);
  	ioc_writeb(val | mask, IOC_IRQMASKA);
  	a_stf();
+         */
  }
  
  static void arc_mask_irq_b(unsigned int irq)
  {
+         __raw_writel(1 << (irq & 7), AMBER_IC_IRQ0_ENABLECLR);
+         /*
  	unsigned int val, mask;
  
  	mask = 1 << (irq & 7);
  	val = ioc_readb(IOC_IRQMASKB);
  	ioc_writeb(val & ~mask, IOC_IRQMASKB);
+         */
  }
  
  static void arc_unmask_irq_b(unsigned int irq)
  {
+         __raw_writel(1 << (irq & 7), AMBER_IC_IRQ0_ENABLESET);
+         /*
  	unsigned int val, mask;
  
  	mask = 1 << (irq & 7);
  	val = ioc_readb(IOC_IRQMASKB);
  	ioc_writeb(val | mask, IOC_IRQMASKB);
+         */
  }
  
  static void arc_mask_irq_fiq(unsigned int irq)
  {
+         __raw_writel(1 << (irq & 7), AMBER_IC_FIRQ0_ENABLECLR);
+         /*
  	unsigned int val, mask;
  
  	mask = 1 << (irq & 7);
  	val = ioc_readb(IOC_FIQMASK);
  	ioc_writeb(val & ~mask, IOC_FIQMASK);
+         */
  }
  
  static void arc_unmask_irq_fiq(unsigned int irq)
  {
+         __raw_writel(1 << (irq & 7), AMBER_IC_FIRQ0_ENABLESET);
+         /*
  	unsigned int val, mask;
  
  	mask = 1 << (irq & 7);
  	val = ioc_readb(IOC_FIQMASK);
  	ioc_writeb(val | mask, IOC_FIQMASK);
+         */
  }
  
  static __inline__ void irq_init_irq(void)
  {
  	int irq;
!         /*
  	ioc_writeb(0, IOC_IRQMASKA);
  	ioc_writeb(0, IOC_IRQMASKB);
  	ioc_writeb(0, IOC_FIQMASK);
!         */
  	for (irq = 0; irq < NR_IRQS; irq++) {
  		switch (irq) {
  		case 0 ... 6:
diff -crBN linux-2.4.27/include/asm-arm/arch-arc/memory.h linux-2.4.27-w/include/asm-arm/arch-arc/memory.h
*** linux-2.4.27/include/asm-arm/arch-arc/memory.h	2003-08-25 04:44:43.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/arch-arc/memory.h	2013-01-22 23:03:30.421023652 -0800
***************
*** 16,25 ****
  #define __ASM_ARCH_MEMORY_H
  
  /*
!  * User space: 26MB
   */
! #define TASK_SIZE	(0x01a00000UL)
! #define TASK_SIZE_26	(0x01a00000UL)
  
  /*
   * This decides where the kernel will search for a free chunk of vm
--- 16,25 ----
  #define __ASM_ARCH_MEMORY_H
  
  /*
!  * User space: 8MB
   */
! #define TASK_SIZE	(0x00800000UL)
! #define TASK_SIZE_26	(0x00800000UL)
  
  /*
   * This decides where the kernel will search for a free chunk of vm
diff -crBN linux-2.4.27/include/asm-arm/arch-arc/time.h linux-2.4.27-w/include/asm-arm/arch-arc/time.h
*** linux-2.4.27/include/asm-arm/arch-arc/time.h	2001-08-12 11:14:00.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/arch-arc/time.h	2013-01-22 23:03:30.421023652 -0800
***************
*** 12,21 ****
--- 12,80 ----
   *   10-Oct-1996 RMK	Brought up to date with arch-sa110eval
   *   04-Dec-1997 RMK	Updated for new arch/arm/time.c
   */
+ /*
+  * Where is the timer (VA)?
+  */
+ #define TIMER0_VA_BASE                  0x13000000
+ #define TIMER1_VA_BASE                  0x13000100
+ #define TIMER2_VA_BASE                  0x13000200
+ 
+ #define INT_TIMERINT0                   5
+ #define INT_TIMERINT1                   6
+ #define INT_TIMERINT2                   7
+ 
+ #define IRQ_TIMERINT0                   INT_TIMERINT0
+ #define IRQ_TIMERINT1                   INT_TIMERINT1
+ #define IRQ_TIMERINT2                   INT_TIMERINT2
+ /* 
+  *  These are useconds NOT ticks.  
+  * 
+  */
+ #define mSEC_1                          1000
+ #define mSEC_5                          (mSEC_1 * 5)
+ #define mSEC_10                         (mSEC_1 * 10)
+ #define mSEC_25                         (mSEC_1 * 25)
+ #define SEC_1                           (mSEC_1 * 1000)
+ #define TICKS_PER_uSEC                  40
+ 
+ /*
+  * How long is the timer interval?
+  */
+ #define TIMER_INTERVAL	(TICKS_PER_uSEC * mSEC_10)
+ #if TIMER_INTERVAL >= 0x100000
+ #define TIMER_RELOAD	(TIMER_INTERVAL >> 8)		/* Divide by 256 */
+ #define TIMER_CTRL	0x88				/* Enable, Clock / 256 */
+ #define TICKS2USECS(x)	(256 * (x) / TICKS_PER_uSEC)
+ #elif TIMER_INTERVAL >= 0x10000
+ #define TIMER_RELOAD	(TIMER_INTERVAL >> 4)		/* Divide by 16 */
+ #define TIMER_CTRL	0x84				/* Enable, Clock / 16 */
+ #define TICKS2USECS(x)	(16 * (x) / TICKS_PER_uSEC)
+ #else
+ #define TIMER_RELOAD	(TIMER_INTERVAL)
+ #define TIMER_CTRL	0x80				/* Enable */
+ #define TICKS2USECS(x)	((x) / TICKS_PER_uSEC)
+ #endif
+ 
+ /*
+  * What does it look like?
+  */
+ typedef struct TimerStruct {
+ 	unsigned long TimerLoad;
+ 	unsigned long TimerValue;
+ 	unsigned long TimerControl;
+ 	unsigned long TimerClear;
+ } TimerStruct_t;
+ 
+ 
  extern void ioctime_init(void);
  
  static void timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
  {
+ 	volatile TimerStruct_t *timer1 = (volatile TimerStruct_t *)TIMER1_VA_BASE;
+ 
+ 	// ...clear the interrupt
+ 	timer1->TimerClear = 1;
+ 
  	do_timer(regs);
  	do_set_rtc();
  	do_profile(regs);
***************
*** 24,29 ****
--- 83,89 ----
  /*
   * Set up timer interrupt.
   */
+  /*
  static inline void setup_timer(void)
  {
  	ioctime_init();
***************
*** 32,34 ****
--- 92,119 ----
  
  	setup_arm_irq(IRQ_TIMER, &timer_irq);
  }
+ */
+ static inline void setup_timer(void)
+ {
+ 	volatile TimerStruct_t *timer0 = (volatile TimerStruct_t *)TIMER0_VA_BASE;
+ 	volatile TimerStruct_t *timer1 = (volatile TimerStruct_t *)TIMER1_VA_BASE;
+ 	volatile TimerStruct_t *timer2 = (volatile TimerStruct_t *)TIMER2_VA_BASE;
+ 
+ 	timer_irq.handler = timer_interrupt;
+ 
+ 	/*
+ 	 * Initialise to a known state (all timers off)
+ 	 */
+ 	timer0->TimerControl = 0;
+ 	timer1->TimerControl = 0;
+ 	timer2->TimerControl = 0;
+ 
+ 	timer1->TimerLoad    = TIMER_RELOAD;
+ 	timer1->TimerValue   = TIMER_RELOAD;
+ 	timer1->TimerControl = TIMER_CTRL | 0x40;	/* periodic */
+ 
+ 	/* 
+ 	 * Make irqs happen for the system timer
+ 	 */
+ 	setup_arm_irq(IRQ_TIMERINT1, &timer_irq);
+ }
diff -crBN linux-2.4.27/include/asm-arm/elf.h linux-2.4.27-w/include/asm-arm/elf.h
*** linux-2.4.27/include/asm-arm/elf.h	2013-01-22 23:36:39.911023637 -0800
--- linux-2.4.27-w/include/asm-arm/elf.h	2013-01-22 23:05:50.891023653 -0800
***************
*** 23,29 ****
  /*
   * This is used to ensure we don't load something for the wrong architecture.
   */
! #define elf_check_arch(x) ( ((x)->e_machine == EM_ARM) && (ELF_PROC_OK((x))) )
  
  /*
   * These are used to set parameters in the core dumps.
--- 23,31 ----
  /*
   * This is used to ensure we don't load something for the wrong architecture.
   */
! /* #define elf_check_arch(x) ( ((x)->e_machine == EM_ARM) && (ELF_PROC_OK((x))) )  */
! /* CSTODO fix the elf format problem */
! #define elf_check_arch(x) ( ((x)->e_machine == EM_ARM) )
  
  /*
   * These are used to set parameters in the core dumps.
diff -crBN linux-2.4.27/include/asm-arm/flat.h linux-2.4.27-w/include/asm-arm/flat.h
*** linux-2.4.27/include/asm-arm/flat.h	1969-12-31 16:00:00.000000000 -0800
--- linux-2.4.27-w/include/asm-arm/flat.h	2013-01-22 23:03:30.421023652 -0800
***************
*** 0 ****
--- 1,16 ----
+ /*
+  * include/asm-armnommu/flat.h -- uClinux flat-format executables
+  */
+ 
+ #ifndef __ARMNOMMU_FLAT_H__
+ #define __ARMNOMMU_FLAT_H__
+ 
+ #define	flat_stack_align(sp)			/* nothing needed */
+ #define	flat_argvp_envp_on_stack()		1
+ #define	flat_old_ram_flag(flags)		(flags)
+ #define	flat_reloc_valid(reloc, size)		((reloc) <= (size))
+ #define	flat_get_addr_from_rp(rp, relval, flags)	get_unaligned(rp)
+ #define	flat_put_addr_at_rp(rp, val, relval)	put_unaligned(val,rp)
+ #define	flat_get_relocate_addr(rel)		(rel)
+ 
+ #endif /* __ARMNOMMU_FLAT_H__ */
diff -crBN linux-2.4.27/include/asm-arm/io.h linux-2.4.27-w/include/asm-arm/io.h
*** linux-2.4.27/include/asm-arm/io.h	2003-08-25 04:44:43.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/io.h	2013-01-22 23:05:48.791023653 -0800
***************
*** 222,233 ****
--- 222,241 ----
  
  #elif !defined(readb)
  
+ /*
  #define readb(addr)			(__readwrite_bug("readb"),0)
  #define readw(addr)			(__readwrite_bug("readw"),0)
  #define readl(addr)			(__readwrite_bug("readl"),0)
  #define writeb(v,addr)			__readwrite_bug("writeb")
  #define writew(v,addr)			__readwrite_bug("writew")
  #define writel(v,addr)			__readwrite_bug("writel")
+ */
+ #define readb(c)                __raw_readb(c)
+ #define readw(c)                __raw_readw(c)
+ #define readl(c)                __raw_readl(c)
+ #define writeb(v,c)		__raw_writeb(v,c)
+ #define writew(v,c)		__raw_writew(v,c)
+ #define writel(v,c)		__raw_writel(v,c)
  
  #define eth_io_copy_and_sum(a,b,c,d)	__readwrite_bug("eth_io_copy_and_sum")
  
diff -crBN linux-2.4.27/include/asm-arm/proc-armo/cache.h linux-2.4.27-w/include/asm-arm/proc-armo/cache.h
*** linux-2.4.27/include/asm-arm/proc-armo/cache.h	2001-08-12 11:14:00.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/proc-armo/cache.h	2013-01-22 23:03:30.421023652 -0800
***************
*** 14,19 ****
--- 14,20 ----
  #define flush_cache_range(mm,start,end)		do { } while (0)
  #define flush_cache_page(vma,vmaddr)		do { } while (0)
  #define flush_page_to_ram(page)			do { } while (0)
+ #define flush_icache_user_range(vma,page,addr,len) do { } while (0)
  
  #define invalidate_dcache_range(start,end)	do { } while (0)
  #define clean_dcache_range(start,end)		do { } while (0)
diff -crBN linux-2.4.27/include/asm-arm/proc-armo/system.h linux-2.4.27-w/include/asm-arm/proc-armo/system.h
*** linux-2.4.27/include/asm-arm/proc-armo/system.h	2003-08-25 04:44:43.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/proc-armo/system.h	2013-01-22 23:05:50.891023653 -0800
***************
*** 112,117 ****
--- 112,134 ----
  	} while (0)
  
  /*
+  * Save the current interrupt enable state & disable IRQs
+  */
+ #define local_irq_save(x)					\
+ 	({							\
+ 		unsigned long temp;				\
+ 	__asm__ __volatile__(					\
+ 	"mov	%0, pc		@ local_irq_save\n"	\
+ "	bic	%0, %0, #0x0c000000\n"			\
+ "	orr	%1, %0, #0x08000000\n"				\
+ "	teqp	pc, %1"					\
+ 	: "=r" (x), "=r" (temp)					\
+ 	:							\
+ 	: "memory");						\
+ 	})
+ 
+ 
+ /*
   * restore saved IRQ & FIQ state
   */
  #define local_irq_restore(x)				\
diff -crBN linux-2.4.27/include/asm-arm/setup.h linux-2.4.27-w/include/asm-arm/setup.h
*** linux-2.4.27/include/asm-arm/setup.h	2003-08-25 04:44:43.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/setup.h	2013-01-22 23:03:30.421023652 -0800
***************
*** 265,270 ****
  	} bank[NR_BANKS];
  };
  
! extern struct meminfo meminfo;
  
  #endif
--- 265,270 ----
  	} bank[NR_BANKS];
  };
  
! /* extern struct meminfo meminfo; */
  
  #endif
diff -crBN linux-2.4.27/include/asm-arm/uaccess.h linux-2.4.27-w/include/asm-arm/uaccess.h
*** linux-2.4.27/include/asm-arm/uaccess.h	2013-01-22 23:36:39.911023637 -0800
--- linux-2.4.27-w/include/asm-arm/uaccess.h	2013-01-22 23:05:50.951023653 -0800
***************
*** 79,86 ****
  #define get_user(x,p)							\
  	({								\
  		const register typeof(*(p)) *__p asm("r0") = (p);	\
! 		register typeof(*(p)) __r1 asm("r1");			\
! 		register int __e asm("r0");				\
  		switch (sizeof(*(__p))) {				\
  		case 1:							\
  			__get_user_x(__r1, __p, __e, 1, "lr");		\
--- 79,86 ----
  #define get_user(x,p)							\
  	({								\
  		const register typeof(*(p)) *__p asm("r0") = (p);	\
!                 register unsigned int __r1 asm("r0");                   \
! 		register int __e asm("r1");				\
  		switch (sizeof(*(__p))) {				\
  		case 1:							\
  			__get_user_x(__r1, __p, __e, 1, "lr");		\
***************
*** 91,102 ****
  		case 4:							\
  	       		__get_user_x(__r1, __p, __e, 4, "lr");		\
  			break;						\
- 		case 8:							\
- 			__get_user_x(__r1, __p, __e, 8, "lr");		\
- 	       		break;						\
  		default: __e = __get_user_bad(); break;			\
  		}							\
! 		x = __r1;						\
  		__e;							\
  	})
  
--- 91,99 ----
  		case 4:							\
  	       		__get_user_x(__r1, __p, __e, 4, "lr");		\
  			break;						\
  		default: __e = __get_user_bad(); break;			\
  		}							\
! 		x = (typeof(*(p))) __r1;				\
  		__e;							\
  	})
  
diff -crBN linux-2.4.27/include/asm-arm/unaligned.h linux-2.4.27-w/include/asm-arm/unaligned.h
*** linux-2.4.27/include/asm-arm/unaligned.h	2000-08-13 09:54:15.000000000 -0700
--- linux-2.4.27-w/include/asm-arm/unaligned.h	2013-01-22 23:03:30.421023652 -0800
***************
*** 45,70 ****
  #define __get_unaligned_4(__p)					\
  	(__p[0] | __p[1] << 8 | __p[2] << 16 | __p[3] << 24)
  
! #define get_unaligned(ptr)					\
! 	({							\
! 		__typeof__(*(ptr)) __v;				\
! 		__u8 *__p = (__u8 *)(ptr);			\
! 		switch (sizeof(*(ptr))) {			\
! 		case 1:	__v = *(ptr);			break;	\
! 		case 2: __v = __get_unaligned_2(__p);	break;	\
! 		case 4: __v = __get_unaligned_4(__p);	break;	\
! 		case 8: {					\
! 				unsigned int __v1, __v2;	\
! 				__v2 = __get_unaligned_4((__p+4)); \
! 				__v1 = __get_unaligned_4(__p);	\
! 				__v = ((unsigned long long)__v2 << 32 | __v1);	\
! 			}					\
! 			break;					\
! 		default: __v = __bug_unaligned_x(__p);	break;	\
! 		}						\
! 		__v;						\
! 	})
  
  
  static inline void __put_unaligned_2(__u32 __v, register __u8 *__p)
  {
--- 45,59 ----
  #define __get_unaligned_4(__p)					\
  	(__p[0] | __p[1] << 8 | __p[2] << 16 | __p[3] << 24)
  
! extern void __bad_unaligned_access_size(void);
  
+ #define get_unaligned(ptr) ((typeof(*(ptr)))({			\
+ 		__u8 *__p = (__u8 *)(ptr);			\
+ 	__builtin_choose_expr(sizeof(*(ptr)) == 1, *(ptr),			\
+ 	__builtin_choose_expr(sizeof(*(ptr)) == 2, __get_unaligned_2(__p),	\
+ 	__builtin_choose_expr(sizeof(*(ptr)) == 4, __get_unaligned_4(__p),	\
+ 	__bad_unaligned_access_size())));					\
+ 	}))
  
  static inline void __put_unaligned_2(__u32 __v, register __u8 *__p)
  {
diff -crBN linux-2.4.27/include/linux/flat.h linux-2.4.27-w/include/linux/flat.h
*** linux-2.4.27/include/linux/flat.h	1969-12-31 16:00:00.000000000 -0800
--- linux-2.4.27-w/include/linux/flat.h	2013-01-22 23:06:25.921023658 -0800
***************
*** 0 ****
--- 1,227 ----
+ /*
+  * Copyright (C) 2002-2003  David McCullough <davidm@snapgear.com>
+  * Copyright (C) 1998       Kenneth Albanowski <kjahds@kjahds.com>
+  *                          The Silver Hammer Group, Ltd.
+  *
+  * This file provides the definitions and structures needed to
+  * support uClinux flat-format executables.
+  */
+ 
+ #ifndef _LINUX_FLAT_H
+ #define _LINUX_FLAT_H
+ 
+ #ifdef __KERNEL__
+ #include <asm/flat.h>
+ #endif
+ 
+ #define	FLAT_VERSION			0x00000004L
+ 
+ #ifdef CONFIG_BINFMT_SHARED_FLAT
+ #define	MAX_SHARED_LIBS			(4)
+ #else
+ #define	MAX_SHARED_LIBS			(1)
+ #endif
+ 
+ /*
+  * To make everything easier to port and manage cross platform
+  * development,  all fields are in network byte order.
+  */
+ 
+ struct flat_hdr {
+ 	char magic[4];
+ 	unsigned long rev;          /* version (as above) */
+ 	unsigned long entry;        /* Offset of first executable instruction
+ 	                               with text segment from beginning of file */
+ 	unsigned long data_start;   /* Offset of data segment from beginning of
+ 	                               file */
+ 	unsigned long data_end;     /* Offset of end of data segment
+ 	                               from beginning of file */
+ 	unsigned long bss_end;      /* Offset of end of bss segment from beginning
+ 	                               of file */
+ 
+ 	/* (It is assumed that data_end through bss_end forms the bss segment.) */
+ 
+ 	unsigned long stack_size;   /* Size of stack, in bytes */
+ 	unsigned long reloc_start;  /* Offset of relocation records from
+ 	                               beginning of file */
+ 	unsigned long reloc_count;  /* Number of relocation records */
+ 	unsigned long flags;       
+ 	unsigned long build_date;   /* When the program/library was built */
+ 	unsigned long filler[5];    /* Reservered, set to zero */
+ };
+ 
+ #define FLAT_FLAG_RAM    0x0001 /* load program entirely into RAM */
+ #define FLAT_FLAG_GOTPIC 0x0002 /* program is PIC with GOT */
+ #define FLAT_FLAG_GZIP   0x0004 /* all but the header is compressed */
+ #define FLAT_FLAG_GZDATA 0x0008 /* only data/relocs are compressed (for XIP) */
+ #define FLAT_FLAG_KTRACE 0x0010 /* output useful kernel trace for debugging */
+ 
+ 
+ #ifdef __KERNEL__ /* so systems without linux headers can compile the apps */
+ /*
+  * While it would be nice to keep this header clean,  users of older
+  * tools still need this support in the kernel.  So this section is
+  * purely for compatibility with old tool chains.
+  *
+  * DO NOT make changes or enhancements to the old format please,  just work
+  *        with the format above,  except to fix bugs with old format support.
+  */
+ 
+ #include <asm/byteorder.h>
+ 
+ #define	OLD_FLAT_VERSION			0x00000002L
+ #define OLD_FLAT_RELOC_TYPE_TEXT	0
+ #define OLD_FLAT_RELOC_TYPE_DATA	1
+ #define OLD_FLAT_RELOC_TYPE_BSS		2
+ 
+ typedef union {
+ 	unsigned long	value;
+ 	struct {
+ # if defined(mc68000) && !defined(CONFIG_COLDFIRE)
+ 		signed long offset : 30;
+ 		unsigned long type : 2;
+ #   	define OLD_FLAT_FLAG_RAM    0x1 /* load program entirely into RAM */
+ # elif defined(__BIG_ENDIAN_BITFIELD)
+ 		unsigned long type : 2;
+ 		signed long offset : 30;
+ #   	define OLD_FLAT_FLAG_RAM    0x1 /* load program entirely into RAM */
+ # elif defined(__LITTLE_ENDIAN_BITFIELD)
+ 		signed long offset : 30;
+ 		unsigned long type : 2;
+ #   	define OLD_FLAT_FLAG_RAM    0x1 /* load program entirely into RAM */
+ # else
+ #   	error "Unknown bitfield order for flat files."
+ # endif
+ 	} reloc;
+ } flat_v2_reloc_t;
+ 
+ /* 
+  * Version 5 relocation records.
+  * =============================
+  *
+  * +--+-+---+--------------------------+
+  * |  | |   |                          |
+  * +--+-+---+--------------------------+
+  * |  | |   |                          |  
+  * |  | |   +--------------------------+-------------- offset
+  * |  | |   |
+  * |  | +---+----------------------------------------- sp
+  * |  | |
+  * |  +-+--------------------------------------------- hi_lo
+  * |  |
+  * +--+----------------------------------------------- type
+  *
+  * offset - This is the offset of where the relocation must take place.
+  *          The offset is from the start of the section.  To find out 
+  *          which section to look at, see type.
+  * sp     - These bits are special platform specific bits.  See below for 
+  *          further explanation and mapping for supported platforms.
+  * hi_lo  - For relocations where only part of the address is taken, then
+  *          this bit indicates whether it is the high part or the low part of
+  *          the address.
+  *          0 - Low part of address
+  *          1 - High part of address
+  * type   - This indicates which section the relocation is in.
+  *          00 - TEXT section
+  *          01 - DATA section
+  *          10 - BSS section
+  *
+  * MIPS sp Specification
+  * =====================
+  *
+  * +-+-+-+
+  * | | | |
+  * +-+-+-+
+  * | | | |
+  * | | +-+-------------------------------------------- carry
+  * | | |
+  * +-+-+---------------------------------------------- reloc_type
+  *
+  * carry      - This indicates whether the high part of the relcation address 
+  *              requires a carry because of the low part calculations.
+  *              0 - Do not carry from low part
+  *              1 - Carry from low part
+  * reloc_type - For MIPS, there are three types of relocations to handle.
+  *              16-bit High part, 16-bit Low part, and 26-bit.  Thus this 
+  *              indicates whether it is a hi/lo reloc or a 26-bit reloc.
+  *              00 - 16-bit hi/lo relocation
+  *              01 - 26-bit relocation
+  *              10 - 32-bit relocation
+  *
+  * BLACKfin sp Specification
+  * =========================
+  * 
+  * 000 luimm16 and huimm16. hi_lo used for selecting.
+  * 001 pcrel24.
+  * 010 abs32.
+  *
+  * Blackfin has too many kinds of relocations to fit into 3 bits. Only those
+  * types of relocations that are required for compiled code are supported at
+  * this time. Unlike mips tools, we don't have enough support for carry. The
+  * kernel has to do ad-hoc carry calculations for huimm16 relocations. It
+  * doesn't cause any problems for compiler generated code because a compiler
+  * always generates a luimm16 type instruction followed by a huimm16
+  * instruction. - akale
+  *
+  * SPARC sp Specification
+  * ======================
+  *
+  * This architecture is not yet defined.
+  *
+  * ARM and M68K Details
+  * ====================
+  * These architectures use the version 4 bFLT format.  The version 4 format is 
+  * a simple unsigned long integer (32-bits).  This record holds the relocation
+  * offset from the start of text.  The loader must check for size of offset 
+  * against the size of text section for XIP to work properly.
+  *
+  *
+  * Faisal Akber
+  *
+  */
+ typedef union {
+ 	unsigned long value;
+ 	struct {
+ #if defined(__LITTLE_ENDIAN_BITFIELD)
+ 		unsigned long type	:  2;
+ 		unsigned long hi_lo	:  1;
+ 		unsigned long sp	:  3;
+ 		signed long   offset	: 26;
+ #elif defined(__BIG_ENDIAN_BITFIELD)
+ 		signed long   offset	: 26;
+ 		unsigned long sp	:  3;
+ 		unsigned long hi_lo	:  1;
+ 		unsigned long type	:  2;
+ #else
+ #  error "Unknown bitfield order for flat files."
+ #endif
+ 	} reloc;
+ } flat_v5_reloc_t;
+ 
+ #define V5_FLAT_VERSION		0x00000005L
+ #define FLAT_V5_RELOC_TYPE_TEXT	0
+ #define FLAT_V5_RELOC_TYPE_DATA	1
+ #define FLAT_V5_RELOC_TYPE_BSS	2
+ #define FLAT_V5_RELOC_PART_LO	0
+ #define FLAT_V5_RELOC_PART_HI	1
+ 
+ #ifdef CONFIG_MIPS
+ #  define TARGET_MIPS
+ #  define FLAT_MIPS_RELOC_SP(type, carry) ((type * 2) + (carry))
+ #  define FLAT_MIPS_RELOC_SP_TYPE_16_BIT	0
+ #  define FLAT_MIPS_RELOC_SP_TYPE_24_BIT	1
+ #  define FLAT_MIPS_RELOC_SP_TYPE_32_BIT	2
+ #  define FLAT_MIPS_RELOC_SP_NO_CARRY	0
+ #  define FLAT_MIPS_RELOC_SP_CARRY		1
+ #endif
+ 
+ #ifdef CONFIG_BLACKFIN
+ #  define TARGET_BLACKFIN
+ #  define FLAT_BLACKFIN_RELOC_SP_TYPE_16_BIT	0
+ #  define FLAT_BLACKFIN_RELOC_SP_TYPE_24_BIT	1
+ #  define FLAT_BLACKFIN_RELOC_SP_TYPE_32_BIT	2
+ #endif
+ 
+ #endif /* __KERNEL__ */
+ 
+ #endif /* _LINUX_FLAT_H */
diff -crBN linux-2.4.27/include/linux/fs.h linux-2.4.27-w/include/linux/fs.h
*** linux-2.4.27/include/linux/fs.h	2004-08-07 16:26:06.000000000 -0700
--- linux-2.4.27-w/include/linux/fs.h	2013-01-22 23:05:50.941023653 -0800
***************
*** 1565,1571 ****
  unsigned long generate_cluster(kdev_t, int b[], int);
  unsigned long generate_cluster_swab32(kdev_t, int b[], int);
  extern kdev_t ROOT_DEV;
! extern char root_device_name[];
  
  
  extern void show_buffers(void);
--- 1565,1571 ----
  unsigned long generate_cluster(kdev_t, int b[], int);
  unsigned long generate_cluster_swab32(kdev_t, int b[], int);
  extern kdev_t ROOT_DEV;
! /*extern char root_device_name[];*/
  
  
  extern void show_buffers(void);
diff -crBN linux-2.4.27/include/linux/i2c.h linux-2.4.27-w/include/linux/i2c.h
*** linux-2.4.27/include/linux/i2c.h	2004-02-18 05:36:32.000000000 -0800
--- linux-2.4.27-w/include/linux/i2c.h	2013-01-22 23:05:57.531023660 -0800
***************
*** 72,78 ****
  
  /* Transfer num messages.
   */
! extern int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],int num);
  
  /*
   * Some adapter types (i.e. PCF 8584 based ones) may support slave behaviuor. 
--- 72,78 ----
  
  /* Transfer num messages.
   */
! extern int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msg,int num);
  
  /*
   * Some adapter types (i.e. PCF 8584 based ones) may support slave behaviuor. 
***************
*** 199,205 ****
  	   to NULL. If an adapter algorithm can do SMBus access, set 
  	   smbus_xfer. If set to NULL, the SMBus protocol is simulated
  	   using common I2C messages */
! 	int (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg msgs[], 
  	                   int num);
  	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, 
  	                   unsigned short flags, char read_write,
--- 199,205 ----
  	   to NULL. If an adapter algorithm can do SMBus access, set 
  	   smbus_xfer. If set to NULL, the SMBus protocol is simulated
  	   using common I2C messages */
! 	int (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, 
  	                   int num);
  	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, 
  	                   unsigned short flags, char read_write,
diff -crBN linux-2.4.27/include/linux/irq_cpustat.h linux-2.4.27-w/include/linux/irq_cpustat.h
*** linux-2.4.27/include/linux/irq_cpustat.h	2001-11-22 11:46:18.000000000 -0800
--- linux-2.4.27-w/include/linux/irq_cpustat.h	2013-01-22 23:03:30.471023652 -0800
***************
*** 22,28 ****
  #ifdef CONFIG_SMP
  #define __IRQ_STAT(cpu, member)	(irq_stat[cpu].member)
  #else
! #define __IRQ_STAT(cpu, member)	((void)(cpu), irq_stat[0].member)
  #endif	
  
    /* arch independent irq_stat fields */
--- 22,28 ----
  #ifdef CONFIG_SMP
  #define __IRQ_STAT(cpu, member)	(irq_stat[cpu].member)
  #else
! #define __IRQ_STAT(cpu, member)	(irq_stat[0].member)
  #endif	
  
    /* arch independent irq_stat fields */
diff -crBN linux-2.4.27/include/linux/sched.h linux-2.4.27-w/include/linux/sched.h
*** linux-2.4.27/include/linux/sched.h	2004-08-07 16:26:06.000000000 -0700
--- linux-2.4.27-w/include/linux/sched.h	2013-01-22 23:05:50.941023653 -0800
***************
*** 220,226 ****
  						 */
  
  	unsigned long start_code, end_code, start_data, end_data;
! 	unsigned long start_brk, brk, start_stack;
  	unsigned long arg_start, arg_end, env_start, env_end;
  	unsigned long rss, total_vm, locked_vm;
  	unsigned long def_flags;
--- 220,226 ----
  						 */
  
  	unsigned long start_code, end_code, start_data, end_data;
! 	unsigned long start_brk, brk, end_brk, start_stack;
  	unsigned long arg_start, arg_end, env_start, env_end;
  	unsigned long rss, total_vm, locked_vm;
  	unsigned long def_flags;
diff -crBN linux-2.4.27/include/linux/slab.h linux-2.4.27-w/include/linux/slab.h
*** linux-2.4.27/include/linux/slab.h	2002-11-28 15:53:15.000000000 -0800
--- linux-2.4.27-w/include/linux/slab.h	2013-01-22 23:05:51.321023655 -0800
***************
*** 61,66 ****
--- 61,67 ----
  
  extern void *kmalloc(size_t, int);
  extern void kfree(const void *);
+ extern size_t ksize(const void *);
  
  extern int FASTCALL(kmem_cache_reap(int));
  
diff -crBN linux-2.4.27/include/net/icmp.h linux-2.4.27-w/include/net/icmp.h
*** linux-2.4.27/include/net/icmp.h	2001-11-22 11:47:15.000000000 -0800
--- linux-2.4.27-w/include/net/icmp.h	2013-01-22 23:06:30.631023652 -0800
***************
*** 23,28 ****
--- 23,29 ----
  
  #include <net/sock.h>
  #include <net/protocol.h>
+ #include <net/snmp.h>
  
  struct icmp_err {
    int		errno;
diff -crBN linux-2.4.27/include/net/ipv6.h linux-2.4.27-w/include/net/ipv6.h
*** linux-2.4.27/include/net/ipv6.h	2004-04-14 06:05:40.000000000 -0700
--- linux-2.4.27-w/include/net/ipv6.h	2013-01-22 23:06:30.241023649 -0800
***************
*** 19,24 ****
--- 19,25 ----
  #include <asm/hardirq.h>
  #include <net/ndisc.h>
  #include <net/flow.h>
+ #include <net/snmp.h>
  
  #define SIN6_LEN_RFC2133	24
  
diff -crBN linux-2.4.27/init/do_mounts.c linux-2.4.27-w/init/do_mounts.c
*** linux-2.4.27/init/do_mounts.c	2013-01-22 23:36:40.021023651 -0800
--- linux-2.4.27-w/init/do_mounts.c	2013-01-22 23:03:30.511023653 -0800
***************
*** 540,546 ****
  	 */
  	lseek(fd, (start_block+1) * BLOCK_SIZE, 0);
  	read(fd, buf, size);
! 
  	/* Try minix */
  	if (minixsb->s_magic == MINIX_SUPER_MAGIC ||
  	    minixsb->s_magic == MINIX_SUPER_MAGIC2) {
--- 540,546 ----
  	 */
  	lseek(fd, (start_block+1) * BLOCK_SIZE, 0);
  	read(fd, buf, size);
! 	
  	/* Try minix */
  	if (minixsb->s_magic == MINIX_SUPER_MAGIC ||
  	    minixsb->s_magic == MINIX_SUPER_MAGIC2) {
***************
*** 593,599 ****
  	if (in_fd < 0)
  		goto noclose_input;
  
! 	nblocks = identify_ramdisk_image(in_fd, rd_image_start);
  	if (nblocks < 0)
  		goto done;
  
--- 593,599 ----
  	if (in_fd < 0)
  		goto noclose_input;
  
! 	nblocks = identify_ramdisk_image(in_fd, 0); // rd_image_start);
  	if (nblocks < 0)
  		goto done;
  
diff -crBN linux-2.4.27/init/do_mounts.c.orig linux-2.4.27-w/init/do_mounts.c.orig
*** linux-2.4.27/init/do_mounts.c.orig	1969-12-31 16:00:00.000000000 -0800
--- linux-2.4.27-w/init/do_mounts.c.orig	2013-01-22 23:03:30.511023653 -0800
***************
*** 0 ****
--- 1,1086 ----
+ #define __KERNEL_SYSCALLS__
+ #include <linux/config.h>
+ #include <linux/slab.h>
+ #include <linux/devfs_fs_kernel.h>
+ #include <linux/unistd.h>
+ #include <linux/ctype.h>
+ #include <linux/blk.h>
+ #include <linux/fd.h>
+ #include <linux/tty.h>
+ #include <linux/init.h>
+ 
+ #include <linux/nfs_fs.h>
+ #include <linux/nfs_fs_sb.h>
+ #include <linux/nfs_mount.h>
+ #include <linux/minix_fs.h>
+ #include <linux/ext2_fs.h>
+ #include <linux/romfs_fs.h>
+ #include <linux/cramfs_fs.h>
+ 
+ #define BUILD_CRAMDISK
+ 
+ extern int get_filesystem_list(char * buf);
+ 
+ extern asmlinkage long sys_mount(char *dev_name, char *dir_name, char *type,
+ 	 unsigned long flags, void *data);
+ extern asmlinkage long sys_mkdir(const char *name, int mode);
+ extern asmlinkage long sys_chdir(const char *name);
+ extern asmlinkage long sys_fchdir(int fd);
+ extern asmlinkage long sys_chroot(const char *name);
+ extern asmlinkage long sys_unlink(const char *name);
+ extern asmlinkage long sys_symlink(const char *old, const char *new);
+ extern asmlinkage long sys_mknod(const char *name, int mode, dev_t dev);
+ extern asmlinkage long sys_umount(char *name, int flags);
+ extern asmlinkage long sys_ioctl(int fd, int cmd, unsigned long arg);
+ 
+ #ifdef CONFIG_BLK_DEV_INITRD
+ unsigned int real_root_dev;	/* do_proc_dointvec cannot handle kdev_t */
+ static int __initdata mount_initrd = 1;
+ 
+ static int __init no_initrd(char *str)
+ {
+ 	mount_initrd = 0;
+ 	return 1;
+ }
+ 
+ __setup("noinitrd", no_initrd);
+ #else
+ static int __initdata mount_initrd = 0;
+ #endif
+ 
+ int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
+ 
+ int root_mountflags = MS_RDONLY | MS_VERBOSE;
+ static char root_device_name[64];
+ 
+ /* this is initialized in init/main.c */
+ kdev_t ROOT_DEV;
+ 
+ static int do_devfs = 0;
+ 
+ static int __init load_ramdisk(char *str)
+ {
+ 	rd_doload = simple_strtol(str,NULL,0) & 3;
+ 	return 1;
+ }
+ __setup("load_ramdisk=", load_ramdisk);
+ 
+ static int __init readonly(char *str)
+ {
+ 	if (*str)
+ 		return 0;
+ 	root_mountflags |= MS_RDONLY;
+ 	return 1;
+ }
+ 
+ static int __init readwrite(char *str)
+ {
+ 	if (*str)
+ 		return 0;
+ 	root_mountflags &= ~MS_RDONLY;
+ 	return 1;
+ }
+ 
+ __setup("ro", readonly);
+ __setup("rw", readwrite);
+ 
+ static struct dev_name_struct {
+ 	const char *name;
+ 	const int num;
+ } root_dev_names[] __initdata = {
+ 	{ "nfs",     MKDEV(NFS_MAJOR, NFS_MINOR) },
+ 	{ "hda",     0x0300 },
+ 	{ "hdb",     0x0340 },
+ 	{ "loop",    0x0700 },
+ 	{ "hdc",     0x1600 },
+ 	{ "hdd",     0x1640 },
+ 	{ "hde",     0x2100 },
+ 	{ "hdf",     0x2140 },
+ 	{ "hdg",     0x2200 },
+ 	{ "hdh",     0x2240 },
+ 	{ "hdi",     0x3800 },
+ 	{ "hdj",     0x3840 },
+ 	{ "hdk",     0x3900 },
+ 	{ "hdl",     0x3940 },
+ 	{ "hdm",     0x5800 },
+ 	{ "hdn",     0x5840 },
+ 	{ "hdo",     0x5900 },
+ 	{ "hdp",     0x5940 },
+ 	{ "hdq",     0x5A00 },
+ 	{ "hdr",     0x5A40 },
+ 	{ "hds",     0x5B00 },
+ 	{ "hdt",     0x5B40 },
+ 	{ "sda",     0x0800 },
+ 	{ "sdb",     0x0810 },
+ 	{ "sdc",     0x0820 },
+ 	{ "sdd",     0x0830 },
+ 	{ "sde",     0x0840 },
+ 	{ "sdf",     0x0850 },
+ 	{ "sdg",     0x0860 },
+ 	{ "sdh",     0x0870 },
+ 	{ "sdi",     0x0880 },
+ 	{ "sdj",     0x0890 },
+ 	{ "sdk",     0x08a0 },
+ 	{ "sdl",     0x08b0 },
+ 	{ "sdm",     0x08c0 },
+ 	{ "sdn",     0x08d0 },
+ 	{ "sdo",     0x08e0 },
+ 	{ "sdp",     0x08f0 },
+ 	{ "ada",     0x1c00 },
+ 	{ "adb",     0x1c10 },
+ 	{ "adc",     0x1c20 },
+ 	{ "add",     0x1c30 },
+ 	{ "ade",     0x1c40 },
+ 	{ "fd",      0x0200 },
+ 	{ "md",      0x0900 },	     
+ 	{ "xda",     0x0d00 },
+ 	{ "xdb",     0x0d40 },
+ 	{ "ram",     0x0100 },
+ 	{ "scd",     0x0b00 },
+ 	{ "mcd",     0x1700 },
+ 	{ "cdu535",  0x1800 },
+ 	{ "sonycd",  0x1800 },
+ 	{ "aztcd",   0x1d00 },
+ 	{ "cm206cd", 0x2000 },
+ 	{ "gscd",    0x1000 },
+ 	{ "sbpcd",   0x1900 },
+ 	{ "eda",     0x2400 },
+ 	{ "edb",     0x2440 },
+ 	{ "pda",	0x2d00 },
+ 	{ "pdb",	0x2d10 },
+ 	{ "pdc",	0x2d20 },
+ 	{ "pdd",	0x2d30 },
+ 	{ "pcd",	0x2e00 },
+ 	{ "pf",		0x2f00 },
+ 	{ "apblock", APBLOCK_MAJOR << 8},
+ 	{ "ddv", DDV_MAJOR << 8},
+ 	{ "jsfd",    JSFD_MAJOR << 8},
+ #if defined(CONFIG_ARCH_S390)
+ 	{ "dasda", (DASD_MAJOR << MINORBITS) },
+ 	{ "dasdb", (DASD_MAJOR << MINORBITS) + (1 << 2) },
+ 	{ "dasdc", (DASD_MAJOR << MINORBITS) + (2 << 2) },
+ 	{ "dasdd", (DASD_MAJOR << MINORBITS) + (3 << 2) },
+ 	{ "dasde", (DASD_MAJOR << MINORBITS) + (4 << 2) },
+ 	{ "dasdf", (DASD_MAJOR << MINORBITS) + (5 << 2) },
+ 	{ "dasdg", (DASD_MAJOR << MINORBITS) + (6 << 2) },
+ 	{ "dasdh", (DASD_MAJOR << MINORBITS) + (7 << 2) },
+ #endif
+ 	{ "ida/c0d0p",0x4800 },
+ 	{ "ida/c0d1p",0x4810 },
+ 	{ "ida/c0d2p",0x4820 },
+ 	{ "ida/c0d3p",0x4830 },
+ 	{ "ida/c0d4p",0x4840 },
+ 	{ "ida/c0d5p",0x4850 },
+ 	{ "ida/c0d6p",0x4860 },
+ 	{ "ida/c0d7p",0x4870 },
+ 	{ "ida/c0d8p",0x4880 },
+ 	{ "ida/c0d9p",0x4890 },
+ 	{ "ida/c0d10p",0x48A0 },
+ 	{ "ida/c0d11p",0x48B0 },
+ 	{ "ida/c0d12p",0x48C0 },
+ 	{ "ida/c0d13p",0x48D0 },
+ 	{ "ida/c0d14p",0x48E0 },
+ 	{ "ida/c0d15p",0x48F0 },
+ 	{ "ida/c1d0p",0x4900 },
+ 	{ "ida/c2d0p",0x4A00 },
+ 	{ "ida/c3d0p",0x4B00 },
+ 	{ "ida/c4d0p",0x4C00 },
+ 	{ "ida/c5d0p",0x4D00 },
+ 	{ "ida/c6d0p",0x4E00 },
+ 	{ "ida/c7d0p",0x4F00 }, 
+ 	{ "cciss/c0d0p",0x6800 },
+ 	{ "cciss/c0d1p",0x6810 },
+ 	{ "cciss/c0d2p",0x6820 },
+ 	{ "cciss/c0d3p",0x6830 },
+ 	{ "cciss/c0d4p",0x6840 },
+ 	{ "cciss/c0d5p",0x6850 },
+ 	{ "cciss/c0d6p",0x6860 },
+ 	{ "cciss/c0d7p",0x6870 },
+ 	{ "cciss/c0d8p",0x6880 },
+ 	{ "cciss/c0d9p",0x6890 },
+ 	{ "cciss/c0d10p",0x68A0 },
+ 	{ "cciss/c0d11p",0x68B0 },
+ 	{ "cciss/c0d12p",0x68C0 },
+ 	{ "cciss/c0d13p",0x68D0 },
+ 	{ "cciss/c0d14p",0x68E0 },
+ 	{ "cciss/c0d15p",0x68F0 },
+ 	{ "cciss/c1d0p",0x6900 },
+ 	{ "cciss/c2d0p",0x6A00 },
+ 	{ "cciss/c3d0p",0x6B00 },
+ 	{ "cciss/c4d0p",0x6C00 },
+ 	{ "cciss/c5d0p",0x6D00 },
+ 	{ "cciss/c6d0p",0x6E00 },
+ 	{ "cciss/c7d0p",0x6F00 },
+ 	{ "ataraid/d0p",0x7200 },
+ 	{ "ataraid/d1p",0x7210 },
+ 	{ "ataraid/d2p",0x7220 },
+ 	{ "ataraid/d3p",0x7230 },
+ 	{ "ataraid/d4p",0x7240 },
+ 	{ "ataraid/d5p",0x7250 },
+ 	{ "ataraid/d6p",0x7260 },
+ 	{ "ataraid/d7p",0x7270 },
+ 	{ "ataraid/d8p",0x7280 },
+ 	{ "ataraid/d9p",0x7290 },
+ 	{ "ataraid/d10p",0x72A0 },
+ 	{ "ataraid/d11p",0x72B0 },
+ 	{ "ataraid/d12p",0x72C0 },
+ 	{ "ataraid/d13p",0x72D0 },
+ 	{ "ataraid/d14p",0x72E0 },
+ 	{ "ataraid/d15p",0x72F0 },
+         { "rd/c0d0p",0x3000 },
+         { "rd/c0d0p1",0x3001 },
+         { "rd/c0d0p2",0x3002 },
+         { "rd/c0d0p3",0x3003 },
+         { "rd/c0d0p4",0x3004 },
+         { "rd/c0d0p5",0x3005 },
+         { "rd/c0d0p6",0x3006 },
+         { "rd/c0d0p7",0x3007 },
+         { "rd/c0d0p8",0x3008 },
+         { "rd/c0d1p",0x3008 },
+         { "rd/c0d1p1",0x3009 },
+         { "rd/c0d1p2",0x300a },
+         { "rd/c0d1p3",0x300b },
+         { "rd/c0d1p4",0x300c },
+         { "rd/c0d1p5",0x300d },
+         { "rd/c0d1p6",0x300e },
+         { "rd/c0d1p7",0x300f },
+         { "rd/c0d1p8",0x3010 },
+ 	{ "nftla", 0x5d00 },
+ 	{ "nftlb", 0x5d10 },
+ 	{ "nftlc", 0x5d20 },
+ 	{ "nftld", 0x5d30 },
+ 	{ "ftla", 0x2c00 },
+ 	{ "ftlb", 0x2c08 },
+ 	{ "ftlc", 0x2c10 },
+ 	{ "ftld", 0x2c18 },
+ 	{ "mtdblock", 0x1f00 },
+ 	{ "nb", 0x2b00 },
+ 	{ NULL, 0 }
+ };
+ 
+ kdev_t __init name_to_kdev_t(char *line)
+ {
+ 	int base = 0, offs;
+ 	char *end;
+ 
+ 	if (strncmp(line,"/dev/",5) == 0) {
+ 		struct dev_name_struct *dev = root_dev_names;
+ 		line += 5;
+ 		do {
+ 			int len = strlen(dev->name);
+ 			if (strncmp(line,dev->name,len) == 0) {
+ 				line += len;
+ 				base = dev->num;
+ 				break;
+ 			}
+ 			dev++;
+ 		} while (dev->name);
+ 	}
+ 	offs = simple_strtoul(line, &end, base?10:16);
+ 	if (*end)
+ 		offs = 0;
+ 	return to_kdev_t(base + offs);
+ }
+ 
+ static int __init root_dev_setup(char *line)
+ {
+ 	int i;
+ 	char ch;
+ 
+ 	ROOT_DEV = name_to_kdev_t(line);
+ 	memset (root_device_name, 0, sizeof root_device_name);
+ 	if (strncmp (line, "/dev/", 5) == 0) line += 5;
+ 	for (i = 0; i < sizeof root_device_name - 1; ++i)
+ 	{
+ 	    ch = line[i];
+ 	    if ( isspace (ch) || (ch == ',') || (ch == '\0') ) break;
+ 	    root_device_name[i] = ch;
+ 	}
+ 	return 1;
+ }
+ 
+ __setup("root=", root_dev_setup);
+ 
+ static char * __initdata root_mount_data;
+ static int __init root_data_setup(char *str)
+ {
+ 	root_mount_data = str;
+ 	return 1;
+ }
+ 
+ static char * __initdata root_fs_names;
+ static int __init fs_names_setup(char *str)
+ {
+ 	root_fs_names = str;
+ 	return 1;
+ }
+ 
+ __setup("rootflags=", root_data_setup);
+ __setup("rootfstype=", fs_names_setup);
+ 
+ static void __init get_fs_names(char *page)
+ {
+ 	char *s = page;
+ 
+ 	if (root_fs_names) {
+ 		strcpy(page, root_fs_names);
+ 		while (*s++) {
+ 			if (s[-1] == ',')
+ 				s[-1] = '\0';
+ 		}
+ 	} else {
+ 		int len = get_filesystem_list(page);
+ 		char *p, *next;
+ 
+ 		page[len] = '\0';
+ 		for (p = page-1; p; p = next) {
+ 			next = strchr(++p, '\n');
+ 			if (*p++ != '\t')
+ 				continue;
+ 			while ((*s++ = *p++) != '\n')
+ 				;
+ 			s[-1] = '\0';
+ 		}
+ 	}
+ 	*s = '\0';
+ }
+ static void __init mount_block_root(char *name, int flags)
+ {
+ 	char *fs_names = __getname();
+ 	char *p;
+ 
+ 	get_fs_names(fs_names);
+ retry:
+ 	for (p = fs_names; *p; p += strlen(p)+1) {
+ 		int err = sys_mount(name, "/root", p, flags, root_mount_data);
+ 		switch (err) {
+ 			case 0:
+ 				goto out;
+ 			case -EACCES:
+ 				flags |= MS_RDONLY;
+ 				goto retry;
+ 			case -EINVAL:
+ 		        case -EBUSY:
+ 				continue;
+ 		}
+ 	        /*
+ 		 * Allow the user to distinguish between failed open
+ 		 * and bad superblock on root device.
+ 		 */
+ 		printk ("VFS: Cannot open root device \"%s\" or %s\n",
+ 			root_device_name, kdevname (ROOT_DEV));
+ 		printk ("Please append a correct \"root=\" boot option\n");
+ 		panic("VFS: Unable to mount root fs on %s",
+ 			kdevname(ROOT_DEV));
+ 	}
+ 	panic("VFS: Unable to mount root fs on %s", kdevname(ROOT_DEV));
+ out:
+ 	putname(fs_names);
+ 	sys_chdir("/root");
+ 	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+ 	printk("VFS: Mounted root (%s filesystem)%s.\n",
+ 		current->fs->pwdmnt->mnt_sb->s_type->name,
+ 		(current->fs->pwdmnt->mnt_sb->s_flags & MS_RDONLY) ? " readonly" : "");
+ }
+  
+ #ifdef CONFIG_ROOT_NFS
+ static int __init mount_nfs_root(void)
+ {
+ 	void *data = nfs_root_data();
+ 
+ 	if (data && sys_mount("/dev/root","/root","nfs",root_mountflags,data) == 0)
+ 		return 1;
+ 	return 0;
+ }
+ #endif
+ 
+ static int __init create_dev(char *name, kdev_t dev, char *devfs_name)
+ {
+ 	void *handle;
+ 	char path[64];
+ 	int n;
+ 
+ 	sys_unlink(name);
+ 	if (!do_devfs)
+ 		return sys_mknod(name, S_IFBLK|0600, kdev_t_to_nr(dev));
+ 
+ 	handle = devfs_find_handle(NULL, dev ? NULL : devfs_name,
+ 				MAJOR(dev), MINOR(dev), DEVFS_SPECIAL_BLK, 1);
+ 	if (!handle)
+ 		return -1;
+ 	n = devfs_generate_path(handle, path + 5, sizeof (path) - 5);
+ 	if (n < 0)
+ 		return -1;
+ 	return sys_symlink(path + n + 5, name);
+ }
+ 
+ #if defined(CONFIG_BLK_DEV_RAM) || defined(CONFIG_BLK_DEV_FD)
+ static void __init change_floppy(char *fmt, ...)
+ {
+ 	struct termios termios;
+ 	char buf[80];
+ 	char c;
+ 	int fd;
+ 	va_list args;
+ 	va_start(args, fmt);
+ 	vsprintf(buf, fmt, args);
+ 	va_end(args);
+ 	fd = open("/dev/root", O_RDWR | O_NDELAY, 0);
+ 	if (fd >= 0) {
+ 		sys_ioctl(fd, FDEJECT, 0);
+ 		close(fd);
+ 	}
+ 	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
+ 	fd = open("/dev/console", O_RDWR, 0);
+ 	if (fd >= 0) {
+ 		sys_ioctl(fd, TCGETS, (long)&termios);
+ 		termios.c_lflag &= ~ICANON;
+ 		sys_ioctl(fd, TCSETSF, (long)&termios);
+ 		read(fd, &c, 1);
+ 		termios.c_lflag |= ICANON;
+ 		sys_ioctl(fd, TCSETSF, (long)&termios);
+ 		close(fd);
+ 	}
+ }
+ #endif
+ 
+ #ifdef CONFIG_BLK_DEV_RAM
+ 
+ int __initdata rd_prompt = 1;	/* 1 = prompt for RAM disk, 0 = don't prompt */
+ 
+ static int __init prompt_ramdisk(char *str)
+ {
+ 	rd_prompt = simple_strtol(str,NULL,0) & 1;
+ 	return 1;
+ }
+ __setup("prompt_ramdisk=", prompt_ramdisk);
+ 
+ int __initdata rd_image_start;		/* starting block # of image */
+ 
+ static int __init ramdisk_start_setup(char *str)
+ {
+ 	rd_image_start = simple_strtol(str,NULL,0);
+ 	return 1;
+ }
+ __setup("ramdisk_start=", ramdisk_start_setup);
+ 
+ static int __init crd_load(int in_fd, int out_fd);
+ 
+ /*
+  * This routine tries to find a RAM disk image to load, and returns the
+  * number of blocks to read for a non-compressed image, 0 if the image
+  * is a compressed image, and -1 if an image with the right magic
+  * numbers could not be found.
+  *
+  * We currently check for the following magic numbers:
+  * 	minix
+  * 	ext2
+  *	romfs
+  *	cramfs
+  * 	gzip
+  */
+ static int __init 
+ identify_ramdisk_image(int fd, int start_block)
+ {
+ 	const int size = 512;
+ 	struct minix_super_block *minixsb;
+ 	struct ext2_super_block *ext2sb;
+ 	struct romfs_super_block *romfsb;
+ 	struct cramfs_super *cramfsb;
+ 	int nblocks = -1;
+ 	unsigned char *buf;
+ 
+ 	buf = kmalloc(size, GFP_KERNEL);
+ 	if (buf == 0)
+ 		return -1;
+ 
+ 	minixsb = (struct minix_super_block *) buf;
+ 	ext2sb = (struct ext2_super_block *) buf;
+ 	romfsb = (struct romfs_super_block *) buf;
+ 	cramfsb = (struct cramfs_super *) buf;
+ 	memset(buf, 0xe5, size);
+ 
+ 	/*
+ 	 * Read block 0 to test for gzipped kernel
+ 	 */
+ 	lseek(fd, start_block * BLOCK_SIZE, 0);
+ 	read(fd, buf, size);
+ 
+ 	/*
+ 	 * If it matches the gzip magic numbers, return -1
+ 	 */
+ 	if (buf[0] == 037 && ((buf[1] == 0213) || (buf[1] == 0236))) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: Compressed image found at block %d\n",
+ 		       start_block);
+ 		nblocks = 0;
+ 		goto done;
+ 	}
+ 
+ 	/* romfs is at block zero too */
+ 	if (romfsb->word0 == ROMSB_WORD0 &&
+ 	    romfsb->word1 == ROMSB_WORD1) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: romfs filesystem found at block %d\n",
+ 		       start_block);
+ 		nblocks = (ntohl(romfsb->size)+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+ 		goto done;
+ 	}
+ 
+ 	if (cramfsb->magic == CRAMFS_MAGIC) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: cramfs filesystem found at block %d\n",
+ 		       start_block);
+ 		nblocks = (cramfsb->size + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
+ 		goto done;
+ 	}
+ 
+ 	/*
+ 	 * Read block 1 to test for minix and ext2 superblock
+ 	 */
+ 	lseek(fd, (start_block+1) * BLOCK_SIZE, 0);
+ 	read(fd, buf, size);
+ 
+ 	/* Try minix */
+ 	if (minixsb->s_magic == MINIX_SUPER_MAGIC ||
+ 	    minixsb->s_magic == MINIX_SUPER_MAGIC2) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: Minix filesystem found at block %d\n",
+ 		       start_block);
+ 		nblocks = minixsb->s_nzones << minixsb->s_log_zone_size;
+ 		goto done;
+ 	}
+ 
+ 	/* Try ext2 */
+ 	if (ext2sb->s_magic == cpu_to_le16(EXT2_SUPER_MAGIC)) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: ext2 filesystem found at block %d\n",
+ 		       start_block);
+ 		nblocks = le32_to_cpu(ext2sb->s_blocks_count);
+ 		goto done;
+ 	}
+ 
+ 	printk(KERN_NOTICE
+ 	       "RAMDISK: Couldn't find valid RAM disk image starting at %d.\n",
+ 	       start_block);
+ 	
+ done:
+ 	lseek(fd, start_block * BLOCK_SIZE, 0);
+ 	kfree(buf);
+ 	return nblocks;
+ }
+ #endif
+ 
+ static int __init rd_load_image(char *from)
+ {
+ 	int res = 0;
+ 
+ #ifdef CONFIG_BLK_DEV_RAM
+ 	int in_fd, out_fd;
+ 	unsigned long rd_blocks, devblocks;
+ 	int nblocks, i;
+ 	char *buf;
+ 	unsigned short rotate = 0;
+ #if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC_ISERIES)
+ 	char rotator[4] = { '|' , '/' , '-' , '\\' };
+ #endif
+ 
+ 	out_fd = open("/dev/ram", O_RDWR, 0);
+ 	if (out_fd < 0)
+ 		goto out;
+ 
+ 	in_fd = open(from, O_RDONLY, 0);
+ 	if (in_fd < 0)
+ 		goto noclose_input;
+ 
+ 	nblocks = identify_ramdisk_image(in_fd, rd_image_start);
+ 	if (nblocks < 0)
+ 		goto done;
+ 
+ 	if (nblocks == 0) {
+ #ifdef BUILD_CRAMDISK
+ 		if (crd_load(in_fd, out_fd) == 0)
+ 			goto successful_load;
+ #else
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: Kernel does not support compressed "
+ 		       "RAM disk images\n");
+ #endif
+ 		goto done;
+ 	}
+ 
+ 	/*
+ 	 * NOTE NOTE: nblocks suppose that the blocksize is BLOCK_SIZE, so
+ 	 * rd_load_image will work only with filesystem BLOCK_SIZE wide!
+ 	 * So make sure to use 1k blocksize while generating ext2fs
+ 	 * ramdisk-images.
+ 	 */
+ 	if (sys_ioctl(out_fd, BLKGETSIZE, (unsigned long)&rd_blocks) < 0)
+ 		rd_blocks = 0;
+ 	else
+ 		rd_blocks >>= 1;
+ 
+ 	if (nblocks > rd_blocks) {
+ 		printk("RAMDISK: image too big! (%d/%lu blocks)\n",
+ 		       nblocks, rd_blocks);
+ 		goto done;
+ 	}
+ 		
+ 	/*
+ 	 * OK, time to copy in the data
+ 	 */
+ 	buf = kmalloc(BLOCK_SIZE, GFP_KERNEL);
+ 	if (buf == 0) {
+ 		printk(KERN_ERR "RAMDISK: could not allocate buffer\n");
+ 		goto done;
+ 	}
+ 
+ 	if (sys_ioctl(in_fd, BLKGETSIZE, (unsigned long)&devblocks) < 0)
+ 		devblocks = 0;
+ 	else
+ 		devblocks >>= 1;
+ 
+ 	if (strcmp(from, "/dev/initrd") == 0)
+ 		devblocks = nblocks;
+ 
+ 	if (devblocks == 0) {
+ 		printk(KERN_ERR "RAMDISK: could not determine device size\n");
+ 		goto done;
+ 	}
+ 
+ 	printk(KERN_NOTICE "RAMDISK: Loading %d blocks [%ld disk%s] into ram disk... ", 
+ 		nblocks, ((nblocks-1)/devblocks)+1, nblocks>devblocks ? "s" : "");
+ 	for (i=0; i < nblocks; i++) {
+ 		if (i && (i % devblocks == 0)) {
+ 			printk("done disk #%ld.\n", i/devblocks);
+ 			rotate = 0;
+ 			if (close(in_fd)) {
+ 				printk("Error closing the disk.\n");
+ 				goto noclose_input;
+ 			}
+ 			change_floppy("disk #%d", i/devblocks+1);
+ 			in_fd = open(from, O_RDONLY, 0);
+ 			if (in_fd < 0)  {
+ 				printk("Error opening disk.\n");
+ 				goto noclose_input;
+ 			}
+ 			printk("Loading disk #%ld... ", i/devblocks+1);
+ 		}
+ 		read(in_fd, buf, BLOCK_SIZE);
+ 		write(out_fd, buf, BLOCK_SIZE);
+ #if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC_ISERIES)
+ 		if (!(i % 16)) {
+ 			printk("%c\b", rotator[rotate & 0x3]);
+ 			rotate++;
+ 		}
+ #endif
+ 	}
+ 	printk("done.\n");
+ 	kfree(buf);
+ 
+ successful_load:
+ 	res = 1;
+ done:
+ 	close(in_fd);
+ noclose_input:
+ 	close(out_fd);
+ out:
+ 	sys_unlink("/dev/ram");
+ #endif
+ 	return res;
+ }
+ 
+ static int __init rd_load_disk(int n)
+ {
+ #ifdef CONFIG_BLK_DEV_RAM
+ 	if (rd_prompt)
+ 		change_floppy("root floppy disk to be loaded into RAM disk");
+ 	create_dev("/dev/ram", MKDEV(RAMDISK_MAJOR, n), NULL);
+ #endif
+ 	return rd_load_image("/dev/root");
+ }
+ 
+ #ifdef CONFIG_DEVFS_FS
+ 
+ static void __init convert_name(char *prefix, char *name, char *p, int part)
+ {
+ 	int host, bus, target, lun;
+ 	char dest[64];
+ 	char src[64];
+ 	char *base = p - 1;
+ 
+ 	/*  Decode "c#b#t#u#"  */
+ 	if (*p++ != 'c')
+ 		return;
+ 	host = simple_strtol(p, &p, 10);
+ 	if (*p++ != 'b')
+ 		return;
+ 	bus = simple_strtol(p, &p, 10);
+ 	if (*p++ != 't')
+ 		return;
+ 	target = simple_strtol(p, &p, 10);
+ 	if (*p++ != 'u')
+ 		return;
+ 	lun = simple_strtol(p, &p, 10);
+ 	if (!part)
+ 		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d",
+ 				prefix, host, bus, target, lun);
+ 	else if (*p++ == 'p')
+ 		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d/part%s",
+ 				prefix, host, bus, target, lun, p);
+ 	else
+ 		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d/disc",
+ 				prefix, host, bus, target, lun);
+ 	*base = '\0';
+ 	sprintf(src, "/dev/%s", name);
+ 	sys_mkdir(src, 0755);
+ 	*base = '/';
+ 	sprintf(src, "/dev/%s", name);
+ 	sys_symlink(dest, src);
+ }
+ 
+ static void __init devfs_make_root(char *name)
+ {
+ 
+ 	if (!strncmp(name, "sd/", 3))
+ 		convert_name("../scsi", name, name+3, 1);
+ 	else if (!strncmp(name, "sr/", 3))
+ 		convert_name("../scsi", name, name+3, 0);
+ 	else if (!strncmp(name, "ide/hd/", 7))
+ 		convert_name("..", name, name + 7, 1);
+ 	else if (!strncmp(name, "ide/cd/", 7))
+ 		convert_name("..", name, name + 7, 0);
+ }
+ #else
+ static void __init devfs_make_root(char *name)
+ {
+ }
+ #endif
+ 
+ static void __init mount_root(void)
+ {
+ #ifdef CONFIG_ROOT_NFS
+        if (MAJOR(ROOT_DEV) == NFS_MAJOR
+            && MINOR(ROOT_DEV) == NFS_MINOR) {
+ 		if (mount_nfs_root()) {
+ 			sys_chdir("/root");
+ 			ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+ 			printk("VFS: Mounted root (nfs filesystem).\n");
+ 			return;
+ 		}
+ 		printk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");
+ 		ROOT_DEV = MKDEV(FLOPPY_MAJOR, 0);
+ 	}
+ #endif
+ 	devfs_make_root(root_device_name);
+ 	create_dev("/dev/root", ROOT_DEV, root_device_name);
+ #ifdef CONFIG_BLK_DEV_FD
+ 	if (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {
+ 		/* rd_doload is 2 for a dual initrd/ramload setup */
+ 		if (rd_doload==2) {
+ 			if (rd_load_disk(1)) {
+ 				ROOT_DEV = MKDEV(RAMDISK_MAJOR, 1);
+ 				create_dev("/dev/root", ROOT_DEV, NULL);
+ 			}
+ 		} else
+ 			change_floppy("root floppy");
+ 	}
+ #endif
+ 	mount_block_root("/dev/root", root_mountflags);
+ }
+ 
+ #ifdef CONFIG_BLK_DEV_INITRD
+ static int old_fd, root_fd;
+ static int do_linuxrc(void * shell)
+ {
+ 	static char *argv[] = { "linuxrc", NULL, };
+ 	extern char * envp_init[];
+ 
+ 	close(old_fd);
+ 	close(root_fd);
+ 	close(0);
+ 	close(1);
+ 	close(2);
+ 	setsid();
+ 	(void) open("/dev/console",O_RDWR,0);
+ 	(void) dup(0);
+ 	(void) dup(0);
+ 	return execve(shell, argv, envp_init);
+ }
+ 
+ #endif
+ 
+ static void __init handle_initrd(void)
+ {
+ #ifdef CONFIG_BLK_DEV_INITRD
+ 	int ram0 = kdev_t_to_nr(MKDEV(RAMDISK_MAJOR,0));
+ 	int error;
+ 	int i, pid;
+ 
+ 	create_dev("/dev/root.old", ram0, NULL);
+ 	/* mount initrd on rootfs' /root */
+ 	mount_block_root("/dev/root.old", root_mountflags & ~MS_RDONLY);
+ 	sys_mkdir("/old", 0700);
+ 	root_fd = open("/", 0, 0);
+ 	old_fd = open("/old", 0, 0);
+ 	/* move initrd over / and chdir/chroot in initrd root */
+ 	sys_chdir("/root");
+ 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
+ 	sys_chroot(".");
+ 	mount_devfs_fs ();
+ 
+ 	pid = kernel_thread(do_linuxrc, "/linuxrc", SIGCHLD);
+ 	if (pid > 0) {
+ 		while (pid != wait(&i))
+ 			yield();
+ 	}
+ 
+ 	/* move initrd to rootfs' /old */
+ 	sys_fchdir(old_fd);
+ 	sys_mount("/", ".", NULL, MS_MOVE, NULL);
+ 	/* switch root and cwd back to / of rootfs */
+ 	sys_fchdir(root_fd);
+ 	sys_chroot(".");
+ 	sys_umount("/old/dev", 0);
+ 	close(old_fd);
+ 	close(root_fd);
+ 
+ 	if (real_root_dev == ram0) {
+ 		sys_chdir("/old");
+ 		return;
+ 	}
+ 
+ 	ROOT_DEV = real_root_dev;
+ 	mount_root();
+ 
+ 	printk(KERN_NOTICE "Trying to move old root to /initrd ... ");
+ 	error = sys_mount("/old", "/root/initrd", NULL, MS_MOVE, NULL);
+ 	if (!error)
+ 		printk("okay\n");
+ 	else {
+ 		int fd = open("/dev/root.old", O_RDWR, 0);
+ 		printk("failed\n");
+ 		printk(KERN_NOTICE "Unmounting old root\n");
+ 		sys_umount("/old", MNT_DETACH);
+ 		printk(KERN_NOTICE "Trying to free ramdisk memory ... ");
+ 		if (fd < 0) {
+ 			error = fd;
+ 		} else {
+ 			error = sys_ioctl(fd, BLKFLSBUF, 0);
+ 			close(fd);
+ 		}
+ 		printk(!error ? "okay\n" : "failed\n");
+ 	}
+ #endif
+ }
+ 
+ static int __init initrd_load(void)
+ {
+ #ifdef CONFIG_BLK_DEV_INITRD
+ 	create_dev("/dev/ram", MKDEV(RAMDISK_MAJOR, 0), NULL);
+ 	create_dev("/dev/initrd", MKDEV(RAMDISK_MAJOR, INITRD_MINOR), NULL);
+ #endif
+ 	return rd_load_image("/dev/initrd");
+ }
+ 
+ /*
+  * Prepare the namespace - decide what/where to mount, load ramdisks, etc.
+  */
+ void prepare_namespace(void)
+ {
+ 	int is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR || MAJOR(ROOT_DEV) == 31;
+ #ifdef CONFIG_ALL_PPC
+ 	extern void arch_discover_root(void);
+ 	arch_discover_root();
+ #endif /* CONFIG_ALL_PPC */
+ #ifdef CONFIG_BLK_DEV_INITRD
+ 	if (!initrd_start)
+ 		mount_initrd = 0;
+ 	real_root_dev = ROOT_DEV;
+ #endif
+ 	sys_mkdir("/dev", 0700);
+ 	sys_mkdir("/root", 0700);
+ 	sys_mknod("/dev/console", S_IFCHR|0600, MKDEV(TTYAUX_MAJOR, 1));
+ #ifdef CONFIG_DEVFS_FS
+ 	sys_mount("devfs", "/dev", "devfs", 0, NULL);
+ 	do_devfs = 1;
+ #endif
+ 
+ 	create_dev("/dev/root", ROOT_DEV, NULL);
+ 	if (mount_initrd) {
+ 		if (initrd_load() && ROOT_DEV != MKDEV(RAMDISK_MAJOR, 0)) {
+ 			handle_initrd();
+ 			goto out;
+ 		}
+ 	} else if (is_floppy && rd_doload && rd_load_disk(0))
+ 		ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+ 	mount_root();
+ out:
+ 	sys_umount("/dev", 0);
+ 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
+ 	sys_chroot(".");
+ 	mount_devfs_fs ();
+ }
+ 
+ #ifdef CONFIG_BLK_DEV_RAM
+ 
+ #if defined(BUILD_CRAMDISK) && defined(CONFIG_BLK_DEV_RAM)
+ 
+ /*
+  * gzip declarations
+  */
+ 
+ #define OF(args)  args
+ 
+ #ifndef memzero
+ #define memzero(s, n)     memset ((s), 0, (n))
+ #endif
+ 
+ typedef unsigned char  uch;
+ typedef unsigned short ush;
+ typedef unsigned long  ulg;
+ 
+ #define INBUFSIZ 4096
+ #define WSIZE 0x8000    /* window size--must be a power of two, and */
+ 			/*  at least 32K for zip's deflate method */
+ 
+ static uch *inbuf;
+ static uch *window;
+ 
+ static unsigned insize;  /* valid bytes in inbuf */
+ static unsigned inptr;   /* index of next byte to be processed in inbuf */
+ static unsigned outcnt;  /* bytes in output buffer */
+ static int exit_code;
+ static int unzip_error;
+ static long bytes_out;
+ static int crd_infd, crd_outfd;
+ 
+ #define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+ 		
+ /* Diagnostic functions (stubbed out) */
+ #define Assert(cond,msg)
+ #define Trace(x)
+ #define Tracev(x)
+ #define Tracevv(x)
+ #define Tracec(c,x)
+ #define Tracecv(c,x)
+ 
+ #define STATIC static
+ 
+ static int  fill_inbuf(void);
+ static void flush_window(void);
+ static void *malloc(int size);
+ static void free(void *where);
+ static void error(char *m);
+ static void gzip_mark(void **);
+ static void gzip_release(void **);
+ 
+ #include "../lib/inflate.c"
+ 
+ static void __init *malloc(int size)
+ {
+ 	return kmalloc(size, GFP_KERNEL);
+ }
+ 
+ static void __init free(void *where)
+ {
+ 	kfree(where);
+ }
+ 
+ static void __init gzip_mark(void **ptr)
+ {
+ }
+ 
+ static void __init gzip_release(void **ptr)
+ {
+ }
+ 
+ 
+ /* ===========================================================================
+  * Fill the input buffer. This is called only when the buffer is empty
+  * and at least one byte is really needed.
+  * Returning -1 does not guarantee that gunzip() will ever return.
+  */
+ static int __init fill_inbuf(void)
+ {
+ 	if (exit_code) return -1;
+ 	
+ 	insize = read(crd_infd, inbuf, INBUFSIZ);
+ 	if (insize == 0) {
+ 		error("RAMDISK: ran out of compressed data\n");
+ 		return -1;
+ 	}
+ 
+ 	inptr = 1;
+ 
+ 	return inbuf[0];
+ }
+ 
+ /* ===========================================================================
+  * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+  * (Used for the decompressed data only.)
+  */
+ static void __init flush_window(void)
+ {
+     ulg c = crc;         /* temporary variable */
+     unsigned n, written;
+     uch *in, ch;
+     
+     written = write(crd_outfd, window, outcnt);
+     if (written != outcnt && unzip_error == 0) {
+ 	printk(KERN_ERR "RAMDISK: incomplete write (%d != %d), "
+ 	       "only wrote %ld\n", written, outcnt, bytes_out);
+ 	unzip_error = 1;
+     }
+     in = window;
+     for (n = 0; n < outcnt; n++) {
+ 	    ch = *in++;
+ 	    c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+     }
+     crc = c;
+     bytes_out += (ulg)outcnt;
+     outcnt = 0;
+ }
+ 
+ static void __init error(char *x)
+ {
+ 	printk(KERN_ERR "%s", x);
+ 	exit_code = 1;
+ 	unzip_error = 1;
+ }
+ 
+ static int __init crd_load(int in_fd, int out_fd)
+ {
+ 	int result;
+ 
+ 	insize = 0;		/* valid bytes in inbuf */
+ 	inptr = 0;		/* index of next byte to be processed in inbuf */
+ 	outcnt = 0;		/* bytes in output buffer */
+ 	exit_code = 0;
+ 	bytes_out = 0;
+ 	crc = (ulg)0xffffffffL; /* shift register contents */
+ 
+ 	crd_infd = in_fd;
+ 	crd_outfd = out_fd;
+ 	inbuf = kmalloc(INBUFSIZ, GFP_KERNEL);
+ 	if (inbuf == 0) {
+ 		printk(KERN_ERR "RAMDISK: Couldn't allocate gzip buffer\n");
+ 		return -1;
+ 	}
+ 	window = kmalloc(WSIZE, GFP_KERNEL);
+ 	if (window == 0) {
+ 		printk(KERN_ERR "RAMDISK: Couldn't allocate gzip window\n");
+ 		kfree(inbuf);
+ 		return -1;
+ 	}
+ 	makecrc();
+ 	result = gunzip();
+ 	if (unzip_error)
+ 		result = 1;
+ 	kfree(inbuf);
+ 	kfree(window);
+ 	return result;
+ }
+ 
+ #endif  /* BUILD_CRAMDISK && CONFIG_BLK_DEV_RAM */
+ #endif  /* CONFIG_BLK_DEV_RAM */
diff -crBN linux-2.4.27/init/do_mounts.c.rej linux-2.4.27-w/init/do_mounts.c.rej
*** linux-2.4.27/init/do_mounts.c.rej	1969-12-31 16:00:00.000000000 -0800
--- linux-2.4.27-w/init/do_mounts.c.rej	2013-01-22 23:03:30.511023653 -0800
***************
*** 0 ****
--- 1,1091 ----
+ --- init/do_mounts.c	2009-12-21 14:19:56.313428766 +0000
+ +++ base-1patched-linux-2.4.27/init/do_mounts.c	1970-01-01 01:00:00.000000000 +0100
+ @@ -1,1088 +0,0 @@
+ -#define __KERNEL_SYSCALLS__
+ -#include <linux/config.h>
+ -#include <linux/slab.h>
+ -#include <linux/devfs_fs_kernel.h>
+ -#include <linux/unistd.h>
+ -#include <linux/ctype.h>
+ -#include <linux/blk.h>
+ -#include <linux/fd.h>
+ -#include <linux/tty.h>
+ -#include <linux/init.h>
+ -
+ -#include <linux/nfs_fs.h>
+ -#include <linux/nfs_fs_sb.h>
+ -#include <linux/nfs_mount.h>
+ -#include <linux/minix_fs.h>
+ -#include <linux/ext2_fs.h>
+ -#include <linux/romfs_fs.h>
+ -#include <linux/cramfs_fs.h>
+ -
+ -#define BUILD_CRAMDISK
+ -
+ -extern int get_filesystem_list(char * buf);
+ -
+ -extern asmlinkage long sys_mount(char *dev_name, char *dir_name, char *type,
+ -	 unsigned long flags, void *data);
+ -extern asmlinkage long sys_mkdir(const char *name, int mode);
+ -extern asmlinkage long sys_chdir(const char *name);
+ -extern asmlinkage long sys_fchdir(int fd);
+ -extern asmlinkage long sys_chroot(const char *name);
+ -extern asmlinkage long sys_unlink(const char *name);
+ -extern asmlinkage long sys_symlink(const char *old, const char *new);
+ -extern asmlinkage long sys_mknod(const char *name, int mode, dev_t dev);
+ -extern asmlinkage long sys_umount(char *name, int flags);
+ -extern asmlinkage long sys_ioctl(int fd, int cmd, unsigned long arg);
+ -
+ -#ifdef CONFIG_BLK_DEV_INITRD
+ -unsigned int real_root_dev;	/* do_proc_dointvec cannot handle kdev_t */
+ -static int __initdata mount_initrd = 1;
+ -
+ -static int __init no_initrd(char *str)
+ -{
+ -	mount_initrd = 0;
+ -	return 1;
+ -}
+ -
+ -__setup("noinitrd", no_initrd);
+ -#else
+ -static int __initdata mount_initrd = 0;
+ -#endif
+ -
+ -int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
+ -
+ -int root_mountflags = MS_RDONLY | MS_VERBOSE;
+ -static char root_device_name[64];
+ -
+ -/* this is initialized in init/main.c */
+ -kdev_t ROOT_DEV;
+ -
+ -static int do_devfs = 0;
+ -
+ -static int __init load_ramdisk(char *str)
+ -{
+ -	rd_doload = simple_strtol(str,NULL,0) & 3;
+ -	return 1;
+ -}
+ -__setup("load_ramdisk=", load_ramdisk);
+ -
+ -static int __init readonly(char *str)
+ -{
+ -	if (*str)
+ -		return 0;
+ -	root_mountflags |= MS_RDONLY;
+ -	return 1;
+ -}
+ -
+ -static int __init readwrite(char *str)
+ -{
+ -	if (*str)
+ -		return 0;
+ -	root_mountflags &= ~MS_RDONLY;
+ -	return 1;
+ -}
+ -
+ -__setup("ro", readonly);
+ -__setup("rw", readwrite);
+ -
+ -static struct dev_name_struct {
+ -	const char *name;
+ -	const int num;
+ -} root_dev_names[] __initdata = {
+ -	{ "nfs",     MKDEV(NFS_MAJOR, NFS_MINOR) },
+ -	{ "hda",     0x0300 },
+ -	{ "hdb",     0x0340 },
+ -	{ "loop",    0x0700 },
+ -	{ "hdc",     0x1600 },
+ -	{ "hdd",     0x1640 },
+ -	{ "hde",     0x2100 },
+ -	{ "hdf",     0x2140 },
+ -	{ "hdg",     0x2200 },
+ -	{ "hdh",     0x2240 },
+ -	{ "hdi",     0x3800 },
+ -	{ "hdj",     0x3840 },
+ -	{ "hdk",     0x3900 },
+ -	{ "hdl",     0x3940 },
+ -	{ "hdm",     0x5800 },
+ -	{ "hdn",     0x5840 },
+ -	{ "hdo",     0x5900 },
+ -	{ "hdp",     0x5940 },
+ -	{ "hdq",     0x5A00 },
+ -	{ "hdr",     0x5A40 },
+ -	{ "hds",     0x5B00 },
+ -	{ "hdt",     0x5B40 },
+ -	{ "sda",     0x0800 },
+ -	{ "sdb",     0x0810 },
+ -	{ "sdc",     0x0820 },
+ -	{ "sdd",     0x0830 },
+ -	{ "sde",     0x0840 },
+ -	{ "sdf",     0x0850 },
+ -	{ "sdg",     0x0860 },
+ -	{ "sdh",     0x0870 },
+ -	{ "sdi",     0x0880 },
+ -	{ "sdj",     0x0890 },
+ -	{ "sdk",     0x08a0 },
+ -	{ "sdl",     0x08b0 },
+ -	{ "sdm",     0x08c0 },
+ -	{ "sdn",     0x08d0 },
+ -	{ "sdo",     0x08e0 },
+ -	{ "sdp",     0x08f0 },
+ -	{ "ada",     0x1c00 },
+ -	{ "adb",     0x1c10 },
+ -	{ "adc",     0x1c20 },
+ -	{ "add",     0x1c30 },
+ -	{ "ade",     0x1c40 },
+ -	{ "fd",      0x0200 },
+ -	{ "md",      0x0900 },	     
+ -	{ "xda",     0x0d00 },
+ -	{ "xdb",     0x0d40 },
+ -	{ "ram",     0x0100 },
+ -	{ "scd",     0x0b00 },
+ -	{ "mcd",     0x1700 },
+ -	{ "cdu535",  0x1800 },
+ -	{ "sonycd",  0x1800 },
+ -	{ "aztcd",   0x1d00 },
+ -	{ "cm206cd", 0x2000 },
+ -	{ "gscd",    0x1000 },
+ -	{ "sbpcd",   0x1900 },
+ -	{ "eda",     0x2400 },
+ -	{ "edb",     0x2440 },
+ -	{ "pda",	0x2d00 },
+ -	{ "pdb",	0x2d10 },
+ -	{ "pdc",	0x2d20 },
+ -	{ "pdd",	0x2d30 },
+ -	{ "pcd",	0x2e00 },
+ -	{ "pf",		0x2f00 },
+ -	{ "apblock", APBLOCK_MAJOR << 8},
+ -	{ "ddv", DDV_MAJOR << 8},
+ -	{ "jsfd",    JSFD_MAJOR << 8},
+ -#if defined(CONFIG_ARCH_S390)
+ -	{ "dasda", (DASD_MAJOR << MINORBITS) },
+ -	{ "dasdb", (DASD_MAJOR << MINORBITS) + (1 << 2) },
+ -	{ "dasdc", (DASD_MAJOR << MINORBITS) + (2 << 2) },
+ -	{ "dasdd", (DASD_MAJOR << MINORBITS) + (3 << 2) },
+ -	{ "dasde", (DASD_MAJOR << MINORBITS) + (4 << 2) },
+ -	{ "dasdf", (DASD_MAJOR << MINORBITS) + (5 << 2) },
+ -	{ "dasdg", (DASD_MAJOR << MINORBITS) + (6 << 2) },
+ -	{ "dasdh", (DASD_MAJOR << MINORBITS) + (7 << 2) },
+ -#endif
+ -	{ "ida/c0d0p",0x4800 },
+ -	{ "ida/c0d1p",0x4810 },
+ -	{ "ida/c0d2p",0x4820 },
+ -	{ "ida/c0d3p",0x4830 },
+ -	{ "ida/c0d4p",0x4840 },
+ -	{ "ida/c0d5p",0x4850 },
+ -	{ "ida/c0d6p",0x4860 },
+ -	{ "ida/c0d7p",0x4870 },
+ -	{ "ida/c0d8p",0x4880 },
+ -	{ "ida/c0d9p",0x4890 },
+ -	{ "ida/c0d10p",0x48A0 },
+ -	{ "ida/c0d11p",0x48B0 },
+ -	{ "ida/c0d12p",0x48C0 },
+ -	{ "ida/c0d13p",0x48D0 },
+ -	{ "ida/c0d14p",0x48E0 },
+ -	{ "ida/c0d15p",0x48F0 },
+ -	{ "ida/c1d0p",0x4900 },
+ -	{ "ida/c2d0p",0x4A00 },
+ -	{ "ida/c3d0p",0x4B00 },
+ -	{ "ida/c4d0p",0x4C00 },
+ -	{ "ida/c5d0p",0x4D00 },
+ -	{ "ida/c6d0p",0x4E00 },
+ -	{ "ida/c7d0p",0x4F00 }, 
+ -	{ "cciss/c0d0p",0x6800 },
+ -	{ "cciss/c0d1p",0x6810 },
+ -	{ "cciss/c0d2p",0x6820 },
+ -	{ "cciss/c0d3p",0x6830 },
+ -	{ "cciss/c0d4p",0x6840 },
+ -	{ "cciss/c0d5p",0x6850 },
+ -	{ "cciss/c0d6p",0x6860 },
+ -	{ "cciss/c0d7p",0x6870 },
+ -	{ "cciss/c0d8p",0x6880 },
+ -	{ "cciss/c0d9p",0x6890 },
+ -	{ "cciss/c0d10p",0x68A0 },
+ -	{ "cciss/c0d11p",0x68B0 },
+ -	{ "cciss/c0d12p",0x68C0 },
+ -	{ "cciss/c0d13p",0x68D0 },
+ -	{ "cciss/c0d14p",0x68E0 },
+ -	{ "cciss/c0d15p",0x68F0 },
+ -	{ "cciss/c1d0p",0x6900 },
+ -	{ "cciss/c2d0p",0x6A00 },
+ -	{ "cciss/c3d0p",0x6B00 },
+ -	{ "cciss/c4d0p",0x6C00 },
+ -	{ "cciss/c5d0p",0x6D00 },
+ -	{ "cciss/c6d0p",0x6E00 },
+ -	{ "cciss/c7d0p",0x6F00 },
+ -	{ "ataraid/d0p",0x7200 },
+ -	{ "ataraid/d1p",0x7210 },
+ -	{ "ataraid/d2p",0x7220 },
+ -	{ "ataraid/d3p",0x7230 },
+ -	{ "ataraid/d4p",0x7240 },
+ -	{ "ataraid/d5p",0x7250 },
+ -	{ "ataraid/d6p",0x7260 },
+ -	{ "ataraid/d7p",0x7270 },
+ -	{ "ataraid/d8p",0x7280 },
+ -	{ "ataraid/d9p",0x7290 },
+ -	{ "ataraid/d10p",0x72A0 },
+ -	{ "ataraid/d11p",0x72B0 },
+ -	{ "ataraid/d12p",0x72C0 },
+ -	{ "ataraid/d13p",0x72D0 },
+ -	{ "ataraid/d14p",0x72E0 },
+ -	{ "ataraid/d15p",0x72F0 },
+ -        { "rd/c0d0p",0x3000 },
+ -        { "rd/c0d0p1",0x3001 },
+ -        { "rd/c0d0p2",0x3002 },
+ -        { "rd/c0d0p3",0x3003 },
+ -        { "rd/c0d0p4",0x3004 },
+ -        { "rd/c0d0p5",0x3005 },
+ -        { "rd/c0d0p6",0x3006 },
+ -        { "rd/c0d0p7",0x3007 },
+ -        { "rd/c0d0p8",0x3008 },
+ -        { "rd/c0d1p",0x3008 },
+ -        { "rd/c0d1p1",0x3009 },
+ -        { "rd/c0d1p2",0x300a },
+ -        { "rd/c0d1p3",0x300b },
+ -        { "rd/c0d1p4",0x300c },
+ -        { "rd/c0d1p5",0x300d },
+ -        { "rd/c0d1p6",0x300e },
+ -        { "rd/c0d1p7",0x300f },
+ -        { "rd/c0d1p8",0x3010 },
+ -	{ "nftla", 0x5d00 },
+ -	{ "nftlb", 0x5d10 },
+ -	{ "nftlc", 0x5d20 },
+ -	{ "nftld", 0x5d30 },
+ -	{ "ftla", 0x2c00 },
+ -	{ "ftlb", 0x2c08 },
+ -	{ "ftlc", 0x2c10 },
+ -	{ "ftld", 0x2c18 },
+ -	{ "mtdblock", 0x1f00 },
+ -	{ "nb", 0x2b00 },
+ -	{ NULL, 0 }
+ -};
+ -
+ -kdev_t __init name_to_kdev_t(char *line)
+ -{
+ -	int base = 0, offs;
+ -	char *end;
+ -
+ -	if (strncmp(line,"/dev/",5) == 0) {
+ -		struct dev_name_struct *dev = root_dev_names;
+ -		line += 5;
+ -		do {
+ -			int len = strlen(dev->name);
+ -			if (strncmp(line,dev->name,len) == 0) {
+ -				line += len;
+ -				base = dev->num;
+ -				break;
+ -			}
+ -			dev++;
+ -		} while (dev->name);
+ -	}
+ -	offs = simple_strtoul(line, &end, base?10:16);
+ -	if (*end)
+ -		offs = 0;
+ -	return to_kdev_t(base + offs);
+ -}
+ -
+ -static int __init root_dev_setup(char *line)
+ -{
+ -	int i;
+ -	char ch;
+ -
+ -	ROOT_DEV = name_to_kdev_t(line);
+ -	memset (root_device_name, 0, sizeof root_device_name);
+ -	if (strncmp (line, "/dev/", 5) == 0) line += 5;
+ -	for (i = 0; i < sizeof root_device_name - 1; ++i)
+ -	{
+ -	    ch = line[i];
+ -	    if ( isspace (ch) || (ch == ',') || (ch == '\0') ) break;
+ -	    root_device_name[i] = ch;
+ -	}
+ -	return 1;
+ -}
+ -
+ -__setup("root=", root_dev_setup);
+ -
+ -static char * __initdata root_mount_data;
+ -static int __init root_data_setup(char *str)
+ -{
+ -	root_mount_data = str;
+ -	return 1;
+ -}
+ -
+ -static char * __initdata root_fs_names;
+ -static int __init fs_names_setup(char *str)
+ -{
+ -	root_fs_names = str;
+ -	return 1;
+ -}
+ -
+ -__setup("rootflags=", root_data_setup);
+ -__setup("rootfstype=", fs_names_setup);
+ -
+ -static void __init get_fs_names(char *page)
+ -{
+ -	char *s = page;
+ -
+ -	if (root_fs_names) {
+ -		strcpy(page, root_fs_names);
+ -		while (*s++) {
+ -			if (s[-1] == ',')
+ -				s[-1] = '\0';
+ -		}
+ -	} else {
+ -		int len = get_filesystem_list(page);
+ -		char *p, *next;
+ -
+ -		page[len] = '\0';
+ -		for (p = page-1; p; p = next) {
+ -			next = strchr(++p, '\n');
+ -			if (*p++ != '\t')
+ -				continue;
+ -			while ((*s++ = *p++) != '\n')
+ -				;
+ -			s[-1] = '\0';
+ -		}
+ -	}
+ -	*s = '\0';
+ -}
+ -static void __init mount_block_root(char *name, int flags)
+ -{
+ -	char *fs_names = __getname();
+ -	char *p;
+ -
+ -	get_fs_names(fs_names);
+ -retry:
+ -	for (p = fs_names; *p; p += strlen(p)+1) {
+ -		int err = sys_mount(name, "/root", p, flags, root_mount_data);
+ -		switch (err) {
+ -			case 0:
+ -				goto out;
+ -			case -EACCES:
+ -				flags |= MS_RDONLY;
+ -				goto retry;
+ -			case -EINVAL:
+ -				continue;
+ -
+ -		        case -EBUSY:
+ -				continue;
+ -		}
+ -	        /*
+ -		 * Allow the user to distinguish between failed open
+ -		 * and bad superblock on root device.
+ -		 */
+ -		printk ("VFS: Cannot open root device \"%s\" or %s\n",
+ -			root_device_name, kdevname (ROOT_DEV));
+ -		printk ("Please append a correct \"root=\" boot option\n");
+ -		panic("VFS: Unable to mount root fs on %s",
+ -			kdevname(ROOT_DEV));
+ -	}
+ -	panic("VFS: Unable to mount root fs on %s", kdevname(ROOT_DEV));
+ -out:
+ -	putname(fs_names);
+ -	sys_chdir("/root");
+ -	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+ -	printk("VFS: Mounted root (%s filesystem)%s.\n",
+ -		current->fs->pwdmnt->mnt_sb->s_type->name,
+ -		(current->fs->pwdmnt->mnt_sb->s_flags & MS_RDONLY) ? " readonly" : "");
+ -}
+ - 
+ -#ifdef CONFIG_ROOT_NFS
+ -static int __init mount_nfs_root(void)
+ -{
+ -	void *data = nfs_root_data();
+ -
+ -	if (data && sys_mount("/dev/root","/root","nfs",root_mountflags,data) == 0)
+ -		return 1;
+ -	return 0;
+ -}
+ -#endif
+ -
+ -static int __init create_dev(char *name, kdev_t dev, char *devfs_name)
+ -{
+ -	void *handle;
+ -	char path[64];
+ -	int n;
+ -
+ -	sys_unlink(name);
+ -	if (!do_devfs)
+ -		return sys_mknod(name, S_IFBLK|0600, kdev_t_to_nr(dev));
+ -
+ -	handle = devfs_find_handle(NULL, dev ? NULL : devfs_name,
+ -				MAJOR(dev), MINOR(dev), DEVFS_SPECIAL_BLK, 1);
+ -	if (!handle)
+ -		return -1;
+ -	n = devfs_generate_path(handle, path + 5, sizeof (path) - 5);
+ -	if (n < 0)
+ -		return -1;
+ -	return sys_symlink(path + n + 5, name);
+ -}
+ -
+ -#if defined(CONFIG_BLK_DEV_RAM) || defined(CONFIG_BLK_DEV_FD)
+ -static void __init change_floppy(char *fmt, ...)
+ -{
+ -	struct termios termios;
+ -	char buf[80];
+ -	char c;
+ -	int fd;
+ -	va_list args;
+ -	va_start(args, fmt);
+ -	vsprintf(buf, fmt, args);
+ -	va_end(args);
+ -	fd = open("/dev/root", O_RDWR | O_NDELAY, 0);
+ -	if (fd >= 0) {
+ -		sys_ioctl(fd, FDEJECT, 0);
+ -		close(fd);
+ -	}
+ -	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
+ -	fd = open("/dev/console", O_RDWR, 0);
+ -	if (fd >= 0) {
+ -		sys_ioctl(fd, TCGETS, (long)&termios);
+ -		termios.c_lflag &= ~ICANON;
+ -		sys_ioctl(fd, TCSETSF, (long)&termios);
+ -		read(fd, &c, 1);
+ -		termios.c_lflag |= ICANON;
+ -		sys_ioctl(fd, TCSETSF, (long)&termios);
+ -		close(fd);
+ -	}
+ -}
+ -#endif
+ -
+ -#ifdef CONFIG_BLK_DEV_RAM
+ -
+ -int __initdata rd_prompt = 1;	/* 1 = prompt for RAM disk, 0 = don't prompt */
+ -
+ -static int __init prompt_ramdisk(char *str)
+ -{
+ -	rd_prompt = simple_strtol(str,NULL,0) & 1;
+ -	return 1;
+ -}
+ -__setup("prompt_ramdisk=", prompt_ramdisk);
+ -
+ -int __initdata rd_image_start;		/* starting block # of image */
+ -
+ -static int __init ramdisk_start_setup(char *str)
+ -{
+ -	rd_image_start = simple_strtol(str,NULL,0);
+ -	return 1;
+ -}
+ -__setup("ramdisk_start=", ramdisk_start_setup);
+ -
+ -static int __init crd_load(int in_fd, int out_fd);
+ -
+ -/*
+ - * This routine tries to find a RAM disk image to load, and returns the
+ - * number of blocks to read for a non-compressed image, 0 if the image
+ - * is a compressed image, and -1 if an image with the right magic
+ - * numbers could not be found.
+ - *
+ - * We currently check for the following magic numbers:
+ - * 	minix
+ - * 	ext2
+ - *	romfs
+ - *	cramfs
+ - * 	gzip
+ - */
+ -static int __init 
+ -identify_ramdisk_image(int fd, int start_block)
+ -{
+ -	const int size = 512;
+ -	struct minix_super_block *minixsb;
+ -	struct ext2_super_block *ext2sb;
+ -	struct romfs_super_block *romfsb;
+ -	struct cramfs_super *cramfsb;
+ -	int nblocks = -1;
+ -	unsigned char *buf;
+ -
+ -	buf = kmalloc(size, GFP_KERNEL);
+ -	if (buf == 0)
+ -		return -1;
+ -
+ -	minixsb = (struct minix_super_block *) buf;
+ -	ext2sb = (struct ext2_super_block *) buf;
+ -	romfsb = (struct romfs_super_block *) buf;
+ -	cramfsb = (struct cramfs_super *) buf;
+ -	memset(buf, 0xe5, size);
+ -
+ -	/*
+ -	 * Read block 0 to test for gzipped kernel
+ -	 */
+ -	lseek(fd, start_block * BLOCK_SIZE, 0);
+ -	read(fd, buf, size);
+ -
+ -	/*
+ -	 * If it matches the gzip magic numbers, return -1
+ -	 */
+ -	if (buf[0] == 037 && ((buf[1] == 0213) || (buf[1] == 0236))) {
+ -		printk(KERN_NOTICE
+ -		       "RAMDISK: Compressed image found at block %d\n",
+ -		       start_block);
+ -		nblocks = 0;
+ -		goto done;
+ -	}
+ -
+ -	/* romfs is at block zero too */
+ -	if (romfsb->word0 == ROMSB_WORD0 &&
+ -	    romfsb->word1 == ROMSB_WORD1) {
+ -		printk(KERN_NOTICE
+ -		       "RAMDISK: romfs filesystem found at block %d\n",
+ -		       start_block);
+ -		nblocks = (ntohl(romfsb->size)+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+ -		goto done;
+ -	}
+ -
+ -	if (cramfsb->magic == CRAMFS_MAGIC) {
+ -		printk(KERN_NOTICE
+ -		       "RAMDISK: cramfs filesystem found at block %d\n",
+ -		       start_block);
+ -		nblocks = (cramfsb->size + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
+ -		goto done;
+ -	}
+ -
+ -	/*
+ -	 * Read block 1 to test for minix and ext2 superblock
+ -	 */
+ -	lseek(fd, (start_block+1) * BLOCK_SIZE, 0);
+ -	read(fd, buf, size);
+ -
+ -	/* Try minix */
+ -	if (minixsb->s_magic == MINIX_SUPER_MAGIC ||
+ -	    minixsb->s_magic == MINIX_SUPER_MAGIC2) {
+ -		printk(KERN_NOTICE
+ -		       "RAMDISK: Minix filesystem found at block %d\n",
+ -		       start_block);
+ -		nblocks = minixsb->s_nzones << minixsb->s_log_zone_size;
+ -		goto done;
+ -	}
+ -
+ -	/* Try ext2 */
+ -	if (ext2sb->s_magic == cpu_to_le16(EXT2_SUPER_MAGIC)) {
+ -		printk(KERN_NOTICE
+ -		       "RAMDISK: ext2 filesystem found at block %d\n",
+ -		       start_block);
+ -		nblocks = le32_to_cpu(ext2sb->s_blocks_count);
+ -		goto done;
+ -	}
+ -
+ -	printk(KERN_NOTICE
+ -	       "RAMDISK: Couldn't find valid RAM disk image starting at %d.\n",
+ -	       start_block);
+ -	
+ -done:
+ -	lseek(fd, start_block * BLOCK_SIZE, 0);
+ -	kfree(buf);
+ -	return nblocks;
+ -}
+ -#endif
+ -
+ -static int __init rd_load_image(char *from)
+ -{
+ -	int res = 0;
+ -
+ -#ifdef CONFIG_BLK_DEV_RAM
+ -	int in_fd, out_fd;
+ -	unsigned long rd_blocks, devblocks;
+ -	int nblocks, i;
+ -	char *buf;
+ -	unsigned short rotate = 0;
+ -#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC_ISERIES)
+ -	char rotator[4] = { '|' , '/' , '-' , '\\' };
+ -#endif
+ -
+ -	out_fd = open("/dev/ram", O_RDWR, 0);
+ -	if (out_fd < 0)
+ -		goto out;
+ -
+ -	in_fd = open(from, O_RDONLY, 0);
+ -	if (in_fd < 0)
+ -		goto noclose_input;
+ -
+ -	nblocks = identify_ramdisk_image(in_fd, rd_image_start);
+ -	if (nblocks < 0)
+ -		goto done;
+ -
+ -	if (nblocks == 0) {
+ -#ifdef BUILD_CRAMDISK
+ -		if (crd_load(in_fd, out_fd) == 0)
+ -			goto successful_load;
+ -#else
+ -		printk(KERN_NOTICE
+ -		       "RAMDISK: Kernel does not support compressed "
+ -		       "RAM disk images\n");
+ -#endif
+ -		goto done;
+ -	}
+ -
+ -	/*
+ -	 * NOTE NOTE: nblocks suppose that the blocksize is BLOCK_SIZE, so
+ -	 * rd_load_image will work only with filesystem BLOCK_SIZE wide!
+ -	 * So make sure to use 1k blocksize while generating ext2fs
+ -	 * ramdisk-images.
+ -	 */
+ -	if (sys_ioctl(out_fd, BLKGETSIZE, (unsigned long)&rd_blocks) < 0)
+ -		rd_blocks = 0;
+ -	else
+ -		rd_blocks >>= 1;
+ -
+ -	if (nblocks > rd_blocks) {
+ -		printk("RAMDISK: image too big! (%d/%lu blocks)\n",
+ -		       nblocks, rd_blocks);
+ -		goto done;
+ -	}
+ -		
+ -	/*
+ -	 * OK, time to copy in the data
+ -	 */
+ -	buf = kmalloc(BLOCK_SIZE, GFP_KERNEL);
+ -	if (buf == 0) {
+ -		printk(KERN_ERR "RAMDISK: could not allocate buffer\n");
+ -		goto done;
+ -	}
+ -
+ -	if (sys_ioctl(in_fd, BLKGETSIZE, (unsigned long)&devblocks) < 0)
+ -		devblocks = 0;
+ -	else
+ -		devblocks >>= 1;
+ -
+ -	if (strcmp(from, "/dev/initrd") == 0)
+ -		devblocks = nblocks;
+ -
+ -	if (devblocks == 0) {
+ -		printk(KERN_ERR "RAMDISK: could not determine device size\n");
+ -		goto done;
+ -	}
+ -
+ -	printk(KERN_NOTICE "RAMDISK: Loading %d blocks [%ld disk%s] into ram disk... ", 
+ -		nblocks, ((nblocks-1)/devblocks)+1, nblocks>devblocks ? "s" : "");
+ -	for (i=0; i < nblocks; i++) {
+ -		if (i && (i % devblocks == 0)) {
+ -			printk("done disk #%ld.\n", i/devblocks);
+ -			rotate = 0;
+ -			if (close(in_fd)) {
+ -				printk("Error closing the disk.\n");
+ -				goto noclose_input;
+ -			}
+ -			change_floppy("disk #%d", i/devblocks+1);
+ -			in_fd = open(from, O_RDONLY, 0);
+ -			if (in_fd < 0)  {
+ -				printk("Error opening disk.\n");
+ -				goto noclose_input;
+ -			}
+ -			printk("Loading disk #%ld... ", i/devblocks+1);
+ -		}
+ -		read(in_fd, buf, BLOCK_SIZE);
+ -		write(out_fd, buf, BLOCK_SIZE);
+ -#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC_ISERIES)
+ -		if (!(i % 16)) {
+ -			printk("%c\b", rotator[rotate & 0x3]);
+ -			rotate++;
+ -		}
+ -#endif
+ -	}
+ -	printk("done.\n");
+ -	kfree(buf);
+ -
+ -successful_load:
+ -	res = 1;
+ -done:
+ -	close(in_fd);
+ -noclose_input:
+ -	close(out_fd);
+ -out:
+ -	sys_unlink("/dev/ram");
+ -#endif
+ -	return res;
+ -}
+ -
+ -static int __init rd_load_disk(int n)
+ -{
+ -#ifdef CONFIG_BLK_DEV_RAM
+ -	if (rd_prompt)
+ -		change_floppy("root floppy disk to be loaded into RAM disk");
+ -	create_dev("/dev/ram", MKDEV(RAMDISK_MAJOR, n), NULL);
+ -#endif
+ -	return rd_load_image("/dev/root");
+ -}
+ -
+ -#ifdef CONFIG_DEVFS_FS
+ -
+ -static void __init convert_name(char *prefix, char *name, char *p, int part)
+ -{
+ -	int host, bus, target, lun;
+ -	char dest[64];
+ -	char src[64];
+ -	char *base = p - 1;
+ -
+ -	/*  Decode "c#b#t#u#"  */
+ -	if (*p++ != 'c')
+ -		return;
+ -	host = simple_strtol(p, &p, 10);
+ -	if (*p++ != 'b')
+ -		return;
+ -	bus = simple_strtol(p, &p, 10);
+ -	if (*p++ != 't')
+ -		return;
+ -	target = simple_strtol(p, &p, 10);
+ -	if (*p++ != 'u')
+ -		return;
+ -	lun = simple_strtol(p, &p, 10);
+ -	if (!part)
+ -		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d",
+ -				prefix, host, bus, target, lun);
+ -	else if (*p++ == 'p')
+ -		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d/part%s",
+ -				prefix, host, bus, target, lun, p);
+ -	else
+ -		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d/disc",
+ -				prefix, host, bus, target, lun);
+ -	*base = '\0';
+ -	sprintf(src, "/dev/%s", name);
+ -	sys_mkdir(src, 0755);
+ -	*base = '/';
+ -	sprintf(src, "/dev/%s", name);
+ -	sys_symlink(dest, src);
+ -}
+ -
+ -static void __init devfs_make_root(char *name)
+ -{
+ -
+ -	if (!strncmp(name, "sd/", 3))
+ -		convert_name("../scsi", name, name+3, 1);
+ -	else if (!strncmp(name, "sr/", 3))
+ -		convert_name("../scsi", name, name+3, 0);
+ -	else if (!strncmp(name, "ide/hd/", 7))
+ -		convert_name("..", name, name + 7, 1);
+ -	else if (!strncmp(name, "ide/cd/", 7))
+ -		convert_name("..", name, name + 7, 0);
+ -}
+ -#else
+ -static void __init devfs_make_root(char *name)
+ -{
+ -}
+ -#endif
+ -
+ -static void __init mount_root(void)
+ -{
+ -#ifdef CONFIG_ROOT_NFS
+ -       if (MAJOR(ROOT_DEV) == NFS_MAJOR
+ -           && MINOR(ROOT_DEV) == NFS_MINOR) {
+ -		if (mount_nfs_root()) {
+ -			sys_chdir("/root");
+ -			ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+ -			printk("VFS: Mounted root (nfs filesystem).\n");
+ -			return;
+ -		}
+ -		printk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");
+ -		ROOT_DEV = MKDEV(FLOPPY_MAJOR, 0);
+ -	}
+ -#endif
+ -	devfs_make_root(root_device_name);
+ -	create_dev("/dev/root", ROOT_DEV, root_device_name);
+ -#ifdef CONFIG_BLK_DEV_FD
+ -	if (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {
+ -		/* rd_doload is 2 for a dual initrd/ramload setup */
+ -		if (rd_doload==2) {
+ -			if (rd_load_disk(1)) {
+ -				ROOT_DEV = MKDEV(RAMDISK_MAJOR, 1);
+ -				create_dev("/dev/root", ROOT_DEV, NULL);
+ -			}
+ -		} else
+ -			change_floppy("root floppy");
+ -	}
+ -#endif
+ -	mount_block_root("/dev/root", root_mountflags);
+ -}
+ -
+ -#ifdef CONFIG_BLK_DEV_INITRD
+ -static int old_fd, root_fd;
+ -static int do_linuxrc(void * shell)
+ -{
+ -	static char *argv[] = { "linuxrc", NULL, };
+ -	extern char * envp_init[];
+ -
+ -	close(old_fd);
+ -	close(root_fd);
+ -	close(0);
+ -	close(1);
+ -	close(2);
+ -	setsid();
+ -	(void) open("/dev/console",O_RDWR,0);
+ -	(void) dup(0);
+ -	(void) dup(0);
+ -	return execve(shell, argv, envp_init);
+ -}
+ -
+ -#endif
+ -
+ -static void __init handle_initrd(void)
+ -{
+ -#ifdef CONFIG_BLK_DEV_INITRD
+ -	int ram0 = kdev_t_to_nr(MKDEV(RAMDISK_MAJOR,0));
+ -	int error;
+ -	int i, pid;
+ -
+ -	create_dev("/dev/root.old", ram0, NULL);
+ -	/* mount initrd on rootfs' /root */
+ -	mount_block_root("/dev/root.old", root_mountflags & ~MS_RDONLY);
+ -	sys_mkdir("/old", 0700);
+ -	root_fd = open("/", 0, 0);
+ -	old_fd = open("/old", 0, 0);
+ -	/* move initrd over / and chdir/chroot in initrd root */
+ -	sys_chdir("/root");
+ -	sys_mount(".", "/", NULL, MS_MOVE, NULL);
+ -	sys_chroot(".");
+ -	mount_devfs_fs ();
+ -
+ -	pid = kernel_thread(do_linuxrc, "/linuxrc", SIGCHLD);
+ -	if (pid > 0) {
+ -		while (pid != wait(&i))
+ -			yield();
+ -	}
+ -
+ -	/* move initrd to rootfs' /old */
+ -	sys_fchdir(old_fd);
+ -	sys_mount("/", ".", NULL, MS_MOVE, NULL);
+ -	/* switch root and cwd back to / of rootfs */
+ -	sys_fchdir(root_fd);
+ -	sys_chroot(".");
+ -	sys_umount("/old/dev", 0);
+ -	close(old_fd);
+ -	close(root_fd);
+ -
+ -	if (real_root_dev == ram0) {
+ -		sys_chdir("/old");
+ -		return;
+ -	}
+ -
+ -	ROOT_DEV = real_root_dev;
+ -	mount_root();
+ -
+ -	printk(KERN_NOTICE "Trying to move old root to /initrd ... ");
+ -	error = sys_mount("/old", "/root/initrd", NULL, MS_MOVE, NULL);
+ -	if (!error)
+ -		printk("okay\n");
+ -	else {
+ -		int fd = open("/dev/root.old", O_RDWR, 0);
+ -		printk("failed\n");
+ -		printk(KERN_NOTICE "Unmounting old root\n");
+ -		sys_umount("/old", MNT_DETACH);
+ -		printk(KERN_NOTICE "Trying to free ramdisk memory ... ");
+ -		if (fd < 0) {
+ -			error = fd;
+ -		} else {
+ -			error = sys_ioctl(fd, BLKFLSBUF, 0);
+ -			close(fd);
+ -		}
+ -		printk(!error ? "okay\n" : "failed\n");
+ -	}
+ -#endif
+ -}
+ -
+ -static int __init initrd_load(void)
+ -{
+ -#ifdef CONFIG_BLK_DEV_INITRD
+ -	create_dev("/dev/ram", MKDEV(RAMDISK_MAJOR, 0), NULL);
+ -	create_dev("/dev/initrd", MKDEV(RAMDISK_MAJOR, INITRD_MINOR), NULL);
+ -#endif
+ -	return rd_load_image("/dev/initrd");
+ -}
+ -
+ -/*
+ - * Prepare the namespace - decide what/where to mount, load ramdisks, etc.
+ - */
+ -void prepare_namespace(void)
+ -{
+ -	int is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR || MAJOR(ROOT_DEV) == 31;
+ -#ifdef CONFIG_ALL_PPC
+ -	extern void arch_discover_root(void);
+ -	arch_discover_root();
+ -#endif /* CONFIG_ALL_PPC */
+ -#ifdef CONFIG_BLK_DEV_INITRD
+ -	if (!initrd_start)
+ -		mount_initrd = 0;
+ -	real_root_dev = ROOT_DEV;
+ -#endif
+ -	sys_mkdir("/dev", 0700);
+ -	sys_mkdir("/root", 0700);
+ -	sys_mknod("/dev/console", S_IFCHR|0600, MKDEV(TTYAUX_MAJOR, 1));
+ -#ifdef CONFIG_DEVFS_FS
+ -	sys_mount("devfs", "/dev", "devfs", 0, NULL);
+ -	do_devfs = 1;
+ -#endif
+ -
+ -	create_dev("/dev/root", ROOT_DEV, NULL);
+ -	if (mount_initrd) {
+ -		if (initrd_load() && ROOT_DEV != MKDEV(RAMDISK_MAJOR, 0)) {
+ -			handle_initrd();
+ -			goto out;
+ -		}
+ -	} else if (is_floppy && rd_doload && rd_load_disk(0))
+ -		ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+ -	mount_root();
+ -out:
+ -	sys_umount("/dev", 0);
+ -	sys_mount(".", "/", NULL, MS_MOVE, NULL);
+ -	sys_chroot(".");
+ -	mount_devfs_fs ();
+ -}
+ -
+ -#ifdef CONFIG_BLK_DEV_RAM
+ -
+ -#if defined(BUILD_CRAMDISK) && defined(CONFIG_BLK_DEV_RAM)
+ -
+ -/*
+ - * gzip declarations
+ - */
+ -
+ -#define OF(args)  args
+ -
+ -#ifndef memzero
+ -#define memzero(s, n)     memset ((s), 0, (n))
+ -#endif
+ -
+ -typedef unsigned char  uch;
+ -typedef unsigned short ush;
+ -typedef unsigned long  ulg;
+ -
+ -#define INBUFSIZ 4096
+ -#define WSIZE 0x8000    /* window size--must be a power of two, and */
+ -			/*  at least 32K for zip's deflate method */
+ -
+ -static uch *inbuf;
+ -static uch *window;
+ -
+ -static unsigned insize;  /* valid bytes in inbuf */
+ -static unsigned inptr;   /* index of next byte to be processed in inbuf */
+ -static unsigned outcnt;  /* bytes in output buffer */
+ -static int exit_code;
+ -static int unzip_error;
+ -static long bytes_out;
+ -static int crd_infd, crd_outfd;
+ -
+ -#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+ -		
+ -/* Diagnostic functions (stubbed out) */
+ -#define Assert(cond,msg)
+ -#define Trace(x)
+ -#define Tracev(x)
+ -#define Tracevv(x)
+ -#define Tracec(c,x)
+ -#define Tracecv(c,x)
+ -
+ -#define STATIC static
+ -
+ -static int  fill_inbuf(void);
+ -static void flush_window(void);
+ -static void *malloc(int size);
+ -static void free(void *where);
+ -static void error(char *m);
+ -static void gzip_mark(void **);
+ -static void gzip_release(void **);
+ -
+ -#include "../lib/inflate.c"
+ -
+ -static void __init *malloc(int size)
+ -{
+ -	return kmalloc(size, GFP_KERNEL);
+ -}
+ -
+ -static void __init free(void *where)
+ -{
+ -	kfree(where);
+ -}
+ -
+ -static void __init gzip_mark(void **ptr)
+ -{
+ -}
+ -
+ -static void __init gzip_release(void **ptr)
+ -{
+ -}
+ -
+ -
+ -/* ===========================================================================
+ - * Fill the input buffer. This is called only when the buffer is empty
+ - * and at least one byte is really needed.
+ - * Returning -1 does not guarantee that gunzip() will ever return.
+ - */
+ -static int __init fill_inbuf(void)
+ -{
+ -	if (exit_code) return -1;
+ -	
+ -	insize = read(crd_infd, inbuf, INBUFSIZ);
+ -	if (insize == 0) {
+ -		error("RAMDISK: ran out of compressed data\n");
+ -		return -1;
+ -	}
+ -
+ -	inptr = 1;
+ -
+ -	return inbuf[0];
+ -}
+ -
+ -/* ===========================================================================
+ - * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+ - * (Used for the decompressed data only.)
+ - */
+ -static void __init flush_window(void)
+ -{
+ -    ulg c = crc;         /* temporary variable */
+ -    unsigned n, written;
+ -    uch *in, ch;
+ -    
+ -    written = write(crd_outfd, window, outcnt);
+ -    if (written != outcnt && unzip_error == 0) {
+ -	printk(KERN_ERR "RAMDISK: incomplete write (%d != %d), "
+ -	       "only wrote %ld\n", written, outcnt, bytes_out);
+ -	unzip_error = 1;
+ -    }
+ -    in = window;
+ -    for (n = 0; n < outcnt; n++) {
+ -	    ch = *in++;
+ -	    c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+ -    }
+ -    crc = c;
+ -    bytes_out += (ulg)outcnt;
+ -    outcnt = 0;
+ -}
+ -
+ -static void __init error(char *x)
+ -{
+ -	printk(KERN_ERR "%s", x);
+ -	exit_code = 1;
+ -	unzip_error = 1;
+ -}
+ -
+ -static int __init crd_load(int in_fd, int out_fd)
+ -{
+ -	int result;
+ -
+ -	insize = 0;		/* valid bytes in inbuf */
+ -	inptr = 0;		/* index of next byte to be processed in inbuf */
+ -	outcnt = 0;		/* bytes in output buffer */
+ -	exit_code = 0;
+ -	bytes_out = 0;
+ -	crc = (ulg)0xffffffffL; /* shift register contents */
+ -
+ -	crd_infd = in_fd;
+ -	crd_outfd = out_fd;
+ -	inbuf = kmalloc(INBUFSIZ, GFP_KERNEL);
+ -	if (inbuf == 0) {
+ -		printk(KERN_ERR "RAMDISK: Couldn't allocate gzip buffer\n");
+ -		return -1;
+ -	}
+ -	window = kmalloc(WSIZE, GFP_KERNEL);
+ -	if (window == 0) {
+ -		printk(KERN_ERR "RAMDISK: Couldn't allocate gzip window\n");
+ -		kfree(inbuf);
+ -		return -1;
+ -	}
+ -	makecrc();
+ -	result = gunzip();
+ -	if (unzip_error)
+ -		result = 1;
+ -	kfree(inbuf);
+ -	kfree(window);
+ -	return result;
+ -}
+ -
+ -#endif  /* BUILD_CRAMDISK && CONFIG_BLK_DEV_RAM */
+ -#endif  /* CONFIG_BLK_DEV_RAM */
diff -crBN linux-2.4.27/init/main.c linux-2.4.27-w/init/main.c
*** linux-2.4.27/init/main.c	2003-11-28 10:26:21.000000000 -0800
--- linux-2.4.27-w/init/main.c	2013-01-22 23:03:30.511023654 -0800
***************
*** 164,169 ****
--- 164,172 ----
  
  void __init calibrate_delay(void)
  {
+ 
+ /* Bypassed bogo mips calculation */
+ #if 0
  	unsigned long ticks, loopbit;
  	int lps_precision = LPS_PREC;
  
***************
*** 201,206 ****
--- 204,216 ----
  	printk("%lu.%02lu BogoMIPS\n",
  		loops_per_jiffy/(500000/HZ),
  		(loops_per_jiffy/(5000/HZ)) % 100);
+ #else
+         /* Correct value for 40MHz */
+ 	loops_per_jiffy = 99550;
+ 	printk("%lu.%02lu BogoMIPS (preset value used)\n",
+ 		loops_per_jiffy/(500000/HZ),
+ 		(loops_per_jiffy/(5000/HZ)) % 100);
+ #endif
  }
  
  static int __init debug_kernel(char *str)
diff -crBN linux-2.4.27/init/tmp.c linux-2.4.27-w/init/tmp.c
*** linux-2.4.27/init/tmp.c	1969-12-31 16:00:00.000000000 -0800
--- linux-2.4.27-w/init/tmp.c	2013-01-22 23:03:30.511023654 -0800
***************
*** 0 ****
--- 1,1716 ----
+ #define __KERNEL_SYSCALLS__
+ #include <linux/config.h>
+ #include <linux/slab.h>
+ #include <linux/devfs_fs_kernel.h>
+ #include <linux/unistd.h>
+ #include <linux/ctype.h>
+ #include <linux/blk.h>
+ #include <linux/fd.h>
+ #include <linux/tty.h>
+ #include <linux/init.h>
+ 
+ #include <linux/nfs_fs.h>
+ #include <linux/nfs_fs_sb.h>
+ #include <linux/nfs_mount.h>
+ #include <linux/minix_fs.h>
+ #include <linux/ext2_fs.h>
+ #include <linux/romfs_fs.h>
+ #include <linux/cramfs_fs.h>
+ 
+ #define BUILD_CRAMDISK
+ 
+ extern int get_filesystem_list(char * buf);
+ 
+ extern asmlinkage long sys_mount(char *dev_name, char *dir_name, char *type,
+ 	 unsigned long flags, void *data);
+ extern asmlinkage long sys_mkdir(const char *name, int mode);
+ extern asmlinkage long sys_chdir(const char *name);
+ extern asmlinkage long sys_fchdir(int fd);
+ extern asmlinkage long sys_chroot(const char *name);
+ extern asmlinkage long sys_unlink(const char *name);
+ extern asmlinkage long sys_symlink(const char *old, const char *new);
+ extern asmlinkage long sys_mknod(const char *name, int mode, dev_t dev);
+ extern asmlinkage long sys_umount(char *name, int flags);
+ extern asmlinkage long sys_ioctl(int fd, int cmd, unsigned long arg);
+ 
+ #ifdef CONFIG_BLK_DEV_INITRD
+ unsigned int real_root_dev;	/* do_proc_dointvec cannot handle kdev_t */
+ static int __initdata mount_initrd = 1;
+ 
+ static int __init no_initrd(char *str)
+ {
+ 	mount_initrd = 0;
+ 	return 1;
+ }
+ 
+ __setup("noinitrd", no_initrd);
+ #else
+ static int __initdata mount_initrd = 0;
+ #endif
+ 
+ int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
+ 
+ int root_mountflags = MS_RDONLY | MS_VERBOSE;
+ static char root_device_name[64];
+ 
+ /* this is initialized in init/main.c */
+ kdev_t ROOT_DEV;
+ 
+ static int do_devfs = 0;
+ 
+ static int __init load_ramdisk(char *str)
+ {
+ 	rd_doload = simple_strtol(str,NULL,0) & 3;
+ 	return 1;
+ }
+ __setup("load_ramdisk=", load_ramdisk);
+ 
+ static int __init readonly(char *str)
+ {
+ 	if (*str)
+ 		return 0;
+ 	root_mountflags |= MS_RDONLY;
+ 	return 1;
+ }
+ 
+ static int __init readwrite(char *str)
+ {
+ 	if (*str)
+ 		return 0;
+ 	root_mountflags &= ~MS_RDONLY;
+ 	return 1;
+ }
+ 
+ __setup("ro", readonly);
+ __setup("rw", readwrite);
+ 
+ static struct dev_name_struct {
+ 	const char *name;
+ 	const int num;
+ } root_dev_names[] __initdata = {
+ 	{ "nfs",     MKDEV(NFS_MAJOR, NFS_MINOR) },
+ 	{ "hda",     0x0300 },
+ 	{ "hdb",     0x0340 },
+ 	{ "loop",    0x0700 },
+ 	{ "hdc",     0x1600 },
+ 	{ "hdd",     0x1640 },
+ 	{ "hde",     0x2100 },
+ 	{ "hdf",     0x2140 },
+ 	{ "hdg",     0x2200 },
+ 	{ "hdh",     0x2240 },
+ 	{ "hdi",     0x3800 },
+ 	{ "hdj",     0x3840 },
+ 	{ "hdk",     0x3900 },
+ 	{ "hdl",     0x3940 },
+ 	{ "hdm",     0x5800 },
+ 	{ "hdn",     0x5840 },
+ 	{ "hdo",     0x5900 },
+ 	{ "hdp",     0x5940 },
+ 	{ "hdq",     0x5A00 },
+ 	{ "hdr",     0x5A40 },
+ 	{ "hds",     0x5B00 },
+ 	{ "hdt",     0x5B40 },
+ 	{ "sda",     0x0800 },
+ 	{ "sdb",     0x0810 },
+ 	{ "sdc",     0x0820 },
+ 	{ "sdd",     0x0830 },
+ 	{ "sde",     0x0840 },
+ 	{ "sdf",     0x0850 },
+ 	{ "sdg",     0x0860 },
+ 	{ "sdh",     0x0870 },
+ 	{ "sdi",     0x0880 },
+ 	{ "sdj",     0x0890 },
+ 	{ "sdk",     0x08a0 },
+ 	{ "sdl",     0x08b0 },
+ 	{ "sdm",     0x08c0 },
+ 	{ "sdn",     0x08d0 },
+ 	{ "sdo",     0x08e0 },
+ 	{ "sdp",     0x08f0 },
+ 	{ "ada",     0x1c00 },
+ 	{ "adb",     0x1c10 },
+ 	{ "adc",     0x1c20 },
+ 	{ "add",     0x1c30 },
+ 	{ "ade",     0x1c40 },
+ 	{ "fd",      0x0200 },
+ 	{ "md",      0x0900 },	     
+ 	{ "xda",     0x0d00 },
+ 	{ "xdb",     0x0d40 },
+ 	{ "ram",     0x0100 },
+ 	{ "scd",     0x0b00 },
+ 	{ "mcd",     0x1700 },
+ 	{ "cdu535",  0x1800 },
+ 	{ "sonycd",  0x1800 },
+ 	{ "aztcd",   0x1d00 },
+ 	{ "cm206cd", 0x2000 },
+ 	{ "gscd",    0x1000 },
+ 	{ "sbpcd",   0x1900 },
+ 	{ "eda",     0x2400 },
+ 	{ "edb",     0x2440 },
+ 	{ "pda",	0x2d00 },
+ 	{ "pdb",	0x2d10 },
+ 	{ "pdc",	0x2d20 },
+ 	{ "pdd",	0x2d30 },
+ 	{ "pcd",	0x2e00 },
+ 	{ "pf",		0x2f00 },
+ 	{ "apblock", APBLOCK_MAJOR << 8},
+ 	{ "ddv", DDV_MAJOR << 8},
+ 	{ "jsfd",    JSFD_MAJOR << 8},
+ #if defined(CONFIG_ARCH_S390)
+ 	{ "dasda", (DASD_MAJOR << MINORBITS) },
+ 	{ "dasdb", (DASD_MAJOR << MINORBITS) + (1 << 2) },
+ 	{ "dasdc", (DASD_MAJOR << MINORBITS) + (2 << 2) },
+ 	{ "dasdd", (DASD_MAJOR << MINORBITS) + (3 << 2) },
+ 	{ "dasde", (DASD_MAJOR << MINORBITS) + (4 << 2) },
+ 	{ "dasdf", (DASD_MAJOR << MINORBITS) + (5 << 2) },
+ 	{ "dasdg", (DASD_MAJOR << MINORBITS) + (6 << 2) },
+ 	{ "dasdh", (DASD_MAJOR << MINORBITS) + (7 << 2) },
+ #endif
+ 	{ "ida/c0d0p",0x4800 },
+ 	{ "ida/c0d1p",0x4810 },
+ 	{ "ida/c0d2p",0x4820 },
+ 	{ "ida/c0d3p",0x4830 },
+ 	{ "ida/c0d4p",0x4840 },
+ 	{ "ida/c0d5p",0x4850 },
+ 	{ "ida/c0d6p",0x4860 },
+ 	{ "ida/c0d7p",0x4870 },
+ 	{ "ida/c0d8p",0x4880 },
+ 	{ "ida/c0d9p",0x4890 },
+ 	{ "ida/c0d10p",0x48A0 },
+ 	{ "ida/c0d11p",0x48B0 },
+ 	{ "ida/c0d12p",0x48C0 },
+ 	{ "ida/c0d13p",0x48D0 },
+ 	{ "ida/c0d14p",0x48E0 },
+ 	{ "ida/c0d15p",0x48F0 },
+ 	{ "ida/c1d0p",0x4900 },
+ 	{ "ida/c2d0p",0x4A00 },
+ 	{ "ida/c3d0p",0x4B00 },
+ 	{ "ida/c4d0p",0x4C00 },
+ 	{ "ida/c5d0p",0x4D00 },
+ 	{ "ida/c6d0p",0x4E00 },
+ 	{ "ida/c7d0p",0x4F00 }, 
+ 	{ "cciss/c0d0p",0x6800 },
+ 	{ "cciss/c0d1p",0x6810 },
+ 	{ "cciss/c0d2p",0x6820 },
+ 	{ "cciss/c0d3p",0x6830 },
+ 	{ "cciss/c0d4p",0x6840 },
+ 	{ "cciss/c0d5p",0x6850 },
+ 	{ "cciss/c0d6p",0x6860 },
+ 	{ "cciss/c0d7p",0x6870 },
+ 	{ "cciss/c0d8p",0x6880 },
+ 	{ "cciss/c0d9p",0x6890 },
+ 	{ "cciss/c0d10p",0x68A0 },
+ 	{ "cciss/c0d11p",0x68B0 },
+ 	{ "cciss/c0d12p",0x68C0 },
+ 	{ "cciss/c0d13p",0x68D0 },
+ 	{ "cciss/c0d14p",0x68E0 },
+ 	{ "cciss/c0d15p",0x68F0 },
+ 	{ "cciss/c1d0p",0x6900 },
+ 	{ "cciss/c2d0p",0x6A00 },
+ 	{ "cciss/c3d0p",0x6B00 },
+ 	{ "cciss/c4d0p",0x6C00 },
+ 	{ "cciss/c5d0p",0x6D00 },
+ 	{ "cciss/c6d0p",0x6E00 },
+ 	{ "cciss/c7d0p",0x6F00 },
+ 	{ "ataraid/d0p",0x7200 },
+ 	{ "ataraid/d1p",0x7210 },
+ 	{ "ataraid/d2p",0x7220 },
+ 	{ "ataraid/d3p",0x7230 },
+ 	{ "ataraid/d4p",0x7240 },
+ 	{ "ataraid/d5p",0x7250 },
+ 	{ "ataraid/d6p",0x7260 },
+ 	{ "ataraid/d7p",0x7270 },
+ 	{ "ataraid/d8p",0x7280 },
+ 	{ "ataraid/d9p",0x7290 },
+ 	{ "ataraid/d10p",0x72A0 },
+ 	{ "ataraid/d11p",0x72B0 },
+ 	{ "ataraid/d12p",0x72C0 },
+ 	{ "ataraid/d13p",0x72D0 },
+ 	{ "ataraid/d14p",0x72E0 },
+ 	{ "ataraid/d15p",0x72F0 },
+         { "rd/c0d0p",0x3000 },
+         { "rd/c0d0p1",0x3001 },
+         { "rd/c0d0p2",0x3002 },
+         { "rd/c0d0p3",0x3003 },
+         { "rd/c0d0p4",0x3004 },
+         { "rd/c0d0p5",0x3005 },
+         { "rd/c0d0p6",0x3006 },
+         { "rd/c0d0p7",0x3007 },
+         { "rd/c0d0p8",0x3008 },
+         { "rd/c0d1p",0x3008 },
+         { "rd/c0d1p1",0x3009 },
+         { "rd/c0d1p2",0x300a },
+         { "rd/c0d1p3",0x300b },
+         { "rd/c0d1p4",0x300c },
+         { "rd/c0d1p5",0x300d },
+         { "rd/c0d1p6",0x300e },
+         { "rd/c0d1p7",0x300f },
+         { "rd/c0d1p8",0x3010 },
+ 	{ "nftla", 0x5d00 },
+ 	{ "nftlb", 0x5d10 },
+ 	{ "nftlc", 0x5d20 },
+ 	{ "nftld", 0x5d30 },
+ 	{ "ftla", 0x2c00 },
+ 	{ "ftlb", 0x2c08 },
+ 	{ "ftlc", 0x2c10 },
+ 	{ "ftld", 0x2c18 },
+ 	{ "mtdblock", 0x1f00 },
+ 	{ "nb", 0x2b00 },
+ 	{ NULL, 0 }
+ };
+ 
+ kdev_t __init name_to_kdev_t(char *line)
+ {
+ 	int base = 0, offs;
+ 	char *end;
+ 
+ 	if (strncmp(line,"/dev/",5) == 0) {
+ 		struct dev_name_struct *dev = root_dev_names;
+ 		line += 5;
+ 		do {
+ 			int len = strlen(dev->name);
+ 			if (strncmp(line,dev->name,len) == 0) {
+ 				line += len;
+ 				base = dev->num;
+ 				break;
+ 			}
+ 			dev++;
+ 		} while (dev->name);
+ 	}
+ 	offs = simple_strtoul(line, &end, base?10:16);
+ 	if (*end)
+ 		offs = 0;
+ 	return to_kdev_t(base + offs);
+ }
+ 
+ static int __init root_dev_setup(char *line)
+ {
+ 	int i;
+ 	char ch;
+ 
+ 	ROOT_DEV = name_to_kdev_t(line);
+ 	memset (root_device_name, 0, sizeof root_device_name);
+ 	if (strncmp (line, "/dev/", 5) == 0) line += 5;
+ 	for (i = 0; i < sizeof root_device_name - 1; ++i)
+ 	{
+ 	    ch = line[i];
+ 	    if ( isspace (ch) || (ch == ',') || (ch == '\0') ) break;
+ 	    root_device_name[i] = ch;
+ 	}
+ 	return 1;
+ }
+ 
+ __setup("root=", root_dev_setup);
+ 
+ static char * __initdata root_mount_data;
+ static int __init root_data_setup(char *str)
+ {
+ 	root_mount_data = str;
+ 	return 1;
+ }
+ 
+ static char * __initdata root_fs_names;
+ static int __init fs_names_setup(char *str)
+ {
+ 	root_fs_names = str;
+ 	return 1;
+ }
+ 
+ __setup("rootflags=", root_data_setup);
+ __setup("rootfstype=", fs_names_setup);
+ 
+ static void __init get_fs_names(char *page)
+ {
+ 	char *s = page;
+ 
+ 	if (root_fs_names) {
+ 		strcpy(page, root_fs_names);
+ 		while (*s++) {
+ 			if (s[-1] == ',')
+ 				s[-1] = '\0';
+ 		}
+ 	} else {
+ 		int len = get_filesystem_list(page);
+ 		char *p, *next;
+ 
+ 		page[len] = '\0';
+ 		for (p = page-1; p; p = next) {
+ 			next = strchr(++p, '\n');
+ 			if (*p++ != '\t')
+ 				continue;
+ 			while ((*s++ = *p++) != '\n')
+ 				;
+ 			s[-1] = '\0';
+ 		}
+ 	}
+ 	*s = '\0';
+ }
+ static void __init mount_block_root(char *name, int flags)
+ {
+ 	char *fs_names = __getname();
+ 	char *p;
+ 
+ 	get_fs_names(fs_names);
+ retry:
+ 	for (p = fs_names; *p; p += strlen(p)+1) {
+ 		int err = sys_mount(name, "/root", p, flags, root_mount_data);
+ 		switch (err) {
+ 			case 0:
+ 				goto out;
+ 			case -EACCES:
+ 				flags |= MS_RDONLY;
+ 				goto retry;
+ 			case -EINVAL:
+ 		        case -EBUSY:
+ 				continue;
+ 		}
+ 	        /*
+ 		 * Allow the user to distinguish between failed open
+ 		 * and bad superblock on root device.
+ 		 */
+ 		printk ("VFS: Cannot open root device \"%s\" or %s\n",
+ 			root_device_name, kdevname (ROOT_DEV));
+ 		printk ("Please append a correct \"root=\" boot option\n");
+ 		panic("VFS: Unable to mount root fs on %s",
+ 			kdevname(ROOT_DEV));
+ 	}
+ 	panic("VFS: Unable to mount root fs on %s", kdevname(ROOT_DEV));
+ out:
+ 	putname(fs_names);
+ 	sys_chdir("/root");
+ 	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+ 	printk("VFS: Mounted root (%s filesystem)%s.\n",
+ 		current->fs->pwdmnt->mnt_sb->s_type->name,
+ 		(current->fs->pwdmnt->mnt_sb->s_flags & MS_RDONLY) ? " readonly" : "");
+ }
+  
+ #ifdef CONFIG_ROOT_NFS
+ static int __init mount_nfs_root(void)
+ {
+ 	void *data = nfs_root_data();
+ 
+ 	if (data && sys_mount("/dev/root","/root","nfs",root_mountflags,data) == 0)
+ 		return 1;
+ 	return 0;
+ }
+ #endif
+ 
+ static int __init create_dev(char *name, kdev_t dev, char *devfs_name)
+ {
+ 	void *handle;
+ 	char path[64];
+ 	int n;
+ 
+ 	sys_unlink(name);
+ 	if (!do_devfs)
+ 		return sys_mknod(name, S_IFBLK|0600, kdev_t_to_nr(dev));
+ 
+ 	handle = devfs_find_handle(NULL, dev ? NULL : devfs_name,
+ 				MAJOR(dev), MINOR(dev), DEVFS_SPECIAL_BLK, 1);
+ 	if (!handle)
+ 		return -1;
+ 	n = devfs_generate_path(handle, path + 5, sizeof (path) - 5);
+ 	if (n < 0)
+ 		return -1;
+ 	return sys_symlink(path + n + 5, name);
+ }
+ 
+ #if defined(CONFIG_BLK_DEV_RAM) || defined(CONFIG_BLK_DEV_FD)
+ static void __init change_floppy(char *fmt, ...)
+ {
+ 	struct termios termios;
+ 	char buf[80];
+ 	char c;
+ 	int fd;
+ 	va_list args;
+ 	va_start(args, fmt);
+ 	vsprintf(buf, fmt, args);
+ 	va_end(args);
+ 	fd = open("/dev/root", O_RDWR | O_NDELAY, 0);
+ 	if (fd >= 0) {
+ 		sys_ioctl(fd, FDEJECT, 0);
+ 		close(fd);
+ 	}
+ 	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
+ 	fd = open("/dev/console", O_RDWR, 0);
+ 	if (fd >= 0) {
+ 		sys_ioctl(fd, TCGETS, (long)&termios);
+ 		termios.c_lflag &= ~ICANON;
+ 		sys_ioctl(fd, TCSETSF, (long)&termios);
+ 		read(fd, &c, 1);
+ 		termios.c_lflag |= ICANON;
+ 		sys_ioctl(fd, TCSETSF, (long)&termios);
+ 		close(fd);
+ 	}
+ }
+ #endif
+ 
+ #ifdef CONFIG_BLK_DEV_RAM
+ 
+ int __initdata rd_prompt = 1;	/* 1 = prompt for RAM disk, 0 = don't prompt */
+ 
+ static int __init prompt_ramdisk(char *str)
+ {
+ 	rd_prompt = simple_strtol(str,NULL,0) & 1;
+ 	return 1;
+ }
+ __setup("prompt_ramdisk=", prompt_ramdisk);
+ 
+ int __initdata rd_image_start;		/* starting block # of image */
+ 
+ static int __init ramdisk_start_setup(char *str)
+ {
+ 	rd_image_start = simple_strtol(str,NULL,0);
+ 	return 1;
+ }
+ __setup("ramdisk_start=", ramdisk_start_setup);
+ 
+ static int __init crd_load(int in_fd, int out_fd);
+ 
+ /*
+  * This routine tries to find a RAM disk image to load, and returns the
+  * number of blocks to read for a non-compressed image, 0 if the image
+  * is a compressed image, and -1 if an image with the right magic
+  * numbers could not be found.
+  *
+  * We currently check for the following magic numbers:
+  * 	minix
+  * 	ext2
+  *	romfs
+  *	cramfs
+  * 	gzip
+  */
+ static int __init 
+ identify_ramdisk_image(int fd, int start_block)
+ {
+ 	const int size = 512;
+ 	struct minix_super_block *minixsb;
+ 	struct ext2_super_block *ext2sb;
+ 	struct romfs_super_block *romfsb;
+ 	struct cramfs_super *cramfsb;
+ 	int nblocks = -1;
+ 	unsigned char *buf;
+ 
+ 	buf = kmalloc(size, GFP_KERNEL);
+ 	if (buf == 0)
+ 		return -1;
+ 
+ 	minixsb = (struct minix_super_block *) buf;
+ 	ext2sb = (struct ext2_super_block *) buf;
+ 	romfsb = (struct romfs_super_block *) buf;
+ 	cramfsb = (struct cramfs_super *) buf;
+ 	memset(buf, 0xe5, size);
+ 
+ 	/*
+ 	 * Read block 0 to test for gzipped kernel
+ 	 */
+ 	lseek(fd, start_block * BLOCK_SIZE, 0);
+ 	read(fd, buf, size);
+ 
+ 	/*
+ 	 * If it matches the gzip magic numbers, return -1
+ 	 */
+ 	if (buf[0] == 037 && ((buf[1] == 0213) || (buf[1] == 0236))) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: Compressed image found at block %d\n",
+ 		       start_block);
+ 		nblocks = 0;
+ 		goto done;
+ 	}
+ 
+ 	/* romfs is at block zero too */
+ 	if (romfsb->word0 == ROMSB_WORD0 &&
+ 	    romfsb->word1 == ROMSB_WORD1) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: romfs filesystem found at block %d\n",
+ 		       start_block);
+ 		nblocks = (ntohl(romfsb->size)+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+ 		goto done;
+ 	}
+ 
+ 	if (cramfsb->magic == CRAMFS_MAGIC) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: cramfs filesystem found at block %d\n",
+ 		       start_block);
+ 		nblocks = (cramfsb->size + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
+ 		goto done;
+ 	}
+ 
+ 	/*
+ 	 * Read block 1 to test for minix and ext2 superblock
+ 	 */
+ 	lseek(fd, (start_block+1) * BLOCK_SIZE, 0);
+ 	read(fd, buf, size);
+ 
+ 	/* Try minix */
+ 	if (minixsb->s_magic == MINIX_SUPER_MAGIC ||
+ 	    minixsb->s_magic == MINIX_SUPER_MAGIC2) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: Minix filesystem found at block %d\n",
+ 		       start_block);
+ 		nblocks = minixsb->s_nzones << minixsb->s_log_zone_size;
+ 		goto done;
+ 	}
+ 
+ 	/* Try ext2 */
+ 	if (ext2sb->s_magic == cpu_to_le16(EXT2_SUPER_MAGIC)) {
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: ext2 filesystem found at block %d\n",
+ 		       start_block);
+ 		nblocks = le32_to_cpu(ext2sb->s_blocks_count);
+ 		goto done;
+ 	}
+ 
+ 	printk(KERN_NOTICE
+ 	       "RAMDISK: Couldn't find valid RAM disk image starting at %d.\n",
+ 	       start_block);
+ 	
+ done:
+ 	lseek(fd, start_block * BLOCK_SIZE, 0);
+ 	kfree(buf);
+ 	return nblocks;
+ }
+ #endif
+ 
+ static int __init rd_load_image(char *from)
+ {
+ 	int res = 0;
+ 
+ #ifdef CONFIG_BLK_DEV_RAM
+ 	int in_fd, out_fd;
+ 	unsigned long rd_blocks, devblocks;
+ 	int nblocks, i;
+ 	char *buf;
+ 	unsigned short rotate = 0;
+ #if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC_ISERIES)
+ 	char rotator[4] = { '|' , '/' , '-' , '\\' };
+ #endif
+ 
+ 	out_fd = open("/dev/ram", O_RDWR, 0);
+ 	if (out_fd < 0)
+ 		goto out;
+ 
+ 	in_fd = open(from, O_RDONLY, 0);
+ 	if (in_fd < 0)
+ 		goto noclose_input;
+ 
+ 	nblocks = identify_ramdisk_image(in_fd, rd_image_start);
+ 	if (nblocks < 0)
+ 		goto done;
+ 
+ 	if (nblocks == 0) {
+ #ifdef BUILD_CRAMDISK
+ 		if (crd_load(in_fd, out_fd) == 0)
+ 			goto successful_load;
+ #else
+ 		printk(KERN_NOTICE
+ 		       "RAMDISK: Kernel does not support compressed "
+ 		       "RAM disk images\n");
+ #endif
+ 		goto done;
+ 	}
+ 
+ 	/*
+ 	 * NOTE NOTE: nblocks suppose that the blocksize is BLOCK_SIZE, so
+ 	 * rd_load_image will work only with filesystem BLOCK_SIZE wide!
+ 	 * So make sure to use 1k blocksize while generating ext2fs
+ 	 * ramdisk-images.
+ 	 */
+ 	if (sys_ioctl(out_fd, BLKGETSIZE, (unsigned long)&rd_blocks) < 0)
+ 		rd_blocks = 0;
+ 	else
+ 		rd_blocks >>= 1;
+ 
+ 	if (nblocks > rd_blocks) {
+ 		printk("RAMDISK: image too big! (%d/%lu blocks)\n",
+ 		       nblocks, rd_blocks);
+ 		goto done;
+ 	}
+ 		
+ 	/*
+ 	 * OK, time to copy in the data
+ 	 */
+ 	buf = kmalloc(BLOCK_SIZE, GFP_KERNEL);
+ 	if (buf == 0) {
+ 		printk(KERN_ERR "RAMDISK: could not allocate buffer\n");
+ 		goto done;
+ 	}
+ 
+ 	if (sys_ioctl(in_fd, BLKGETSIZE, (unsigned long)&devblocks) < 0)
+ 		devblocks = 0;
+ 	else
+ 		devblocks >>= 1;
+ 
+ 	if (strcmp(from, "/dev/initrd") == 0)
+ 		devblocks = nblocks;
+ 
+ 	if (devblocks == 0) {
+ 		printk(KERN_ERR "RAMDISK: could not determine device size\n");
+ 		goto done;
+ 	}
+ 
+ 	printk(KERN_NOTICE "RAMDISK: Loading %d blocks [%ld disk%s] into ram disk... ", 
+ 		nblocks, ((nblocks-1)/devblocks)+1, nblocks>devblocks ? "s" : "");
+ 	for (i=0; i < nblocks; i++) {
+ 		if (i && (i % devblocks == 0)) {
+ 			printk("done disk #%ld.\n", i/devblocks);
+ 			rotate = 0;
+ 			if (close(in_fd)) {
+ 				printk("Error closing the disk.\n");
+ 				goto noclose_input;
+ 			}
+ 			change_floppy("disk #%d", i/devblocks+1);
+ 			in_fd = open(from, O_RDONLY, 0);
+ 			if (in_fd < 0)  {
+ 				printk("Error opening disk.\n");
+ 				goto noclose_input;
+ 			}
+ 			printk("Loading disk #%ld... ", i/devblocks+1);
+ 		}
+ 		read(in_fd, buf, BLOCK_SIZE);
+ 		write(out_fd, buf, BLOCK_SIZE);
+ #if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC_ISERIES)
+ 		if (!(i % 16)) {
+ 			printk("%c\b", rotator[rotate & 0x3]);
+ 			rotate++;
+ 		}
+ #endif
+ 	}
+ 	printk("done.\n");
+ 	kfree(buf);
+ 
+ successful_load:
+ 	res = 1;
+ done:
+ 	close(in_fd);
+ noclose_input:
+ 	close(out_fd);
+ out:
+ 	sys_unlink("/dev/ram");
+ #endif
+ 	return res;
+ }
+ 
+ static int __init rd_load_disk(int n)
+ {
+ #ifdef CONFIG_BLK_DEV_RAM
+ 	if (rd_prompt)
+ 		change_floppy("root floppy disk to be loaded into RAM disk");
+ 	create_dev("/dev/ram", MKDEV(RAMDISK_MAJOR, n), NULL);
+ #endif
+ 	return rd_load_image("/dev/root");
+ }
+ 
+ #ifdef CONFIG_DEVFS_FS
+ 
+ static void __init convert_name(char *prefix, char *name, char *p, int part)
+ {
+ 	int host, bus, target, lun;
+ 	char dest[64];
+ 	char src[64];
+ 	char *base = p - 1;
+ 
+ 	/*  Decode "c#b#t#u#"  */
+ 	if (*p++ != 'c')
+ 		return;
+ 	host = simple_strtol(p, &p, 10);
+ 	if (*p++ != 'b')
+ 		return;
+ 	bus = simple_strtol(p, &p, 10);
+ 	if (*p++ != 't')
+ 		return;
+ 	target = simple_strtol(p, &p, 10);
+ 	if (*p++ != 'u')
+ 		return;
+ 	lun = simple_strtol(p, &p, 10);
+ 	if (!part)
+ 		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d",
+ 				prefix, host, bus, target, lun);
+ 	else if (*p++ == 'p')
+ 		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d/part%s",
+ 				prefix, host, bus, target, lun, p);
+ 	else
+ 		sprintf(dest, "%s/host%d/bus%d/target%d/lun%d/disc",
+ 				prefix, host, bus, target, lun);
+ 	*base = '\0';
+ 	sprintf(src, "/dev/%s", name);
+ 	sys_mkdir(src, 0755);
+ 	*base = '/';
+ 	sprintf(src, "/dev/%s", name);
+ 	sys_symlink(dest, src);
+ }
+ 
+ static void __init devfs_make_root(char *name)
+ {
+ 
+ 	if (!strncmp(name, "sd/", 3))
+ 		convert_name("../scsi", name, name+3, 1);
+ 	else if (!strncmp(name, "sr/", 3))
+ 		convert_name("../scsi", name, name+3, 0);
+ 	else if (!strncmp(name, "ide/hd/", 7))
+ 		convert_name("..", name, name + 7, 1);
+ 	else if (!strncmp(name, "ide/cd/", 7))
+ 		convert_name("..", name, name + 7, 0);
+ }
+ #else
+ static void __init devfs_make_root(char *name)
+ {
+ }
+ #endif
+ 
+ static void __init mount_root(void)
+ {
+ #ifdef CONFIG_ROOT_NFS
+        if (MAJOR(ROOT_DEV) == NFS_MAJOR
+            && MINOR(ROOT_DEV) == NFS_MINOR) {
+ 		if (mount_nfs_root()) {
+ 			sys_chdir("/root");
+ 			ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+ 			printk("VFS: Mounted root (nfs filesystem).\n");
+ 			return;
+ 		}
+ 		printk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");
+ 		ROOT_DEV = MKDEV(FLOPPY_MAJOR, 0);
+ 	}
+ #endif
+ 	devfs_make_root(root_device_name);
+ 	create_dev("/dev/root", ROOT_DEV, root_device_name);
+ #ifdef CONFIG_BLK_DEV_FD
+ 	if (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {
+ 		/* rd_doload is 2 for a dual initrd/ramload setup */
+ 		if (rd_doload==2) {
+ 			if (rd_load_disk(1)) {
+ 				ROOT_DEV = MKDEV(RAMDISK_MAJOR, 1);
+ 				create_dev("/dev/root", ROOT_DEV, NULL);
+ 			}
+ 		} else
+ 			change_floppy("root floppy");
+ 	}
+ #endif
+ 	mount_block_root("/dev/root", root_mountflags);
+ }
+ 
+ #ifdef CONFIG_BLK_DEV_INITRD
+ static int old_fd, root_fd;
+ static int do_linuxrc(void * shell)
+ {
+ 	static char *argv[] = { "linuxrc", NULL, };
+ 	extern char * envp_init[];
+ 
+ 	close(old_fd);
+ 	close(root_fd);
+ 	close(0);
+ 	close(1);
+ 	close(2);
+ 	setsid();
+ 	(void) open("/dev/console",O_RDWR,0);
+ 	(void) dup(0);
+ 	(void) dup(0);
+ 	return execve(shell, argv, envp_init);
+ }
+ 
+ #endif
+ 
+ static void __init handle_initrd(void)
+ {
+ #ifdef CONFIG_BLK_DEV_INITRD
+ 	int ram0 = kdev_t_to_nr(MKDEV(RAMDISK_MAJOR,0));
+ 	int error;
+ 	int i, pid;
+ 
+ 	create_dev("/dev/root.old", ram0, NULL);
+ 	/* mount initrd on rootfs' /root */
+ 	mount_block_root("/dev/root.old", root_mountflags & ~MS_RDONLY);
+ 	sys_mkdir("/old", 0700);
+ 	root_fd = open("/", 0, 0);
+ 	old_fd = open("/old", 0, 0);
+ 	/* move initrd over / and chdir/chroot in initrd root */
+ 	sys_chdir("/root");
+ 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
+ 	sys_chroot(".");
+ 	mount_devfs_fs ();
+ 
+ 	pid = kernel_thread(do_linuxrc, "/linuxrc", SIGCHLD);
+ 	if (pid > 0) {
+ 		while (pid != wait(&i))
+ 			yield();
+ 	}
+ 
+ 	/* move initrd to rootfs' /old */
+ 	sys_fchdir(old_fd);
+ 	sys_mount("/", ".", NULL, MS_MOVE, NULL);
+ 	/* switch root and cwd back to / of rootfs */
+ 	sys_fchdir(root_fd);
+ 	sys_chroot(".");
+ 	sys_umount("/old/dev", 0);
+ 	close(old_fd);
+ 	close(root_fd);
+ 
+ 	if (real_root_dev == ram0) {
+ 		sys_chdir("/old");
+ 		return;
+ 	}
+ 
+ 	ROOT_DEV = real_root_dev;
+ 	mount_root();
+ 
+ 	printk(KERN_NOTICE "Trying to move old root to /initrd ... ");
+ 	error = sys_mount("/old", "/root/initrd", NULL, MS_MOVE, NULL);
+ 	if (!error)
+ 		printk("okay\n");
+ 	else {
+ 		int fd = open("/dev/root.old", O_RDWR, 0);
+ 		printk("failed\n");
+ 		printk(KERN_NOTICE "Unmounting old root\n");
+ 		sys_umount("/old", MNT_DETACH);
+ 		printk(KERN_NOTICE "Trying to free ramdisk memory ... ");
+ 		if (fd < 0) {
+ 			error = fd;
+ 		} else {
+ 			error = sys_ioctl(fd, BLKFLSBUF, 0);
+ 			close(fd);
+ 		}
+ 		printk(!error ? "okay\n" : "failed\n");
+ 	}
+ #endif
+ }
+ 
+ static int __init initrd_load(void)
+ {
+ #ifdef CONFIG_BLK_DEV_INITRD
+ 	create_dev("/dev/ram", MKDEV(RAMDISK_MAJOR, 0), NULL);
+ 	create_dev("/dev/initrd", MKDEV(RAMDISK_MAJOR, INITRD_MINOR), NULL);
+ #endif
+ 	return rd_load_image("/dev/initrd");
+ }
+ 
+ /*
+  * Prepare the namespace - decide what/where to mount, load ramdisks, etc.
+  */
+ void prepare_namespace(void)
+ {
+ 	int is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR || MAJOR(ROOT_DEV) == 31;
+ #ifdef CONFIG_ALL_PPC
+ 	extern void arch_discover_root(void);
+ 	arch_discover_root();
+ #endif /* CONFIG_ALL_PPC */
+ #ifdef CONFIG_BLK_DEV_INITRD
+ 	if (!initrd_start)
+ 		mount_initrd = 0;
+ 	real_root_dev = ROOT_DEV;
+ #endif
+ 	sys_mkdir("/dev", 0700);
+ 	sys_mkdir("/root", 0700);
+ 	sys_mknod("/dev/console", S_IFCHR|0600, MKDEV(TTYAUX_MAJOR, 1));
+ #ifdef CONFIG_DEVFS_FS
+ 	sys_mount("devfs", "/dev", "devfs", 0, NULL);
+ 	do_devfs = 1;
+ #endif
+ 
+ 	create_dev("/dev/root", ROOT_DEV, NULL);
+ 	if (mount_initrd) {
+ 		if (initrd_load() && ROOT_DEV != MKDEV(RAMDISK_MAJOR, 0)) {
+ 			handle_initrd();
+ 			goto out;
+ 		}
+ 	} else if (is_floppy && rd_doload && rd_load_disk(0))
+ 		ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+ 	mount_root();
+ out:
+ 	sys_umount("/dev", 0);
+ 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
+ 	sys_chroot(".");
+ 	mount_devfs_fs ();
+ }
+ 
+ #ifdef CONFIG_BLK_DEV_RAM
+ 
+ #if defined(BUILD_CRAMDISK) && defined(CONFIG_BLK_DEV_RAM)
+ 
+ /*
+  * gzip declarations
+  */
+ 
+ #define OF(args)  args
+ 
+ #ifndef memzero
+ #define memzero(s, n)     memset ((s), 0, (n))
+ #endif
+ 
+ typedef unsigned char  uch;
+ typedef unsigned short ush;
+ typedef unsigned long  ulg;
+ 
+ #define INBUFSIZ 4096
+ #define WSIZE 0x8000    /* window size--must be a power of two, and */
+ 			/*  at least 32K for zip's deflate method */
+ 
+ static uch *inbuf;
+ static uch *window;
+ 
+ static unsigned insize;  /* valid bytes in inbuf */
+ static unsigned inptr;   /* index of next byte to be processed in inbuf */
+ static unsigned outcnt;  /* bytes in output buffer */
+ static int exit_code;
+ static int unzip_error;
+ static long bytes_out;
+ static int crd_infd, crd_outfd;
+ 
+ #define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+ 		
+ /* Diagnostic functions (stubbed out) */
+ #define Assert(cond,msg)
+ #define Trace(x)
+ #define Tracev(x)
+ #define Tracevv(x)
+ #define Tracec(c,x)
+ #define Tracecv(c,x)
+ 
+ #define STATIC static
+ 
+ static int  fill_inbuf(void);
+ static void flush_window(void);
+ static void *malloc(int size);
+ static void free(void *where);
+ static void error(char *m);
+ static void gzip_mark(void **);
+ static void gzip_release(void **);
+ 
+ #include "../lib/inflate.c"
+ 
+ static void __init *malloc(int size)
+ {
+ 	return kmalloc(size, GFP_KERNEL);
+ }
+ 
+ static void __init free(void *where)
+ {
+ 	kfree(where);
+ }
+ 
+ static void __init gzip_mark(void **ptr)
+ {
+ }
+ 
+ static void __init gzip_release(void **ptr)
+ {
+ }
+ 
+ 
+ /* ===========================================================================
+  * Fill the input buffer. This is called only when the buffer is empty
+  * and at least one byte is really needed.
+  * Returning -1 does not guarantee that gunzip() will ever return.
+  */
+ static int __init fill_inbuf(void)
+ {
+ 	if (exit_code) return -1;
+ 	
+ 	insize = read(crd_infd, inbuf, INBUFSIZ);
+ 	if (insize == 0) {
+ 		error("RAMDISK: ran out of compressed data\n");
+ 		return -1;
+ 	}
+ 
+ 	inptr = 1;
+ 
+ 	return inbuf[0];
+ }
+ 
+ /* ===========================================================================
+  * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+  * (Used for the decompressed data only.)
+  */
+ static void __init flush_window(void)
+ {
+     ulg c = crc;         /* temporary variable */
+     unsigned n, written;
+     uch *in, ch;
+     
+     written = write(crd_outfd, window, outcnt);
+     if (written != outcnt && unzip_error == 0) {
+ 	printk(KERN_ERR "RAMDISK: incomplete write (%d != %d), "
+ 	       "only wrote %ld\n", written, outcnt, bytes_out);
+ 	unzip_error = 1;
+     }
+     in = window;
+     for (n = 0; n < outcnt; n++) {
+ 	    ch = *in++;
+ 	    c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+     }
+     crc = c;
+     bytes_out += (ulg)outcnt;
+     outcnt = 0;
+ }
+ 
+ static void __init error(char *x)
+ {
+ 	printk(KERN_ERR "%s", x);
+ 	exit_code = 1;
+ 	unzip_error = 1;
+ }
+ 
+ static int __init crd_load(int in_fd, int out_fd)
+ {
+ 	int result;
+ 
+ 	insize = 0;		/* valid bytes in inbuf */
+ 	inptr = 0;		/* index of next byte to be processed in inbuf */
+ 	outcnt = 0;		/* bytes in output buffer */
+ 	exit_code = 0;
+ 	bytes_out = 0;
+ 	crc = (ulg)0xffffffffL; /* shift register contents */
+ 
+ 	crd_infd = in_fd;
+ 	crd_outfd = out_fd;
+ 	inbuf = kmalloc(INBUFSIZ, GFP_KERNEL);
+ 	if (inbuf == 0) {
+ 		printk(KERN_ERR "RAMDISK: Couldn't allocate gzip buffer\n");
+ 		return -1;
+ 	}
+ 	window = kmalloc(WSIZE, GFP_KERNEL);
+ 	if (window == 0) {
+ 		printk(KERN_ERR "RAMDISK: Couldn't allocate gzip window\n");
+ 		kfree(inbuf);
+ 		return -1;
+ 	}
+ 	makecrc();
+ 	result = gunzip();
+ 	if (unzip_error)
+ 		result = 1;
+ 	kfree(inbuf);
+ 	kfree(window);
+ 	return result;
+ }
+ 
+ #endif  /* BUILD_CRAMDISK && CONFIG_BLK_DEV_RAM */
+ #endif  /* CONFIG_BLK_DEV_RAM */
+ /*
+  *  linux/init/main.c
+  *
+  *  Copyright (C) 1991, 1992  Linus Torvalds
+  *
+  *  GK 2/5/95  -  Changed to support mounting root fs via NFS
+  *  Added initrd & change_root: Werner Almesberger & Hans Lermen, Feb '96
+  *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May '96
+  *  Simplified starting of init:  Michael A. Griffith <grif@acm.org> 
+  */
+ 
+ #define __KERNEL_SYSCALLS__
+ 
+ #include <linux/config.h>
+ #include <linux/proc_fs.h>
+ #include <linux/devfs_fs_kernel.h>
+ #include <linux/unistd.h>
+ #include <linux/string.h>
+ #include <linux/ctype.h>
+ #include <linux/delay.h>
+ #include <linux/utsname.h>
+ #include <linux/ioport.h>
+ #include <linux/init.h>
+ #include <linux/smp_lock.h>
+ #include <linux/blk.h>
+ #include <linux/hdreg.h>
+ #include <linux/iobuf.h>
+ #include <linux/bootmem.h>
+ #include <linux/file.h>
+ #include <linux/tty.h>
+ 
+ #include <asm/io.h>
+ #include <asm/bugs.h>
+ 
+ #if defined(CONFIG_ARCH_S390)
+ #include <asm/s390mach.h>
+ #include <asm/ccwcache.h>
+ #endif
+ 
+ #ifdef CONFIG_ACPI
+ #include <linux/acpi.h>
+ #endif
+ 
+ #ifdef CONFIG_PCI
+ #include <linux/pci.h>
+ #endif
+ 
+ #ifdef CONFIG_DIO
+ #include <linux/dio.h>
+ #endif
+ 
+ #ifdef CONFIG_ZORRO
+ #include <linux/zorro.h>
+ #endif
+ 
+ #ifdef CONFIG_MTRR
+ #  include <asm/mtrr.h>
+ #endif
+ 
+ #ifdef CONFIG_NUBUS
+ #include <linux/nubus.h>
+ #endif
+ 
+ #ifdef CONFIG_ISAPNP
+ #include <linux/isapnp.h>
+ #endif
+ 
+ #ifdef CONFIG_IRDA
+ extern int irda_proto_init(void);
+ extern int irda_device_init(void);
+ #endif
+ 
+ #ifdef CONFIG_X86_LOCAL_APIC
+ #include <asm/smp.h>
+ #endif
+ 
+ /*
+  * Versions of gcc older than that listed below may actually compile
+  * and link okay, but the end product can have subtle run time bugs.
+  * To avoid associated bogus bug reports, we flatly refuse to compile
+  * with a gcc that is known to be too old from the very beginning.
+  */
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 91)
+ #error Sorry, your GCC is too old. It builds incorrect kernels.
+ #endif
+ 
+ extern char _stext, _etext;
+ extern char *linux_banner;
+ 
+ static int init(void *);
+ 
+ extern void init_IRQ(void);
+ extern void init_modules(void);
+ extern void sock_init(void);
+ extern void fork_init(unsigned long);
+ extern void mca_init(void);
+ extern void sbus_init(void);
+ extern void ppc_init(void);
+ extern void sysctl_init(void);
+ extern void signals_init(void);
+ extern int init_pcmcia_ds(void);
+ 
+ extern void free_initmem(void);
+ 
+ #ifdef CONFIG_TC
+ extern void tc_init(void);
+ #endif
+ 
+ extern void ecard_init(void);
+ 
+ #if defined(CONFIG_SYSVIPC)
+ extern void ipc_init(void);
+ #endif
+ 
+ /*
+  * Boot command-line arguments
+  */
+ #define MAX_INIT_ARGS 8
+ #define MAX_INIT_ENVS 8
+ 
+ extern void time_init(void);
+ extern void softirq_init(void);
+ 
+ int rows, cols;
+ 
+ char *execute_command;
+ 
+ static char * argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
+ char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
+ 
+ static int __init profile_setup(char *str)
+ {
+     int par;
+     if (get_option(&str,&par)) prof_shift = par;
+ 	return 1;
+ }
+ 
+ __setup("profile=", profile_setup);
+ 
+ static int __init checksetup(char *line)
+ {
+ 	struct kernel_param *p;
+ 
+ 	p = &__setup_start;
+ 	do {
+ 		int n = strlen(p->str);
+ 		if (!strncmp(line,p->str,n)) {
+ 			if (p->setup_func(line+n))
+ 				return 1;
+ 		}
+ 		p++;
+ 	} while (p < &__setup_end);
+ 	return 0;
+ }
+ 
+ /* this should be approx 2 Bo*oMips to start (note initial shift), and will
+    still work even if initially too large, it will just take slightly longer */
+ unsigned long loops_per_jiffy = (1<<12);
+ 
+ /* This is the number of bits of precision for the loops_per_jiffy.  Each
+    bit takes on average 1.5/HZ seconds.  This (like the original) is a little
+    better than 1% */
+ #define LPS_PREC 8
+ 
+ void __init calibrate_delay(void)
+ {
+ 	unsigned long ticks, loopbit;
+ 	int lps_precision = LPS_PREC;
+ 
+ 	loops_per_jiffy = (1<<12);
+ 
+ 	printk("Calibrating delay loop... ");
+ 	while (loops_per_jiffy <<= 1) {
+ 		/* wait for "start of" clock tick */
+ 		ticks = jiffies;
+ 		while (ticks == jiffies)
+ 			/* nothing */;
+ 		/* Go .. */
+ 		ticks = jiffies;
+ 		__delay(loops_per_jiffy);
+ 		ticks = jiffies - ticks;
+ 		if (ticks)
+ 			break;
+ 	}
+ 
+ /* Do a binary approximation to get loops_per_jiffy set to equal one clock
+    (up to lps_precision bits) */
+ 	loops_per_jiffy >>= 1;
+ 	loopbit = loops_per_jiffy;
+ 	while ( lps_precision-- && (loopbit >>= 1) ) {
+ 		loops_per_jiffy |= loopbit;
+ 		ticks = jiffies;
+ 		while (ticks == jiffies);
+ 		ticks = jiffies;
+ 		__delay(loops_per_jiffy);
+ 		if (jiffies != ticks)	/* longer than 1 tick */
+ 			loops_per_jiffy &= ~loopbit;
+ 	}
+ 
+ /* Round the value and print it */	
+ 	printk("%lu.%02lu BogoMIPS\n",
+ 		loops_per_jiffy/(500000/HZ),
+ 		(loops_per_jiffy/(5000/HZ)) % 100);
+ }
+ 
+ static int __init debug_kernel(char *str)
+ {
+ 	if (*str)
+ 		return 0;
+ 	console_loglevel = 10;
+ 	return 1;
+ }
+ 
+ static int __init quiet_kernel(char *str)
+ {
+ 	if (*str)
+ 		return 0;
+ 	console_loglevel = 4;
+ 	return 1;
+ }
+ 
+ __setup("debug", debug_kernel);
+ __setup("quiet", quiet_kernel);
+ 
+ /*
+  * This is a simple kernel command line parsing function: it parses
+  * the command line, and fills in the arguments/environment to init
+  * as appropriate. Any cmd-line option is taken to be an environment
+  * variable if it contains the character '='.
+  *
+  * This routine also checks for options meant for the kernel.
+  * These options are not given to init - they are for internal kernel use only.
+  */
+ static void __init parse_options(char *line)
+ {
+ 	char *next,*quote;
+ 	int args, envs;
+ 
+ 	if (!*line)
+ 		return;
+ 	args = 0;
+ 	envs = 1;	/* TERM is set to 'linux' by default */
+ 	next = line;
+ 	while ((line = next) != NULL) {
+                 quote = strchr(line,'"');
+                 next = strchr(line, ' ');
+                 while (next != NULL && quote != NULL && quote < next) {
+                         /* we found a left quote before the next blank
+                          * now we have to find the matching right quote
+                          */
+                         next = strchr(quote+1, '"');
+                         if (next != NULL) {
+                                 quote = strchr(next+1, '"');
+                                 next = strchr(next+1, ' ');
+                         }
+                 }
+                 if (next != NULL)
+                         *next++ = 0;
+ 		if (!strncmp(line,"init=",5)) {
+ 			line += 5;
+ 			execute_command = line;
+ 			/* In case LILO is going to boot us with default command line,
+ 			 * it prepends "auto" before the whole cmdline which makes
+ 			 * the shell think it should execute a script with such name.
+ 			 * So we ignore all arguments entered _before_ init=... [MJ]
+ 			 */
+ 			args = 0;
+ 			continue;
+ 		}
+ 		if (checksetup(line))
+ 			continue;
+ 		
+ 		/*
+ 		 * Then check if it's an environment variable or
+ 		 * an option.
+ 		 */
+ 		if (strchr(line,'=')) {
+ 			if (envs >= MAX_INIT_ENVS)
+ 				break;
+ 			envp_init[++envs] = line;
+ 		} else {
+ 			if (args >= MAX_INIT_ARGS)
+ 				break;
+ 			if (*line)
+ 				argv_init[++args] = line;
+ 		}
+ 	}
+ 	argv_init[args+1] = NULL;
+ 	envp_init[envs+1] = NULL;
+ }
+ 
+ 
+ extern void setup_arch(char **);
+ extern void cpu_idle(void);
+ 
+ unsigned long wait_init_idle;
+ 
+ #ifndef CONFIG_SMP
+ 
+ #ifdef CONFIG_X86_LOCAL_APIC
+ static void __init smp_init(void)
+ {
+ 	APIC_init_uniprocessor();
+ }
+ #else
+ #define smp_init()	do { } while (0)
+ #endif
+ 
+ #else
+ 
+ 
+ /* Called by boot processor to activate the rest. */
+ static void __init smp_init(void)
+ {
+ 	/* Get other processors into their bootup holding patterns. */
+ 	smp_boot_cpus();
+ 	wait_init_idle = cpu_online_map;
+ 	clear_bit(current->processor, &wait_init_idle); /* Don't wait on me! */
+ 
+ 	smp_threads_ready=1;
+ 	smp_commence();
+ 
+ 	/* Wait for the other cpus to set up their idle processes */
+ 	printk("Waiting on wait_init_idle (map = 0x%lx)\n", wait_init_idle);
+ 	while (wait_init_idle) {
+ 		cpu_relax();
+ 		barrier();
+ 	}
+ 	printk("All processors have done init_idle\n");
+ }
+ 
+ #endif
+ 
+ /*
+  * We need to finalize in a non-__init function or else race conditions
+  * between the root thread and the init thread may cause start_kernel to
+  * be reaped by free_initmem before the root thread has proceeded to
+  * cpu_idle.
+  */
+ 
+ static void rest_init(void)
+ {
+ 	kernel_thread(init, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
+ 	unlock_kernel();
+ 	current->need_resched = 1;
+  	cpu_idle();
+ } 
+ 
+ /*
+  *	Activate the first processor.
+  */
+ 
+ asmlinkage void __init start_kernel(void)
+ {
+ 	char * command_line;
+ 	extern char saved_command_line[];
+ /*
+  * Interrupts are still disabled. Do necessary setups, then
+  * enable them
+  */
+ 	lock_kernel();
+ 	printk(linux_banner);
+ 	setup_arch(&command_line);
+ 	printk("Kernel command line: %s\n", saved_command_line);
+ 	parse_options(command_line);
+ 	trap_init();
+ 	init_IRQ();
+ 	sched_init();
+ 	softirq_init();
+ 	time_init();
+ 
+ 	/*
+ 	 * HACK ALERT! This is early. We're enabling the console before
+ 	 * we've done PCI setups etc, and console_init() must be aware of
+ 	 * this. But we do want output early, in case something goes wrong.
+ 	 */
+ 	console_init();
+ #ifdef CONFIG_MODULES
+ 	init_modules();
+ #endif
+ 	if (prof_shift) {
+ 		unsigned int size;
+ 		/* only text is profiled */
+ 		prof_len = (unsigned long) &_etext - (unsigned long) &_stext;
+ 		prof_len >>= prof_shift;
+ 		
+ 		size = prof_len * sizeof(unsigned int) + PAGE_SIZE-1;
+ 		prof_buffer = (unsigned int *) alloc_bootmem(size);
+ 	}
+ 
+ 	kmem_cache_init();
+ 	sti();
+ 	calibrate_delay();
+ #ifdef CONFIG_BLK_DEV_INITRD
+ 	if (initrd_start && !initrd_below_start_ok &&
+ 			initrd_start < min_low_pfn << PAGE_SHIFT) {
+ 		printk(KERN_CRIT "initrd overwritten (0x%08lx < 0x%08lx) - "
+ 		    "disabling it.\n",initrd_start,min_low_pfn << PAGE_SHIFT);
+ 		initrd_start = 0;
+ 	}
+ #endif
+ 	mem_init();
+ 	kmem_cache_sizes_init();
+ 	pgtable_cache_init();
+ 
+ 	/*
+ 	 * For architectures that have highmem, num_mappedpages represents
+ 	 * the amount of memory the kernel can use.  For other architectures
+ 	 * it's the same as the total pages.  We need both numbers because
+ 	 * some subsystems need to initialize based on how much memory the
+ 	 * kernel can use.
+ 	 */
+ 	if (num_mappedpages == 0)
+ 		num_mappedpages = num_physpages;
+   
+ 	fork_init(num_mappedpages);
+ 	proc_caches_init();
+ 	vfs_caches_init(num_physpages);
+ 	buffer_init(num_physpages);
+ 	page_cache_init(num_physpages);
+ #if defined(CONFIG_ARCH_S390)
+ 	ccwcache_init();
+ #endif
+ 	signals_init();
+ #ifdef CONFIG_PROC_FS
+ 	proc_root_init();
+ #endif
+ 	check_bugs();
+ 	printk("POSIX conformance testing by UNIFIX\n");
+ 
+ 	/* 
+ 	 *	We count on the initial thread going ok 
+ 	 *	Like idlers init is an unlocked kernel thread, which will
+ 	 *	make syscalls (and thus be locked).
+ 	 */
+ 	smp_init();
+ #if defined(CONFIG_SYSVIPC)
+ 	ipc_init();
+ #endif
+ 	rest_init();
+ }
+ 
+ struct task_struct *child_reaper = &init_task;
+ 
+ static void __init do_initcalls(void)
+ {
+ 	initcall_t *call;
+ 
+ 	call = &__initcall_start;
+ 	do {
+ 		(*call)();
+ 		call++;
+ 	} while (call < &__initcall_end);
+ 
+ 	/* Make sure there is no pending stuff from the initcall sequence */
+ 	flush_scheduled_tasks();
+ }
+ 
+ /*
+  * Ok, the machine is now initialized. None of the devices
+  * have been touched yet, but the CPU subsystem is up and
+  * running, and memory and process management works.
+  *
+  * Now we can finally start doing some real work..
+  */
+ static void __init do_basic_setup(void)
+ {
+ 
+ 	/*
+ 	 * Tell the world that we're going to be the grim
+ 	 * reaper of innocent orphaned children.
+ 	 *
+ 	 * We don't want people to have to make incorrect
+ 	 * assumptions about where in the task array this
+ 	 * can be found.
+ 	 */
+ 	child_reaper = current;
+ 
+ #if defined(CONFIG_MTRR)	/* Do this after SMP initialization */
+ /*
+  * We should probably create some architecture-dependent "fixup after
+  * everything is up" style function where this would belong better
+  * than in init/main.c..
+  */
+ 	mtrr_init();
+ #endif
+ 
+ #ifdef CONFIG_SYSCTL
+ 	sysctl_init();
+ #endif
+ 
+ 	/*
+ 	 * Ok, at this point all CPU's should be initialized, so
+ 	 * we can start looking into devices..
+ 	 */
+ #if defined(CONFIG_ARCH_S390)
+ 	s390_init_machine_check();
+ #endif
+ #ifdef CONFIG_ACPI_INTERPRETER
+ 	acpi_init();
+ #endif
+ #ifdef CONFIG_PCI
+ 	pci_init();
+ #endif
+ #ifdef CONFIG_SBUS
+ 	sbus_init();
+ #endif
+ #if defined(CONFIG_PPC)
+ 	ppc_init();
+ #endif
+ #ifdef CONFIG_MCA
+ 	mca_init();
+ #endif
+ #ifdef CONFIG_ARCH_ACORN
+ 	ecard_init();
+ #endif
+ #ifdef CONFIG_ZORRO
+ 	zorro_init();
+ #endif
+ #ifdef CONFIG_DIO
+ 	dio_init();
+ #endif
+ #ifdef CONFIG_NUBUS
+ 	nubus_init();
+ #endif
+ #ifdef CONFIG_ISAPNP
+ 	isapnp_init();
+ #endif
+ #ifdef CONFIG_TC
+ 	tc_init();
+ #endif
+ 
+ 	/* Networking initialization needs a process context */ 
+ 	sock_init();
+ 
+ 	start_context_thread();
+ 	do_initcalls();
+ 
+ #ifdef CONFIG_IRDA
+ 	irda_proto_init();
+ 	irda_device_init(); /* Must be done after protocol initialization */
+ #endif
+ #ifdef CONFIG_PCMCIA
+ 	init_pcmcia_ds();		/* Do this last */
+ #endif
+ }
+ 
+ static void run_init_process(char *init_filename)
+ {
+ 	argv_init[0] = init_filename;
+ 	execve(init_filename, argv_init, envp_init);
+ }
+ 
+ extern void prepare_namespace(void);
+ 
+ static int init(void * unused)
+ {
+ 	struct files_struct *files;
+ 	lock_kernel();
+ 	do_basic_setup();
+ 
+ 	prepare_namespace();
+ 
+ 	/*
+ 	 * Ok, we have completed the initial bootup, and
+ 	 * we're essentially up and running. Get rid of the
+ 	 * initmem segments and start the user-mode stuff..
+ 	 */
+ 	free_initmem();
+ 	unlock_kernel();
+ 	
+ 	/*
+ 	 * Right now we are a thread sharing with a ton of kernel
+ 	 * stuff. We don't want to end up in user space in that state
+ 	 */
+ 	 
+ 	files = current->files;
+ 	if(unshare_files())
+ 		panic("unshare");
+ 	put_files_struct(files);
+ 	
+ 	if (open("/dev/console", O_RDWR, 0) < 0)
+ 		printk("Warning: unable to open an initial console.\n");
+ 
+ 	(void) dup(0);
+ 	(void) dup(0);
+ 	
+ 	/*
+ 	 * We try each of these until one succeeds.
+ 	 *
+ 	 * The Bourne shell can be used instead of init if we are 
+ 	 * trying to recover a really broken machine.
+ 	 */
+ 
+ 	if (execute_command)
+ 		run_init_process(execute_command);
+ 
+ 	run_init_process("/sbin/init");
+ 	run_init_process("/etc/init");
+ 	run_init_process("/bin/init");
+ 	run_init_process("/bin/sh");
+ 
+ 	panic("No init found.  Try passing init= option to kernel.");
+ }
+ /*
+  *  linux/init/version.c
+  *
+  *  Copyright (C) 1992  Theodore Ts'o
+  *
+  *  May be freely distributed as part of Linux.
+  */
+ 
+ #include <linux/uts.h>
+ #include <linux/utsname.h>
+ #include <linux/version.h>
+ #include <linux/compile.h>
+ 
+ #define version(a) Version_ ## a
+ #define version_string(a) version(a)
+ 
+ int version_string(LINUX_VERSION_CODE);
+ 
+ struct new_utsname system_utsname = {
+ 	UTS_SYSNAME, UTS_NODENAME, UTS_RELEASE, UTS_VERSION,
+ 	UTS_MACHINE, UTS_DOMAINNAME
+ };
+ 
+ const char *linux_banner = 
+ 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
+ 	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
diff -crBN linux-2.4.27/kernel/sysctl.c linux-2.4.27-w/kernel/sysctl.c
*** linux-2.4.27/kernel/sysctl.c	2004-08-07 16:26:06.000000000 -0700
--- linux-2.4.27-w/kernel/sysctl.c	2013-01-22 23:03:30.511023654 -0800
***************
*** 857,862 ****
--- 857,864 ----
  	int *i, vleft, first=1, neg, val;
  	size_t left, len;
  	
+         char * chbuffer = (char *) buffer;
+         
  	#define TMPBUFLEN 20
  	char buf[TMPBUFLEN], *p;
  	
***************
*** 874,885 ****
  		if (write) {
  			while (left) {
  				char c;
! 				if (get_user(c, (char *) buffer))
  					return -EFAULT;
  				if (!isspace(c))
  					break;
  				left--;
! 				((char *) buffer)++;
  			}
  			if (!left)
  				break;
--- 876,887 ----
  		if (write) {
  			while (left) {
  				char c;
! 				if (get_user(c, chbuffer))
  					return -EFAULT;
  				if (!isspace(c))
  					break;
  				left--;
! 				chbuffer++;
  			}
  			if (!left)
  				break;
***************
*** 887,893 ****
  			len = left;
  			if (len > TMPBUFLEN-1)
  				len = TMPBUFLEN-1;
! 			if(copy_from_user(buf, buffer, len))
  				return -EFAULT;
  			buf[len] = 0;
  			p = buf;
--- 889,895 ----
  			len = left;
  			if (len > TMPBUFLEN-1)
  				len = TMPBUFLEN-1;
! 			if(copy_from_user(buf, chbuffer, len))
  				return -EFAULT;
  			buf[len] = 0;
  			p = buf;
***************
*** 903,909 ****
  				break;
  			if (neg)
  				val = -val;
! 			buffer += len;
  			left -= len;
  			switch(op) {
  			case OP_SET:	*i = val; break;
--- 905,911 ----
  				break;
  			if (neg)
  				val = -val;
! 			chbuffer += len;
  			left -= len;
  			switch(op) {
  			case OP_SET:	*i = val; break;
***************
*** 924,943 ****
  			len = strlen(buf);
  			if (len > left)
  				len = left;
! 			if(copy_to_user(buffer, buf, len))
  				return -EFAULT;
  			left -= len;
! 			buffer += len;
  		}
  	}
  
  	if (!write && !first && left) {
! 		if(put_user('\n', (char *) buffer))
  			return -EFAULT;
! 		left--, buffer++;
  	}
  	if (write) {
! 		p = (char *) buffer;
  		while (left) {
  			char c;
  			if (get_user(c, p++))
--- 926,945 ----
  			len = strlen(buf);
  			if (len > left)
  				len = left;
! 			if(copy_to_user(chbuffer, buf, len))
  				return -EFAULT;
  			left -= len;
! 			chbuffer += len;
  		}
  	}
  
  	if (!write && !first && left) {
! 		if(put_user('\n', chbuffer))
  			return -EFAULT;
! 		left--, chbuffer++;
  	}
  	if (write) {
! 		p = chbuffer;
  		while (left) {
  			char c;
  			if (get_user(c, p++))
***************
*** 1010,1016 ****
  	size_t len, left;
  	#define TMPBUFLEN 20
  	char buf[TMPBUFLEN], *p;
! 	
  	if (!table->data || !table->maxlen || !*lenp ||
  	    (filp->f_pos && !write)) {
  		*lenp = 0;
--- 1012,1018 ----
  	size_t len, left;
  	#define TMPBUFLEN 20
  	char buf[TMPBUFLEN], *p;
! 	char * chbuffer = (char *) buffer;
  	if (!table->data || !table->maxlen || !*lenp ||
  	    (filp->f_pos && !write)) {
  		*lenp = 0;
***************
*** 1027,1038 ****
  		if (write) {
  			while (left) {
  				char c;
! 				if (get_user(c, (char *) buffer))
  					return -EFAULT;
  				if (!isspace(c))
  					break;
  				left--;
! 				((char *) buffer)++;
  			}
  			if (!left)
  				break;
--- 1029,1040 ----
  		if (write) {
  			while (left) {
  				char c;
! 				if (get_user(c, chbuffer))
  					return -EFAULT;
  				if (!isspace(c))
  					break;
  				left--;
! 				chbuffer++;
  			}
  			if (!left)
  				break;
***************
*** 1040,1046 ****
  			len = left;
  			if (len > TMPBUFLEN-1)
  				len = TMPBUFLEN-1;
! 			if(copy_from_user(buf, buffer, len))
  				return -EFAULT;
  			buf[len] = 0;
  			p = buf;
--- 1042,1048 ----
  			len = left;
  			if (len > TMPBUFLEN-1)
  				len = TMPBUFLEN-1;
! 			if(copy_from_user(buf, chbuffer, len))
  				return -EFAULT;
  			buf[len] = 0;
  			p = buf;
***************
*** 1056,1062 ****
  				break;
  			if (neg)
  				val = -val;
! 			buffer += len;
  			left -= len;
  
  			if ((min && val < *min) || (max && val > *max))
--- 1058,1064 ----
  				break;
  			if (neg)
  				val = -val;
! 			chbuffer += len;
  			left -= len;
  
  			if ((min && val < *min) || (max && val > *max))
***************
*** 1070,1089 ****
  			len = strlen(buf);
  			if (len > left)
  				len = left;
! 			if(copy_to_user(buffer, buf, len))
  				return -EFAULT;
  			left -= len;
! 			buffer += len;
  		}
  	}
  
  	if (!write && !first && left) {
! 		if(put_user('\n', (char *) buffer))
  			return -EFAULT;
! 		left--, buffer++;
  	}
  	if (write) {
! 		p = (char *) buffer;
  		while (left) {
  			char c;
  			if (get_user(c, p++))
--- 1072,1091 ----
  			len = strlen(buf);
  			if (len > left)
  				len = left;
! 			if(copy_to_user(chbuffer, buf, len))
  				return -EFAULT;
  			left -= len;
! 			chbuffer += len;
  		}
  	}
  
  	if (!write && !first && left) {
! 		if(put_user('\n', chbuffer))
  			return -EFAULT;
! 		left--, chbuffer++;
  	}
  	if (write) {
! 		p = chbuffer;
  		while (left) {
  			char c;
  			if (get_user(c, p++))
***************
*** 1111,1117 ****
  	int vleft, first=1, neg;
  	size_t len, left;
  	char buf[TMPBUFLEN], *p;
! 	
  	if (!table->data || !table->maxlen || !*lenp ||
  	    (filp->f_pos && !write)) {
  		*lenp = 0;
--- 1113,1119 ----
  	int vleft, first=1, neg;
  	size_t len, left;
  	char buf[TMPBUFLEN], *p;
! 	char * chbuffer = (char *) buffer;	
  	if (!table->data || !table->maxlen || !*lenp ||
  	    (filp->f_pos && !write)) {
  		*lenp = 0;
***************
*** 1128,1139 ****
  		if (write) {
  			while (left) {
  				char c;
! 				if (get_user(c, (char *) buffer))
  					return -EFAULT;
  				if (!isspace(c))
  					break;
  				left--;
! 				((char *) buffer)++;
  			}
  			if (!left)
  				break;
--- 1130,1141 ----
  		if (write) {
  			while (left) {
  				char c;
! 				if (get_user(c, chbuffer))
  					return -EFAULT;
  				if (!isspace(c))
  					break;
  				left--;
! 				chbuffer++;
  			}
  			if (!left)
  				break;
***************
*** 1141,1147 ****
  			len = left;
  			if (len > TMPBUFLEN-1)
  				len = TMPBUFLEN-1;
! 			if(copy_from_user(buf, buffer, len))
  				return -EFAULT;
  			buf[len] = 0;
  			p = buf;
--- 1143,1149 ----
  			len = left;
  			if (len > TMPBUFLEN-1)
  				len = TMPBUFLEN-1;
! 			if(copy_from_user(buf, chbuffer, len))
  				return -EFAULT;
  			buf[len] = 0;
  			p = buf;
***************
*** 1157,1163 ****
  				break;
  			if (neg)
  				val = -val;
! 			buffer += len;
  			left -= len;
  
  			if(neg)
--- 1159,1165 ----
  				break;
  			if (neg)
  				val = -val;
! 			chbuffer += len;
  			left -= len;
  
  			if(neg)
***************
*** 1175,1194 ****
  			len = strlen(buf);
  			if (len > left)
  				len = left;
! 			if(copy_to_user(buffer, buf, len))
  				return -EFAULT;
  			left -= len;
! 			buffer += len;
  		}
  	}
  
  	if (!write && !first && left) {
! 		if(put_user('\n', (char *) buffer))
  			return -EFAULT;
! 		left--, buffer++;
  	}
  	if (write) {
! 		p = (char *) buffer;
  		while (left) {
  			char c;
  			if (get_user(c, p++))
--- 1177,1196 ----
  			len = strlen(buf);
  			if (len > left)
  				len = left;
! 			if(copy_to_user(chbuffer, buf, len))
  				return -EFAULT;
  			left -= len;
! 			chbuffer += len;
  		}
  	}
  
  	if (!write && !first && left) {
! 		if(put_user('\n', chbuffer))
  			return -EFAULT;
! 		left--, chbuffer++;
  	}
  	if (write) {
! 		p = chbuffer;
  		while (left) {
  			char c;
  			if (get_user(c, p++))
diff -crBN linux-2.4.27/Makefile linux-2.4.27-w/Makefile
*** linux-2.4.27/Makefile	2013-01-22 23:36:39.251023638 -0800
--- linux-2.4.27-w/Makefile	2013-01-22 23:03:30.511023654 -0800
***************
*** 5,11 ****
  
  KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
  
! ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
  KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
  
  CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
--- 5,11 ----
  
  KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
  
! ARCH := arm
  KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
  
  CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
***************
*** 19,26 ****
  HOSTCC  	= gcc
  HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
  
! CROSS_COMPILE 	=
! 
  #
  # Include the make variables (CC, etc...)
  #
--- 19,25 ----
  HOSTCC  	= gcc
  HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
  
! CROSS_COMPILE 	= arm-uclinuxeabi-
  #
  # Include the make variables (CC, etc...)
  #
***************
*** 38,44 ****
  GENKSYMS	= /sbin/genksyms
  DEPMOD		= /sbin/depmod
  MODFLAGS	= -DMODULE
! CFLAGS_KERNEL	=
  PERL		= perl
  AWK		= awk
  RPM 		:= $(shell if [ -x "/usr/bin/rpmbuild" ]; then echo rpmbuild; \
--- 37,44 ----
  GENKSYMS	= /sbin/genksyms
  DEPMOD		= /sbin/depmod
  MODFLAGS	= -DMODULE
! CFLAGS_KERNEL   = -march=armv2a -mno-thumb-interwork -mabi=apcs-gnu
! LDFLAGS 	= -fix-v4bx
  PERL		= perl
  AWK		= awk
  RPM 		:= $(shell if [ -x "/usr/bin/rpmbuild" ]; then echo rpmbuild; \
diff -crBN linux-2.4.27/mm/slab.c linux-2.4.27-w/mm/slab.c
*** linux-2.4.27/mm/slab.c	2013-01-22 23:36:40.111023652 -0800
--- linux-2.4.27-w/mm/slab.c	2013-01-22 23:03:30.511023654 -0800
***************
*** 1555,1566 ****
  void * kmalloc (size_t size, int flags)
  {
  	cache_sizes_t *csizep = cache_sizes;
  
  	for (; csizep->cs_size; csizep++) {
  		if (size > csizep->cs_size)
  			continue;
! 		return __kmem_cache_alloc(flags & GFP_DMA ?
! 			 csizep->cs_dmacachep : csizep->cs_cachep, flags);
  	}
  	return NULL;
  }
--- 1555,1568 ----
  void * kmalloc (size_t size, int flags)
  {
  	cache_sizes_t *csizep = cache_sizes;
+ void * buf;        
  
  	for (; csizep->cs_size; csizep++) {
  		if (size > csizep->cs_size)
  			continue;
!                 buf =  __kmem_cache_alloc(flags & GFP_DMA ?
! 			 csizep->cs_dmacachep : csizep->cs_cachep, flags);       
! 		return buf;
  	}
  	return NULL;
  }
***************
*** 2076,2078 ****
--- 2078,2118 ----
  #endif
  }
  #endif
+ 
+ #define MAP_NR(addr)      (((unsigned long) (addr) - PAGE_OFFSET) >> PAGE_SHIFT)
+ 
+ size_t
+ ksize(const void *objp)
+ {
+ 	struct page *page;
+ 	kmem_cache_t *c;
+ 	unsigned long flags;
+ 	int size;
+ 
+ 	if (!objp)
+ 		return(0);
+ 	local_irq_save(flags);
+ 	size = MAP_NR(objp);
+ 	if (size < 0 || size >= max_mapnr)
+ 		return(0);
+ 	page = &mem_map[size];
+ 
+ 	if (!PageSlab(page)) { /* not allocated with kmalloc */
+ #ifdef CONFIG_CONTIGUOUS_PAGE_ALLOC
+ 		if (page_contig(page))
+ 			size = page_contig(page) * PAGE_SIZE;
+ 		else
+ #endif
+ 		if (page->index < 0 || page->index >= MAX_ORDER) {
+ 			printk("ksize on unknown page type (index=%ld)!\n", page->index);
+ 			size = PAGE_SIZE;
+ 		} else
+ 			size = PAGE_SIZE << page->index;
+ 	} else {
+ 		CHECK_PAGE(page);
+ 		c = GET_PAGE_CACHE(page);
+ 		size = c->objsize;
+ 	}
+ 	local_irq_restore(flags);
+ 	return size;
+ }
